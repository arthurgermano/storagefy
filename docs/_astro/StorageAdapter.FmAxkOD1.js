import{g as h,r as b,a as C,b as E}from"./generateSimpleId.DxAnr5Wo.js";globalThis.storagefyDebug=!0;globalThis.storagefyDebugLevel=0;const o=(...t)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=0&&(t.unshift("Storagefy Error:"),console.error(...t))},u=(...t)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=1&&(t.unshift("Storagefy Warn:"),console.warn(...t))},a=(...t)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=2&&(t.unshift("Storagefy:"),console.info(...t))};var S=b();const y=h(S);var v=C();const m=h(v),g=new TextEncoder,x=new TextDecoder;let l,c;function A(){try{if(a("CryptoHelper - Attempting to initialize crypto engine"),typeof window<"u"&&window.crypto){l=window.crypto,c=l.subtle,a("CryptoHelper - Crypto initialized from window.crypto");return}if(typeof global<"u"&&global.crypto?.webcrypto){l=global.crypto.webcrypto,c=l.subtle,a("CryptoHelper - Crypto initialized from global.webcrypto");return}throw new Error("Crypto API not available")}catch(t){throw o("Failed to initialize crypto:",t),t}}try{A()}catch(t){o("Failed to initialize crypto:",t)}const T=async t=>{try{return a("CryptoHelper - Generating key material from password"),c.importKey("raw",g.encode(t),"PBKDF2",!1,["deriveKey"])}catch(e){throw o("Error generating key material:",e),e}},f=async(t,e,r=!1)=>{try{if(typeof t!="string"||!t.length)throw new Error("Invalid password");a("CryptoHelper - Deriving key with PBKDF2",{passwordLength:t.length,extractable:r});const n=await T(t);return c.deriveKey({name:"PBKDF2",salt:g.encode(e),iterations:1e5,hash:"SHA-256"},n,{name:"AES-GCM",length:256},r,["encrypt","decrypt"])}catch(n){throw o("Error deriving key:",n),n}},D=async(t,e,r=!1)=>{if(e===void 0||typeof e=="function"||typeof e=="symbol")throw new Error("Invalid data type for encryption");try{a("CryptoHelper - Encrypting data",{raw:r});const n=l.getRandomValues(new Uint8Array(12)),i=g.encode(JSON.stringify(e)),s=await c.encrypt({name:"AES-GCM",iv:n},t,i);if(r)return{iv:n,data:new Uint8Array(s)};const p=y(String.fromCharCode(...n)),d=y(String.fromCharCode(...new Uint8Array(s)));return{iv:p,data:d}}catch(n){throw o("Error encrypting data:",n),n}},_=async(t,e,r=!1)=>{let n,i;try{if(a("CryptoHelper - Decrypting data",{raw:r}),r)n=new Uint8Array(e.iv),i=new Uint8Array(e.data);else{const p=d=>new Uint8Array(m(d).split("").map(w=>w.charCodeAt(0)));n=p(e.iv),i=p(e.data)}const s=await c.decrypt({name:"AES-GCM",iv:n},t,i);return JSON.parse(x.decode(s))}catch(s){throw o("Error decrypting data:",s),s}};function I(t){if(!t)return t;a("CryptoHelper - Obfuscating string");try{const e=[...t].map(r=>String.fromCharCode(r.charCodeAt(0)+1)).join("");return y(e)}catch{return t}}function F(t){if(!t)return t;a("CryptoHelper - Deobfuscating string");try{return[...m(t)].map(r=>String.fromCharCode(r.charCodeAt(0)-1)).join("")}catch{return t}}var N=E();const $=h(N);class k{constructor(e){try{typeof e!="string"&&(e=$("storagefy_channel")),this.channel=new BroadcastChannel(e),this.channelName=e,a(`CrossTabChannel initialized on channel "${e}"`)}catch(r){throw o("Failed to initialize BroadcastChannel:",r),r}}subscribe(e){if(typeof e!="function"){u("CrossTabChannel.subscribe: Provided callback is not a function.");return}this.channel.onmessage=r=>{a("CrossTabChannel - Received message:",r.data);try{e(r.data)}catch(n){o("Error in CrossTabChannel subscriber callback:",n)}},a("CrossTabChannel - Subscribed to incoming messages.")}emit(e){try{this.channel.postMessage(e),a("CrossTabChannel - Emitted message:",e)}catch(r){o("CrossTabChannel.emit: Failed to send message:",r)}}close(){try{this.channel.close(),a("CrossTabChannel - Channel closed.")}catch(e){o("CrossTabChannel.close: Error closing channel:",e)}}}class K{constructor(e){e?(a("StorageAdapter - Initializing cross-tab channel:",e),this.channelName=e,this.channel=new k(e)):(this.channel=null,this.channelName=null,u("StorageAdapter - No channel name provided, cross-tab syncing disabled."))}async get(e){throw new Error("Not implemented")}async set(e,r,n){throw new Error("Not implemented")}async delete(e){throw new Error("Not implemented")}async list(e=""){throw new Error("Not implemented")}async reset(){throw new Error("Not implemented")}async clear(){throw new Error("Not implemented")}async clearExpire(){throw new Error("Not implemented")}async setExpire(e,r){throw new Error("Not implemented")}async deleteExpire(e){throw new Error("Not implemented")}async has(e){throw new Error("Not implemented")}async _encrypt(e,r){if(!this.encrypt||!e)return r;try{const n=await f(e),i=await D(n,r,!1);return a(`StorageAdapter - Successfully encrypted value for key "${e}".`),JSON.stringify(i)}catch(n){return o("Encryption failed:",n),null}}async _decrypt(e,r){if(!this.encrypt||!e)return JSON.parse(r);try{const n=await f(e),i=JSON.parse(r),s=await _(n,i,!1);return a(`StorageAdapter - Successfully decrypted value for key "${e}".`),JSON.parse(s)}catch(n){return o("Decryption failed:",n),null}}_fullKey(e){const r=`${this.prefix}${e}`;if(this.encrypt){const n=I(r);return a(`StorageAdapter - Obfuscated key "${e}" to "${n}".`),n}return a(`StorageAdapter - Using plain key: "${r}"`),r}_startExpireWatcher(){this._expireTimer&&clearInterval(this._expireTimer),!(this.expireCheckInterval<=0)&&(this._expireTimer=setInterval(()=>{try{a("StorageAdapter - Running expiration cleanup..."),this.clearExpire()}catch(e){o("Error clearing expired keys:",e)}},this.expireCheckInterval),a(`StorageAdapter - Expire watcher started, interval: ${this.expireCheckInterval}ms`))}destroy(){this._expireTimer&&(clearInterval(this._expireTimer),this._expireTimer=null,a("StorageAdapter - Expire watcher stopped.")),this._unloadHandler&&(window.removeEventListener("beforeunload",this._unloadHandler),this._unloadHandler=null,a("StorageAdapter - Removed unload handler."))}async getAll(e){return a(`StorageAdapter - Getting all keys under table: "${e}"`),this.list(`${e}__`)}async getExpire(e){try{const r=await this._loadExpires();return a(`StorageAdapter - Getting expiration for key "${e}":`,r[e]||null),r[e]||null}catch(r){return o(`Error getting expire for key '${e}':`,r),null}}emitDataChange(e,r,n){!this.channelName||!n||(a(`StorageAdapter - Emitting data change for key "${e}" from origin "${n}"`),this.channel.emit({adapterId:this.adapterId,key:e,value:r,origin:n}))}onDataChanged(e){!this.channelName||typeof e!="function"||(a("StorageAdapter - Subscribing to cross-tab data changes."),this.channel.subscribe(e))}}export{K as S,a,$ as g,o as l,F as s};
