import{n as f,W as P,$ as _}from"./generateSimpleId.1pzoLIeQ.js";import{t as J}from"./sleep.B0B6IrN2.js";import{j as F}from"./assign.MzTrJBn8.js";import{c as H,d as G}from"./pinia.Cu2Pq-U4.js";import{_ as z}from"./_plugin-vue_export-helper.DlAUqK2U.js";import{c as S,a as M,f as U,b,d as C,o as D,w as I,e as x}from"./runtime-core.esm-bundler.CumKEaZd.js";globalThis.storagefyDebug=!1;globalThis.storagefyDebugLevel=0;var n=(...e)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=0&&(e.unshift("Storagefy Error:"),console.error(...e))},B=(...e)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=1&&(e.unshift("Storagefy Warn:"),console.warn(...e))},i=(...e)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=2&&(e.unshift("Storagefy:"),console.info(...e))},N=new TextEncoder,W=new TextDecoder,u,g;async function j(){var e;try{if(i("CryptoHelper - Attempting to initialize crypto engine"),typeof window<"u"&&window.crypto){u=window.crypto,g=u.subtle,i("CryptoHelper - Crypto initialized from window.crypto");return}if(typeof global<"u"&&(e=globalThis.crypto)!=null&&e.webcrypto){u=globalThis.crypto.webcrypto,g=u.subtle,i("CryptoHelper - Crypto initialized from globalThis.webcrypto");return}throw new Error("Crypto API not available")}catch(t){throw n("Failed to initialize crypto:",t),t}}await j();var V=async e=>{try{return i("CryptoHelper - Generating key material from password"),g.importKey("raw",N.encode(e),"PBKDF2",!1,["deriveKey"])}catch(t){throw n("Error generating key material:",t),t}},T=async(e,t,r=!1)=>{try{if(typeof e!="string"||!e.length)throw new Error("Invalid password");i("CryptoHelper - Deriving key with PBKDF2",{passwordLength:e.length,extractable:r});let a=await V(e);return g.deriveKey({name:"PBKDF2",salt:N.encode(t),iterations:1e5,hash:"SHA-256"},a,{name:"AES-GCM",length:256},r,["encrypt","decrypt"])}catch(a){throw n("Error deriving key:",a),a}},Y=async(e,t,r=!1)=>{if(t===void 0||typeof t=="function"||typeof t=="symbol")throw new Error("Invalid data type for encryption");try{i("CryptoHelper - Encrypting data",{raw:r});let a=u.getRandomValues(new Uint8Array(12)),s=N.encode(JSON.stringify(t)),o=await g.encrypt({name:"AES-GCM",iv:a},e,s);if(r)return{iv:a,data:new Uint8Array(o)};let l=_(String.fromCharCode(...a)),c=_(String.fromCharCode(...new Uint8Array(o)));return{iv:l,data:c}}catch(a){throw n("Error encrypting data:",a),a}},q=async(e,t,r=!1)=>{let a,s;try{if(i("CryptoHelper - Decrypting data",{raw:r}),r)a=new Uint8Array(t.iv),s=new Uint8Array(t.data);else{let l=c=>new Uint8Array(P(c).split("").map(h=>h.charCodeAt(0)));a=l(t.iv),s=l(t.data)}let o=await g.decrypt({name:"AES-GCM",iv:a},e,s);return JSON.parse(W.decode(o))}catch(o){throw n("Error decrypting data:",o),o}};function Q(e){if(!e)return e;i("CryptoHelper - Obfuscating string");try{let t=[...e].map(r=>String.fromCharCode(r.charCodeAt(0)+1)).join("");return _(t)}catch{return e}}function A(e){if(!e)return e;i("CryptoHelper - Deobfuscating string");try{return[...P(e)].map(t=>String.fromCharCode(t.charCodeAt(0)-1)).join("")}catch{return e}}var X=class{constructor(e){try{typeof e!="string"&&(e=f("storagefy_channel")),this.channel=new BroadcastChannel(e),this.channelName=e,i(`CrossTabChannel initialized on channel "${e}"`)}catch(t){throw n("Failed to initialize BroadcastChannel:",t),t}}subscribe(e){if(typeof e!="function"){B("CrossTabChannel.subscribe: Provided callback is not a function.");return}this.channel.onmessage=t=>{i("CrossTabChannel - Received message:",t.data);try{e(t.data)}catch(r){n("Error in CrossTabChannel subscriber callback:",r)}},i("CrossTabChannel - Subscribed to incoming messages.")}emit(e){try{this.channel.postMessage(e),i("CrossTabChannel - Emitted message:",e)}catch(t){n("CrossTabChannel.emit: Failed to send message:",t)}}close(){try{this.channel.close(),i("CrossTabChannel - Channel closed.")}catch(e){n("CrossTabChannel.close: Error closing channel:",e)}}},Z=X,ee=class{constructor(e){e?(i("StorageAdapter - Initializing cross-tab channel:",e),this.channelName=e,this.channel=new Z(e)):(this.channel=null,this.channelName=null,B("StorageAdapter - No channel name provided, cross-tab syncing disabled."))}async get(e){throw new Error("Not implemented")}async set(e,t,r){throw new Error("Not implemented")}async delete(e){throw new Error("Not implemented")}async list(e=""){throw new Error("Not implemented")}async reset(){throw new Error("Not implemented")}async clear(){throw new Error("Not implemented")}async clearExpire(){throw new Error("Not implemented")}async setExpire(e,t){throw new Error("Not implemented")}async deleteExpire(e){throw new Error("Not implemented")}async has(e){throw new Error("Not implemented")}async _encrypt(e,t){if(!this.encrypt||!e)return t;try{let r=await T(e),a=await Y(r,t,!1);return i(`StorageAdapter - Successfully encrypted value for key "${e}".`),JSON.stringify(a)}catch(r){return n("Encryption failed:",r),null}}async _decrypt(e,t){if(!this.encrypt||!e)return JSON.parse(t);try{let r=await T(e),a=JSON.parse(t),s=await q(r,a,!1);return i(`StorageAdapter - Successfully decrypted value for key "${e}".`),JSON.parse(s)}catch(r){return n("Decryption failed:",r),null}}_fullKey(e){let t=`${this.prefix}${e}`;if(this.encrypt){let r=Q(t);return i(`StorageAdapter - Obfuscated key "${e}" to "${r}".`),r}return i(`StorageAdapter - Using plain key: "${t}"`),t}_startExpireWatcher(){this._expireTimer&&clearInterval(this._expireTimer),!(this.expireCheckInterval<=0)&&(this._expireTimer=setInterval(()=>{try{i("StorageAdapter - Running expiration cleanup..."),this.clearExpire()}catch(e){n("Error clearing expired keys:",e)}},this.expireCheckInterval),i(`StorageAdapter - Expire watcher started, interval: ${this.expireCheckInterval}ms`))}destroy(){this._expireTimer&&(clearInterval(this._expireTimer),this._expireTimer=null,i("StorageAdapter - Expire watcher stopped.")),this._unloadHandler&&(window.removeEventListener("beforeunload",this._unloadHandler),this._unloadHandler=null,i("StorageAdapter - Removed unload handler."))}async getAll(e){return i(`StorageAdapter - Getting all keys under table: "${e}"`),this.list(`${e}__`)}async getExpire(e){try{let t=await this._loadExpires();return i(`StorageAdapter - Getting expiration for key "${e}":`,t[e]||null),t[e]||null}catch(t){return n(`Error getting expire for key '${e}':`,t),null}}emitDataChange(e,t,r){!this.channelName||!r||(i(`StorageAdapter - Emitting data change for key "${e}" from origin "${r}"`),this.channel.emit({adapterId:this.adapterId,key:e,value:t,origin:r}))}onDataChanged(e){!this.channelName||typeof e!="function"||(i("StorageAdapter - Subscribing to cross-tab data changes."),this.channel.subscribe(e))}},$=ee,te=class extends ${constructor({dbName:e,storeName:t,version:r=1,encrypt:a=!1,expireCheckInterval:s=1e3,channelName:o=!1,enableSyncTabs:l=!1,description:c=""}){if(super(o),typeof indexedDB>"u")throw n("IndexedDB is not available in this environment"),new Error("IndexedDB is not available in this environment");this.isReady=!1,this.dbName=e,this.storeName=t||`${e}_store`,this.encrypt=a,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=f(e),this.enableSyncTabs=l||!1,this.expireCheckInterval=s,this.dbPromise=null,this._initDB({dbName:e,version:r,description:c}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),i(`IndexedDBAdapter - initialized with dbName: ${e}, storeName: ${this.storeName}`)}_initDB({dbName:e,version:t,description:r}){i(`IndexedDBAdapter -Initializing IndexedDB with dbName: ${e}, storeName: ${this.storeName}`),this.dbPromise=new Promise((a,s)=>{let o=indexedDB.open(e,t);o.onupgradeneeded=l=>{let c=l.target.result;c.objectStoreNames.contains(this.storeName)||c.createObjectStore(this.storeName);let h={dbName:e,version:t,description:r,createdAt:Date.now()};l.target.transaction.objectStore(this.storeName).put(JSON.stringify(h),this.metaKey)},o.onsuccess=l=>{let c=l.target.result,h=c.transaction(this.storeName,"readwrite").objectStore(this.storeName),m=h.get(this.metaKey);m.onsuccess=()=>{if(!m.result){let w={dbName:e,version:t,description:r,createdAt:Date.now()};h.put(JSON.stringify(w),this.metaKey)}this.isReady=!0,a(c)},m.onerror=w=>{n("Error checking meta:",w),a(c)}},o.onerror=l=>{n("Error opening database:",l.target.error),s(l.target.error)}})}async waitReadiness(e=50,t=20){return i(`IndexedDBAdapter - Waiting for database readiness with timeout: ${e}ms, tries: ${t}`),new Promise(async(r,a)=>{if(await J(e),this.isReady)return r(),!0;let s=0;for(;!this.isReady&&s++<t;)setTimeout(()=>{if(this.isReady)return r(),!0},e);a(new Error("Database is not ready"))})}async _withStore(e,t){try{i(`IndexedDBAdapter - Executing operation in ${e} mode`);let r=(await this.dbPromise).transaction(this.storeName,e).objectStore(this.storeName);return await t(r)}catch(r){throw n("Database operation failed:",r),r}}async _loadExpires(){return i("IndexedDBAdapter - Loading expiration timestamps"),this._withStore("readonly",async e=>new Promise(t=>{let r=e.get(this.expireKey);r.onsuccess=()=>{t(r.result?JSON.parse(r.result):{})},r.onerror=()=>{t({})}}))}async get(e){try{i(`IndexedDBAdapter - Getting key: ${e}`);let t=this._fullKey(e),r=await this._withStore("readonly",s=>new Promise(o=>{let l=s.get(t);l.onsuccess=()=>o(l.result),l.onerror=()=>o(null)}));if(!r)return null;let a=await this.getExpire(e);return a&&Date.now()>=a?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return n(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(i(`IndexedDBAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let a=this._fullKey(e);if(e&&t==null)return await this.delete(a),null;t=JSON.stringify(t);let s=await this._encrypt(e,t);return s?(await this._withStore("readwrite",o=>new Promise(l=>{let c=o.put(s,a);c.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),l(!0)},c.onerror=()=>l(!1)})),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(a){return n(`Error setting key '${e}':`,a),!1}}async delete(e){try{i(`IndexedDBAdapter - Deleting key: ${e}`);let t=this._fullKey(e);await this._withStore("readwrite",a=>new Promise(s=>{let o=a.delete(t);o.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),s(!0)},o.onerror=()=>s()}));let r=await this._loadExpires();delete r[e],await this._withStore("readwrite",a=>new Promise(s=>{let o=a.put(JSON.stringify(r),this.expireKey);o.onsuccess=()=>s(),o.onerror=()=>s()}))}catch(t){n(`Error deleting key '${e}':`,t)}}async list(){let e=[];try{i(`IndexedDBAdapter - Listing keys with prefix: ${this.prefix}`),await this._withStore("readonly",async t=>new Promise(r=>{let a=t.getAllKeys();a.onsuccess=async()=>{let s=a.result||[];for(let o of s)if(this.encrypt&&(o=A(o)),!(o===this.metaKey||o===this.expireKey)&&o.startsWith(this.prefix)){let l=await this.get(o.replace(this.prefix,""));l!==null&&e.push({key:o.replace(this.prefix,""),value:l})}r()},a.onerror=()=>r()}))}catch(t){n("Error listing keys:",t)}return e}async has(e){try{i(`IndexedDBAdapter - Checking existence of key: ${e}`);let t=this._fullKey(e);return await this._withStore("readonly",r=>new Promise(a=>{let s=r.getKey(t);s.onsuccess=()=>a(s.result!==void 0),s.onerror=()=>a(!1)}))}catch(t){return n(`Error checking key '${e}':`,t),!1}}async clear(){try{i("IndexedDBAdapter - Clearing all data"),await this.reset(),await this._withStore("readwrite",e=>new Promise(t=>{let r=e.delete(this.metaKey);r.onsuccess=()=>{let a=e.delete(this.expireKey);a.onsuccess=()=>t(),a.onerror=()=>t()},r.onerror=()=>t()}))}catch(e){n("Error clearing storage:",e)}}async reset(){try{i("IndexedDBAdapter - Resetting storage"),await this._withStore("readwrite",async e=>new Promise(t=>{let r=e.getAllKeys();r.onsuccess=()=>{let a=r.result||[];if(a.length===0){t();return}let s=0,o=l=>()=>{++s===a.length&&(this.enableSyncTabs&&this.emitDataChange(l.replace(this.prefix,""),"reset"),t())};for(let l of a){let c=e.delete(l);c.onsuccess=o(l),c.onerror=o(l)}},r.onerror=()=>t()}))}catch(e){n("Error resetting storage:",e)}}async setExpire(e,t){try{i(`IndexedDBAdapter - Setting expire for key: ${e}, timestamp: ${t}`);let r=await this._loadExpires();r[e]=t,await this._withStore("readwrite",a=>new Promise(s=>{let o=a.put(JSON.stringify(r),this.expireKey);o.onsuccess=()=>s(),o.onerror=()=>s()}))}catch(r){n(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{i(`IndexedDBAdapter - Deleting expire for key: ${e}`);let t=await this._loadExpires();delete t[e],await this._withStore("readwrite",r=>new Promise(a=>{let s=r.put(JSON.stringify(t),this.expireKey);s.onsuccess=()=>a(),s.onerror=()=>a()}))}catch(t){n(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{i("IndexedDBAdapter - Clearing expired keys");let e=Date.now(),t=await this._loadExpires(),r=!1;for(let a in t)t[a]<=e&&(await this.delete(a),r=!0);if(r){let a=await this._loadExpires();await this._withStore("readwrite",s=>new Promise(o=>{let l=s.put(JSON.stringify(a),this.expireKey);l.onsuccess=()=>o(),l.onerror=()=>o()}))}}catch(e){n("Error clearing expired keys:",e)}}},v=te,re=class extends ${constructor({dbName:e,version:t=1,encrypt:r=!1,expireCheckInterval:a=1e3,description:s="",channelName:o=!1,enableSyncTabs:l=!1}){if(super(o),typeof localStorage>"u")throw n("LocalStorage is not available in this environment"),new Error("LocalStorage is not available in this environment");this.dbName=e,this.encrypt=r,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=f(e),this.expireCheckInterval=a,this.enableSyncTabs=l||!1,this._initMeta({dbName:e,version:t,description:s}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),i(`LocalStorageAdapter -  initialized with dbName: ${e}, version: ${t}, encrypt: ${r}, description: ${s}`)}_initMeta({dbName:e,version:t,description:r}){try{i("LocalStorageAdapter - Initializing metadata for LocalStorageAdapter");let a={dbName:e,version:t,description:r,createdAt:Date.now()};localStorage.setItem(this.metaKey,JSON.stringify(a))}catch(a){n("Error initializing meta:",a)}}_loadExpires(){try{i("LocalStorageAdapter - Loading expiration metadata");let e=localStorage.getItem(this.expireKey);return e?JSON.parse(e):{}}catch(e){return n("Error loading expires:",e),{}}}async get(e){try{i(`LocalStorageAdapter - Getting key: ${e}`);let t=this._fullKey(e),r=localStorage.getItem(t);if(!r)return null;let a=await this.getExpire(e);return a&&Date.now()>=a?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return n(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(i(`LocalStorageAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let a=this._fullKey(e);if(e&&t==null)return await this.delete(a),null;t=JSON.stringify(t);let s=await this._encrypt(e,t);return s?(localStorage.setItem(a,s),this.enableSyncTabs&&this.emitDataChange(e,void 0,"set"),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(a){return n(`Error setting key '${e}':`,a),!1}}async delete(e){try{i(`LocalStorageAdapter - Deleting key: ${e}`);let t=this._fullKey(e);localStorage.removeItem(t);let r=this._loadExpires();delete r[e],localStorage.setItem(this.expireKey,JSON.stringify(r)),this.enableSyncTabs&&this.emitDataChange(e,void 0,"delete")}catch(t){n(`Error deleting key '${e}':`,t)}}async list(){let e=[];i(`LocalStorageAdapter - Listing keys with prefix: ${this.prefix}`);try{for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);if(this.encrypt&&(r=A(r)),!(r===this.metaKey||r===this.expireKey)&&r.startsWith(this.prefix)){let a=await this.get(r.replace(this.prefix,""));a!==null&&e.push({key:r.replace(this.prefix,""),value:a})}}}catch(t){throw n("Error listing keys:",t),t}return e}async has(e){try{i(`LocalStorageAdapter - Checking existence of key: ${e}`);let t=this._fullKey(e);return localStorage.getItem(t)!==null}catch(t){return n(`Error checking key '${e}':`,t),!1}}async clear(){try{i("LocalStorageAdapter - Clearing all data"),await this.reset(),localStorage.removeItem(this.metaKey),localStorage.removeItem(this.expireKey)}catch(e){n("Error clearing storage:",e)}}async reset(){try{i("LocalStorageAdapter - Resetting storage");let e=[];for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);r.startsWith(this.prefix)&&e.push(r)}for(let t of e)localStorage.removeItem(t),this.enableSyncTabs&&this.emitDataChange(t.replace(this.prefix,""),void 0,"reset")}catch(e){n("Error resetting storage:",e)}}async setExpire(e,t){try{i(`LocalStorageAdapter - Setting expiration for key: ${e}`,{timestamp:t});let r=this._loadExpires();r[e]=t,localStorage.setItem(this.expireKey,JSON.stringify(r))}catch(r){n(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{i(`LocalStorageAdapter - Deleting expiration for key: ${e}`);let t=this._loadExpires();delete t[e],localStorage.setItem(this.expireKey,JSON.stringify(t))}catch(t){n(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{i("LocalStorageAdapter - Clearing expired keys");let e=Date.now(),t=this._loadExpires(),r=!1;for(let a in t)t[a]<=e&&(await this.delete(a),r=!0);r&&localStorage.setItem(this.expireKey,JSON.stringify(this._loadExpires()))}catch(e){n("Error clearing expired keys:",e)}}},E=re,ae=class extends ${constructor({dbName:e,version:t=1,encrypt:r=!1,expireCheckInterval:a=1e3,channelName:s=!1,description:o="",enableSyncTabs:l=!1}){if(super(s),typeof sessionStorage>"u")throw n("SessionStorage is not available in this environment"),new Error("SessionStorage is not available in this environment");this.dbName=e,this.encrypt=r,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=f(e),this.expireCheckInterval=a,this.enableSyncTabs=l||!1,this._initMeta({dbName:e,version:t,description:o}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),i(`SessionStorageAdapter - initialized with prefix: ${this.prefix}, encrypt: ${this.encrypt}`)}_initMeta({dbName:e,version:t,description:r}){try{i(`SessionStorageAdapter - Initializing metadata for ${e} v${t}`);let a={dbName:e,version:t,description:r,createdAt:Date.now()};sessionStorage.setItem(this.metaKey,JSON.stringify(a))}catch(a){n("Error initializing meta:",a)}}_loadExpires(){try{i("SessionStorageAdapter - Loading expiration map");let e=sessionStorage.getItem(this.expireKey);return e?JSON.parse(e):{}}catch(e){return n("Error loading expires:",e),{}}}async get(e){try{i(`SessionStorageAdapter - Getting key '${e}'`);let t=this._fullKey(e),r=sessionStorage.getItem(t);if(!r)return null;let a=await this.getExpire(e);return a&&Date.now()>=a?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return n(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(i(`SessionStorageAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let a=this._fullKey(e);if(e&&t==null)return await this.delete(a),null;t=JSON.stringify(t);let s=await this._encrypt(e,t);return s?(sessionStorage.setItem(a,s),this.enableSyncTabs&&this.emitDataChange(e,s,"set"),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(a){return n(`Error setting key '${e}':`,a),!1}}async delete(e){try{i(`SessionStorageAdapter - Deleting key '${e}'`);let t=this._fullKey(e);sessionStorage.removeItem(t);let r=this._loadExpires();delete r[e],sessionStorage.setItem(this.expireKey,JSON.stringify(r)),this.enableSyncTabs&&this.emitDataChange(e,void 0,"delete")}catch(t){n(`Error deleting key '${e}':`,t)}}async list(){let e=[];try{i(`SessionStorageAdapter - Listing keys with prefix '${this.prefix}'`);for(let t=0;t<sessionStorage.length;t++){let r=sessionStorage.key(t);if(this.encrypt&&(r=A(r)),!(r===this.metaKey||r===this.expireKey)&&r.startsWith(this.prefix)){let a=await this.get(r.replace(this.prefix,""));a!==null&&e.push({key:r.replace(this.prefix,""),value:a})}}}catch(t){throw n("Error listing keys:",t),t}return e}async has(e){try{i(`SessionStorageAdapter - Checking existence of key '${e}'`);let t=this._fullKey(e);return sessionStorage.getItem(t)!==null}catch(t){return n(`Error checking key '${e}':`,t),!1}}async clear(){try{i("SessionStorageAdapter - Clearing all data"),await this.reset(),sessionStorage.removeItem(this.metaKey),sessionStorage.removeItem(this.expireKey)}catch(e){n("Error clearing storage:",e)}}async reset(){try{i("SessionStorageAdapter - Resetting storage");let e=[];for(let t=0;t<sessionStorage.length;t++){let r=sessionStorage.key(t);r.startsWith(this.prefix)&&e.push(r)}for(let t of e)sessionStorage.removeItem(t),this.enableSyncTabs&&this.emitDataChange(t.replace(this.prefix,""),void 0,"reset")}catch(e){n("Error resetting storage:",e)}}async setExpire(e,t){try{i(`SessionStorageAdapter - Setting expire for key '${e}'`);let r=this._loadExpires();r[e]=t,sessionStorage.setItem(this.expireKey,JSON.stringify(r))}catch(r){n(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{i(`SessionStorageAdapter - Deleting expire for key '${e}'`);let t=this._loadExpires();delete t[e],sessionStorage.setItem(this.expireKey,JSON.stringify(t))}catch(t){n(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{i("SessionStorageAdapter - Clearing expired keys");let e=Date.now(),t=this._loadExpires(),r=!1;for(let a in t)t[a]<=e&&(await this.delete(a),r=!0);r&&sessionStorage.setItem(this.expireKey,JSON.stringify(this._loadExpires()))}catch(e){n("Error clearing expired keys:",e)}}},k=ae,ie=class{async setInStorage(e,t,r={}){throw new Error("Not implemented")}async getFromStorage(e,t,r){throw new Error("Not implemented")}destroy(){if(this._unsubscribe){i("StoreAdapter - destroy - Unsubscribing from store changes."),this._unsubscribe(),this._unsubscribe=null;return}i("StoreAdapter - destroy - No unsubscribe function to call.")}},se=ie,ne=class extends se{constructor(e){if(super(),!e)throw n("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e}_checkStore(e){if(!e||!e.$subscribe||!e.$patch)throw n("Store provided is not defined"),new Error("Store provided is not defined")}_registerOnDataChanged(e){i("PiniaAdapter - Registering onDataChanged listener"),e&&this.adapter.onDataChanged(async t=>{if(t.adapterId==this.adapter.adapterId||!t.origin)return;let r;t.value?r=await this.adapter._decrypt(t.key,t.value):r=await this.adapter.get(t.key),JSON.stringify(e.$state)!==JSON.stringify(r)&&(e.$state={...e.$state,...r,STORAGEFY_SILENT_CHANNEL_UPDATE:!0})})}async setInStorage(e,t,r={}){try{return i("PiniaAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this._unsubscribe&&this._unsubscribe(),new Promise((a,s)=>{this._unsubscribe=e.$subscribe(async(o,l)=>{try{if(!l)return a(!0);if(l.STORAGEFY_SILENT_CHANNEL_UPDATE)return delete l.STORAGEFY_SILENT_CHANNEL_UPDATE,a(!0);let c={...l};for(let h in c)r.ignoreKeys.includes(h)&&(c[h]=void 0);return await this.adapter.set(t,c,r.timeout),a(!0)}catch(c){return s(c)}}),e.$patch({...e.$state}),r.syncTabs&&this._registerOnDataChanged(e)})}catch(a){throw n(a),a}}async getFromStorage(e,t){try{i("PiniaAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);return r?(e.$patch(F({},r)),!0):void 0}catch(r){throw n(r),r}}},K=ne,oe={dbName:"storagefy",storeName:"storagefy_db",version:1,encrypt:!1,expireCheckInterval:1e3,description:"Storagefy database",adapter:"indexedDB"},y,p;function le(e={}){let t={...oe,...e};if(!e.forceRecreate&&y)return y;switch(t.adapter){case"localStorage":if(e.fresh)return new E(t);y=new E(t);break;case"sessionStorage":if(e.fresh)return new k(t);y=new k(t);break;default:if(e.fresh)return new v(t);y=new v(t)}return y}function L({adapter:e,adapterParams:t,forceRecreate:r},a,s){if(e)return new s(e);if(a&&!r)return a;if(t){let o=ce(t);return new s(o)}if(!y)throw new Error("Storage adapter not initialized. Call startStoragefy first.");return new s(y)}function ce(e){switch(e.adapter){case"localStorage":return new E(e);case"sessionStorage":return new k(e);default:return new v(e)}}function de({adapter:e=null,adapterParams:t=null,forceRecreate:r=!1,fresh:a=!1}={}){return a?L({adapter:e,adapterParams:t,forceRecreate:r},null,K):(p=L({adapter:e,adapterParams:t,forceRecreate:r},p,K),{setInStorage:p.setInStorage.bind(p),getFromStorage:p.getFromStorage.bind(p)})}async function he(e,t,r={}){try{if(p||de(),!e)throw new Error("Store is required.");if(!t)throw new Error("Key is required.");await p.getFromStorage(e,t),await p.setInStorage(e,t,r)}catch(a){throw logError(a),a}}new le({dbName:"storagefy",storeName:"storagefy_db",version:1,encrypt:!1,description:"Storagefy database",adapter:"localStorage",channelName:"storagefy_channel",enableSyncTabs:!0});const pe=G("Storagefy_App",{state:()=>({mode:"dark",debugMode:!1,debugLevel:2}),actions:{setDebugMode(e){this.debugMode=e},setDebugLevel(e){this.debugLevel=e}}}),ye=H(),d=pe(ye);let O=!1;async function R(){try{return O||await he(d,d.$id,{syncTabs:!0}),O=!0,globalThis.storagefyDebug=d.debugMode,globalThis.storagefyDebugLevel=d.debugLevel,{appStore:d,loadStores:R}}catch(e){console.error(e)}}R();const ge={__name:"STRGF_ThemeButton",setup(e,{expose:t}){t();const r=C(!1);function a(){d.mode==="dark"?(d.mode="light",document.body.classList.remove("dark")):(d.mode="dark",document.body.classList.add("dark"))}D(async()=>{r.value=!0}),I(()=>{!r.value||!d||(d.mode==="dark"?document.body.classList.add("dark"):document.body.classList.remove("dark"))});const s={isMounted:r,toggleTheme:a,onMounted:D,ref:C,watchEffect:I,get appStore(){return d}};return Object.defineProperty(s,"__isScriptSetup",{enumerable:!1,value:!0}),s}},ue={key:0,class:"icon-wrapper sun-glow"},fe={key:1,class:"icon-wrapper moon-glow"};function me(e,t,r,a,s,o){return a.isMounted?(x(),S("button",{key:0,onClick:a.toggleTheme,class:"theme-toggle-button"},[a.appStore.mode!=="dark"?(x(),S("div",ue,t[0]||(t[0]=[U('<div class="glow-circle" data-v-5b65bf19></div><svg class="rise-animation" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#FACC15" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-5b65bf19><circle cx="12" cy="12" r="5" data-v-5b65bf19></circle><line x1="12" y1="1" x2="12" y2="3" data-v-5b65bf19></line><line x1="12" y1="21" x2="12" y2="23" data-v-5b65bf19></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64" data-v-5b65bf19></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78" data-v-5b65bf19></line><line x1="1" y1="12" x2="3" y2="12" data-v-5b65bf19></line><line x1="21" y1="12" x2="23" y2="12" data-v-5b65bf19></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36" data-v-5b65bf19></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22" data-v-5b65bf19></line></svg>',2)]))):(x(),S("div",fe,t[1]||(t[1]=[b("div",{class:"glow-circle"},null,-1),b("svg",{class:"rise-animation",xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",viewBox:"0 0 24 24",fill:"none",stroke:"#3999F9","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[b("path",{d:"M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"})],-1)])))])):M("",!0)}const Ee=z(ge,[["render",me],["__scopeId","data-v-5b65bf19"]]);export{Ee as default};
