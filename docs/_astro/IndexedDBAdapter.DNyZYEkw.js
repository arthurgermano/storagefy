import{S as x,l as d,g,a as o,s as m}from"./StorageAdapter.DFwS-N09.js";import{g as S}from"./_commonjsHelpers.Cpj98o6Y.js";var p,y;function _(){if(y)return p;y=1;function f(e,t=!0,r=!1){return new Promise((s,i)=>{setTimeout(()=>{r&&i(t===!0?new Error("Sleep Error"):t),s(t)},e)})}return p=f,p}var D=_();const E=S(D);class I extends x{constructor({dbName:e,storeName:t,version:r=1,encrypt:s=!1,expireCheckInterval:i=1e3,channelName:n=!1,enableSyncTabs:a=!1,description:c=""}){if(super(n),typeof indexedDB>"u")throw d("IndexedDB is not available in this environment"),new Error("IndexedDB is not available in this environment");this.isReady=!1,this.dbName=e,this.storeName=t||`${e}_store`,this.encrypt=s,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=g(e),this.enableSyncTabs=a||!1,this.expireCheckInterval=i,this.dbPromise=null,this._initDB({dbName:e,version:r,description:c}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),o(`IndexedDBAdapter - initialized with dbName: ${e}, storeName: ${this.storeName}`)}_initDB({dbName:e,version:t,description:r}){o(`IndexedDBAdapter -Initializing IndexedDB with dbName: ${e}, storeName: ${this.storeName}`),this.dbPromise=new Promise((s,i)=>{const n=indexedDB.open(e,t);n.onupgradeneeded=a=>{const c=a.target.result;c.objectStoreNames.contains(this.storeName)||c.createObjectStore(this.storeName);const w={dbName:e,version:t,description:r,createdAt:Date.now()};a.target.transaction.objectStore(this.storeName).put(JSON.stringify(w),this.metaKey)},n.onsuccess=a=>{const c=a.target.result,u=c.transaction(this.storeName,"readwrite").objectStore(this.storeName),h=u.get(this.metaKey);h.onsuccess=()=>{if(!h.result){const l={dbName:e,version:t,description:r,createdAt:Date.now()};u.put(JSON.stringify(l),this.metaKey)}this.isReady=!0,s(c)},h.onerror=l=>{d("Error checking meta:",l),s(c)}},n.onerror=a=>{d("Error opening database:",a.target.error),i(a.target.error)}})}async waitReadiness(e=50,t=20){return o(`IndexedDBAdapter - Waiting for database readiness with timeout: ${e}ms, tries: ${t}`),new Promise(async(r,s)=>{try{if(await E(e),this.isReady)return r(),!0;let i=0;for(;!this.isReady&&i++<t;)setTimeout(()=>{if(this.isReady)return r(),!0},e)}catch(i){return s(i)}s(new Error("Database is not ready"))})}async _withStore(e,t){try{o(`IndexedDBAdapter - Executing operation in ${e} mode`);const i=(await this.dbPromise).transaction(this.storeName,e).objectStore(this.storeName);return await t(i)}catch(r){throw d("Database operation failed:",r),r}}async _loadExpires(){return o("IndexedDBAdapter - Loading expiration timestamps"),this._withStore("readonly",async e=>new Promise(t=>{const r=e.get(this.expireKey);r.onsuccess=()=>{t(r.result?JSON.parse(r.result):{})},r.onerror=()=>{t({})}}))}async get(e){try{o(`IndexedDBAdapter - Getting key: ${e}`);const t=this._fullKey(e),r=await this._withStore("readonly",i=>new Promise(n=>{const a=i.get(t);a.onsuccess=()=>n(a.result),a.onerror=()=>n(null)}));if(!r)return null;const s=await this.getExpire(e);return s&&Date.now()>=s?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return d(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(o(`IndexedDBAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;const s=this._fullKey(e);if(e&&t==null)return await this.delete(s),null;t=JSON.stringify(t);const i=await this._encrypt(e,t);return i?(await this._withStore("readwrite",n=>new Promise(a=>{const c=n.put(i,s);c.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),a(!0)},c.onerror=()=>a(!1)})),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(s){return d(`Error setting key '${e}':`,s),!1}}async delete(e){try{o(`IndexedDBAdapter - Deleting key: ${e}`);const t=this._fullKey(e);await this._withStore("readwrite",s=>new Promise(i=>{const n=s.delete(t);n.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),i(!0)},n.onerror=()=>i()}));const r=await this._loadExpires();delete r[e],await this._withStore("readwrite",s=>new Promise(i=>{const n=s.put(JSON.stringify(r),this.expireKey);n.onsuccess=()=>i(),n.onerror=()=>i()}))}catch(t){d(`Error deleting key '${e}':`,t)}}async list(){const e=[];try{o(`IndexedDBAdapter - Listing keys with prefix: ${this.prefix}`),await this._withStore("readonly",async t=>new Promise(r=>{const s=t.getAllKeys();s.onsuccess=async()=>{const i=s.result||[];for(let n of i)if(this.encrypt&&(n=m(n)),!(n===this.metaKey||n===this.expireKey)&&n.startsWith(this.prefix)){const a=await this.get(n.replace(this.prefix,""));a!==null&&e.push({key:n.replace(this.prefix,""),value:a})}r()},s.onerror=()=>r()}))}catch(t){d("Error listing keys:",t)}return e}async has(e){try{o(`IndexedDBAdapter - Checking existence of key: ${e}`);const t=this._fullKey(e);return await this._withStore("readonly",r=>new Promise(s=>{const i=r.getKey(t);i.onsuccess=()=>s(i.result!==void 0),i.onerror=()=>s(!1)}))}catch(t){return d(`Error checking key '${e}':`,t),!1}}async clear(){try{o("IndexedDBAdapter - Clearing all data"),await this.reset(),await this._withStore("readwrite",e=>new Promise(t=>{const r=e.delete(this.metaKey);r.onsuccess=()=>{const s=e.delete(this.expireKey);s.onsuccess=()=>t(),s.onerror=()=>t()},r.onerror=()=>t()}))}catch(e){d("Error clearing storage:",e)}}async reset(){try{o("IndexedDBAdapter - Resetting storage"),await this._withStore("readwrite",async e=>new Promise(t=>{const r=e.getAllKeys();r.onsuccess=()=>{const s=r.result||[];if(s.length===0){t();return}let i=0;const n=a=>()=>{++i===s.length&&(this.enableSyncTabs&&this.emitDataChange(a.replace(this.prefix,""),"reset"),t())};for(const a of s){const c=e.delete(a);c.onsuccess=n(a),c.onerror=n(a)}},r.onerror=()=>t()}))}catch(e){d("Error resetting storage:",e)}}async setExpire(e,t){try{o(`IndexedDBAdapter - Setting expire for key: ${e}, timestamp: ${t}`);const r=await this._loadExpires();r[e]=t,await this._withStore("readwrite",s=>new Promise(i=>{const n=s.put(JSON.stringify(r),this.expireKey);n.onsuccess=()=>i(),n.onerror=()=>i()}))}catch(r){d(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{o(`IndexedDBAdapter - Deleting expire for key: ${e}`);const t=await this._loadExpires();delete t[e],await this._withStore("readwrite",r=>new Promise(s=>{const i=r.put(JSON.stringify(t),this.expireKey);i.onsuccess=()=>s(),i.onerror=()=>s()}))}catch(t){d(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{o("IndexedDBAdapter - Clearing expired keys");const e=Date.now(),t=await this._loadExpires();let r=!1;for(const s in t)t[s]<=e&&(await this.delete(s),r=!0);if(r){const s=await this._loadExpires();await this._withStore("readwrite",i=>new Promise(n=>{const a=i.put(JSON.stringify(s),this.expireKey);a.onsuccess=()=>n(),a.onerror=()=>n()}))}}catch(e){d("Error clearing expired keys:",e)}}}export{I as default};
