import{g as b}from"./_commonjsHelpers.Cpj98o6Y.js";globalThis.storagefyDebug=!1;globalThis.storagefyDebugLevel=0;const a=(...n)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=0&&(n.unshift("Storagefy Error:"),console.error(...n))},D=(...n)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=1&&(n.unshift("Storagefy Warn:"),console.warn(...n))},o=(...n)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=2&&(n.unshift("Storagefy:"),console.info(...n))};var u,C;function x(){if(C)return u;C=1;function n(e){return typeof e=="number"&&!isNaN(e)&&Number.isFinite(e)}return u=n,u}var y,S;function N(){if(S)return y;S=1;function n(e="",r=!0){let t="";if(typeof e!="string"){if(e)e.toString&&(t=e.toString());else return t;if(r&&t=="[object Object]")try{t=JSON.stringify(e)}catch{return e.toString()}return t}return e}return y=n,y}var f,E;function F(){if(E)return f;E=1;const n=x(),e=N();function r(t="",s){let i;return typeof window>"u"?(n(t)&&(t=e(t)),i=Buffer.from(t,s).toString("base64")):i=btoa(t),i.replaceAll("=","")}return f=r,f}var $=F();const m=b($);var h,v;function k(){if(v)return h;v=1;function n(e=""){return typeof e!="string"||!e?"":typeof window>"u"?Buffer.from(e,"base64").toString("utf-8"):atob(e)}return h=n,h}var B=k();const _=b(B),w=new TextEncoder,H=new TextDecoder;let l,c;function K(){try{if(o("CryptoHelper - Attempting to initialize crypto engine"),typeof window<"u"&&window.crypto){l=window.crypto,c=l.subtle,o("CryptoHelper - Crypto initialized from window.crypto");return}if(typeof global<"u"&&global.crypto?.webcrypto){l=global.crypto.webcrypto,c=l.subtle,o("CryptoHelper - Crypto initialized from global.webcrypto");return}throw new Error("Crypto API not available")}catch(n){throw a("Failed to initialize crypto:",n),n}}try{K()}catch(n){a("Failed to initialize crypto:",n)}const R=async n=>{try{return o("CryptoHelper - Generating key material from password"),c.importKey("raw",w.encode(n),"PBKDF2",!1,["deriveKey"])}catch(e){throw a("Error generating key material:",e),e}},T=async(n,e,r=!1)=>{try{if(typeof n!="string"||!n.length)throw new Error("Invalid password");o("CryptoHelper - Deriving key with PBKDF2",{passwordLength:n.length,extractable:r});const t=await R(n);return c.deriveKey({name:"PBKDF2",salt:w.encode(e),iterations:1e5,hash:"SHA-256"},t,{name:"AES-GCM",length:256},r,["encrypt","decrypt"])}catch(t){throw a("Error deriving key:",t),t}},q=async(n,e,r=!1)=>{if(e===void 0||typeof e=="function"||typeof e=="symbol")throw new Error("Invalid data type for encryption");try{o("CryptoHelper - Encrypting data",{raw:r});const t=l.getRandomValues(new Uint8Array(12)),s=w.encode(JSON.stringify(e)),i=await c.encrypt({name:"AES-GCM",iv:t},n,s);if(r)return{iv:t,data:new Uint8Array(i)};const p=m(String.fromCharCode(...t)),d=m(String.fromCharCode(...new Uint8Array(i)));return{iv:p,data:d}}catch(t){throw a("Error encrypting data:",t),t}},z=async(n,e,r=!1)=>{let t,s;try{if(o("CryptoHelper - Decrypting data",{raw:r}),r)t=new Uint8Array(e.iv),s=new Uint8Array(e.data);else{const p=d=>new Uint8Array(_(d).split("").map(I=>I.charCodeAt(0)));t=p(e.iv),s=p(e.data)}const i=await c.decrypt({name:"AES-GCM",iv:t},n,s);return JSON.parse(H.decode(i))}catch(i){throw a("Error decrypting data:",i),i}};function G(n){if(!n)return n;o("CryptoHelper - Obfuscating string");try{const e=[...n].map(r=>String.fromCharCode(r.charCodeAt(0)+1)).join("");return m(e)}catch{return n}}function W(n){if(!n)return n;o("CryptoHelper - Deobfuscating string");try{return[..._(n)].map(r=>String.fromCharCode(r.charCodeAt(0)-1)).join("")}catch{return n}}var g,A;function M(){if(A)return g;A=1;const n=N();function e(r,t="_"){return r=n(r)+t,r==t&&(r=""),r+=Date.now(),r+=t+Math.floor(Math.random()*9999999999999+1),r}return g=e,g}var J=M();const U=b(J);class L{constructor(e){try{typeof e!="string"&&(e=U("storagefy_channel")),this.channel=new BroadcastChannel(e),this.channelName=e,o(`CrossTabChannel initialized on channel "${e}"`)}catch(r){throw a("Failed to initialize BroadcastChannel:",r),r}}subscribe(e){if(typeof e!="function"){D("CrossTabChannel.subscribe: Provided callback is not a function.");return}this.channel.onmessage=r=>{o("CrossTabChannel - Received message:",r.data);try{e(r.data)}catch(t){a("Error in CrossTabChannel subscriber callback:",t)}},o("CrossTabChannel - Subscribed to incoming messages.")}emit(e){try{this.channel.postMessage(e),o("CrossTabChannel - Emitted message:",e)}catch(r){a("CrossTabChannel.emit: Failed to send message:",r)}}close(){try{this.channel.close(),o("CrossTabChannel - Channel closed.")}catch(e){a("CrossTabChannel.close: Error closing channel:",e)}}}class O{constructor(e){e?(o("StorageAdapter - Initializing cross-tab channel:",e),this.channelName=e,this.channel=new L(e)):(this.channel=null,this.channelName=null,D("StorageAdapter - No channel name provided, cross-tab syncing disabled."))}async get(e){throw new Error("Not implemented")}async set(e,r,t){throw new Error("Not implemented")}async delete(e){throw new Error("Not implemented")}async list(e=""){throw new Error("Not implemented")}async reset(){throw new Error("Not implemented")}async clear(){throw new Error("Not implemented")}async clearExpire(){throw new Error("Not implemented")}async setExpire(e,r){throw new Error("Not implemented")}async deleteExpire(e){throw new Error("Not implemented")}async has(e){throw new Error("Not implemented")}async _encrypt(e,r){if(!this.encrypt||!e)return r;try{const t=await T(e),s=await q(t,r,!1);return o(`StorageAdapter - Successfully encrypted value for key "${e}".`),JSON.stringify(s)}catch(t){return a("Encryption failed:",t),null}}async _decrypt(e,r){if(!this.encrypt||!e)return JSON.parse(r);try{const t=await T(e),s=JSON.parse(r),i=await z(t,s,!1);return o(`StorageAdapter - Successfully decrypted value for key "${e}".`),JSON.parse(i)}catch(t){return a("Decryption failed:",t),null}}_fullKey(e){const r=`${this.prefix}${e}`;if(this.encrypt){const t=G(r);return o(`StorageAdapter - Obfuscated key "${e}" to "${t}".`),t}return o(`StorageAdapter - Using plain key: "${r}"`),r}_startExpireWatcher(){this._expireTimer&&clearInterval(this._expireTimer),!(this.expireCheckInterval<=0)&&(this._expireTimer=setInterval(()=>{try{o("StorageAdapter - Running expiration cleanup..."),this.clearExpire()}catch(e){a("Error clearing expired keys:",e)}},this.expireCheckInterval),o(`StorageAdapter - Expire watcher started, interval: ${this.expireCheckInterval}ms`))}destroy(){this._expireTimer&&(clearInterval(this._expireTimer),this._expireTimer=null,o("StorageAdapter - Expire watcher stopped.")),this._unloadHandler&&(window.removeEventListener("beforeunload",this._unloadHandler),this._unloadHandler=null,o("StorageAdapter - Removed unload handler."))}async getAll(e){return o(`StorageAdapter - Getting all keys under table: "${e}"`),this.list(`${e}__`)}async getExpire(e){try{const r=await this._loadExpires();return o(`StorageAdapter - Getting expiration for key "${e}":`,r[e]||null),r[e]||null}catch(r){return a(`Error getting expire for key '${e}':`,r),null}}emitDataChange(e,r,t){!this.channelName||!t||(o(`StorageAdapter - Emitting data change for key "${e}" from origin "${t}"`),this.channel.emit({adapterId:this.adapterId,key:e,value:r,origin:t}))}onDataChanged(e){!this.channelName||typeof e!="function"||(o("StorageAdapter - Subscribing to cross-tab data changes."),this.channel.subscribe(e))}}export{O as S,o as a,U as g,a as l,W as s};
