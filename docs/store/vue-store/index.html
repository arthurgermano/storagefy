<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.6.1"><title>Storagefy | Frontend Storage Adapter</title><!-- Fonts --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet"><!-- Meta tags --><meta name="description" content="Frontend storage adapter with framework integrations for IndexedDB, LocalStorage, and SessionStorage as well stores like Pinia, Svelte and React"><meta property="og:title" content="Storagefy"><meta property="og:description" content="Cross-framework storage solution for modern web applications"><meta property="og:type" content="website"><meta property="og:url" content="https://arthurgermano.github.com/storagefy"><script>
      (() => {
        try {
          const raw = localStorage.getItem("storagefy__Storagefy_App");
          const parsed = JSON.parse(raw || "{}");
          const mode = parsed?.mode;

          // Delay to ensure body is available
          requestAnimationFrame(() => {
            if (!document.body) return;

            if (mode === "dark") {
              document.body.classList.add("dark");
            } else {
              document.body.classList.remove("dark");
            }
          });
        } catch (err) {
          console.error("Failed to load theme mode from storage:", err);
        }
      })();
    </script><link rel="stylesheet" href="/storagefy/_astro/exports-usage.BQxDOPS-.css"></head> <body class=""> <header class="strf-header"> <span></span> <a href="/" class="strf-logo" style="margin-left: -1rem"> <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M12 2C17 2 21 3.79 21 6V18C21 20.21 17 22 12 22C7 22 3 20.21 3 18V6C3 3.79 7 2 12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M21 6C21 8.21 17 10 12 10C7 10 3 8.21 3 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M21 12C21 14.21 17 16 12 16C7 16 3 14.21 3 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </svg> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z22jFD6" prefix="v0" component-url="/storagefy/_astro/STRGF_Title.KDvzcBB3.js" component-export="default" renderer-url="/storagefy/_astro/client.DxL-F4FW.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;STRGF_Title&quot;,&quot;value&quot;:true}" await-children><div id="strf-title" data-v-5dc29489><!--[--><span data-v-5dc29489>S</span><span data-v-5dc29489>T</span><span data-v-5dc29489>O</span><span data-v-5dc29489>R</span><span data-v-5dc29489>A</span><span data-v-5dc29489>G</span><span data-v-5dc29489>E</span><span data-v-5dc29489>F</span><span data-v-5dc29489>Y</span><!--]--></div><!--astro:end--></astro-island> </a> <div style="min-width: 3rem"> <script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><astro-island uid="1VrJTH" component-url="/storagefy/_astro/STRGF_ThemeButton.D7tAUEY4.js" component-export="default" renderer-url="/storagefy/_astro/client.DxL-F4FW.js" props="{}" ssr client="only" opts="{&quot;name&quot;:&quot;STRGF_ThemeButton&quot;,&quot;value&quot;:true}"></astro-island> </div> </header> <main class="strf-layout"> <aside class="strf-sidebar" id="sidebar"> <nav> <ul class="strf-nav-group"> <li><a href="/storagefy/">Getting Started</a></li> <li><a href="/storagefy/exports-usage">Exports Usage</a></li> <li class="strf-nav-section">Storage</li> <ul> <li> <a href="/storagefy/storage/local-storage">Local Storage Adapter</a> </li> <li> <a href="/storagefy/storage/session-storage">Session Storage Adapter</a> </li> <li><a href="/storagefy/storage/indexeddb">Indexed DB Adapter</a></li> </ul> <li class="strf-nav-section">Store</li> <ul> <li><a href="/storagefy/store/react-store">React Store Adapter</a></li> <li><a href="/storagefy/store/svelte-store">Svelte Store Adapter</a></li> <li><a href="/storagefy/store/vue-store">Vue Store Adapter</a></li> </ul> <li> <a href="https://github.com/arthurgermano/storagefy" target="_blank">
GitHub
</a> </li> <li> <a href="https://npmjs.com/package/storagefy" target="_blank">
NPM
</a> </li> </ul> </nav> </aside> <section class="strf-main-content"> <button id="menuToggle" class="strf-mobile-toggle">â˜°</button>  <div class="strf-main-content"> <section class="strf-section"> <h1>Vue Store Adapter</h1> <p>
Storagefy's Vue adapter provides seamless integration with Vue's
        reactive state management systems, particularly focusing on Pinia
        stores. This adapter synchronizes your Vue store state with your chosen
        storage backend (localStorage, sessionStorage, or IndexedDB) with
        minimal configuration.
</p> </section> <section class="strf-section"> <h2>1. Basic Usage</h2> <p>
The Vue adapter works primarily with Pinia, Vue's recommended state
        management solution, allowing you to persist your store state across
        page reloads and browser sessions.
</p> <pre class="strf-code-block">        <code>
import &#123; startStoragefy, getPiniaAdapter &#125; from "storagefy";

// Initialize the storage backend
startStoragefy(&#123;
  dbName: "my-vue-app",
  adapter: "indexedDB", // or "localStorage" or "sessionStorage"
  encrypt: true,
  channelName: "vue-sync" // for cross-tab synchronization
&#125;);

// Get the Pinia adapter
const &#123; setInStorage, getFromStorage &#125; = getPiniaAdapter();

// Connect with your store
const userStore = useUserStore();
await getFromStorage(userStore, "user"); // Always call this before setInStorage
await setInStorage(userStore, "user", &#123;
  timeout: 3600000, // 1 hour expiration
  ignoreKeys: ["tempData", "password"],
  syncTabs: true
&#125;);
        </code>
      </pre> </section> <section class="strf-section"> <h2>2. Using the Helper Function</h2> <p>
For a more concise approach, use the <code>setPiniaStorage</code> helper
        function:
</p> <pre class="strf-code-block">        <code>
import &#123; startStoragefy, setPiniaStorage &#125; from "storagefy";

// Initialize storage backend
startStoragefy(&#123;
  dbName: "my-vue-app",
  adapter: "localStorage"
&#125;);

// Use the helper function
const userStore = useUserStore();
await setPiniaStorage(userStore, "user", &#123;
  timeout: 86400000, // 24 hours
  ignoreKeys: ["sessionToken"],
  syncTabs: true
&#125;);
        </code>
      </pre> </section> <section class="strf-section"> <h2>3. Test It</h2> <astro-island uid="1pyO7G" component-url="/storagefy/_astro/STRGF_ShoppingDemo.C3Bu6FDV.js" component-export="default" renderer-url="/storagefy/_astro/client.DxL-F4FW.js" props="{}" ssr client="only" opts="{&quot;name&quot;:&quot;STRGF_ShopDemo&quot;,&quot;value&quot;:true}"></astro-island> </section> <section class="strf-section"> <h2>4. Advanced Configuration</h2> <p>
You can directly instantiate the <code>PiniaAdapter</code> class for more
        advanced control:
</p> <pre class="strf-code-block">        <code>
import &#123; PiniaAdapter, IndexedDBAdapter &#125; from "storagefy";

// Create storage adapter instance
const storageAdapter = new IndexedDBAdapter(&#123; 
  dbName: "my-app",
  encrypt: true
&#125;);

// Create Pinia adapter with the storage adapter
const piniaAdapter = new PiniaAdapter(storageAdapter);

// Connect with your store
const settingsStore = useSettingsStore();
await piniaAdapter.getFromStorage(settingsStore, "app-settings");
await piniaAdapter.setInStorage(settingsStore, "app-settings", &#123;
  ignoreKeys: ["tempSettings"],
  timeout: 604800000 // 1 week
&#125;);
        </code>
      </pre> </section> <section class="strf-section"> <h2>5. Configuration Options</h2> <p>
The <code>setInStorage</code> method accepts the following options:
</p> <div class="strf-options"> <h3>Options Object</h3> <ul> <li> <code>ignoreKeys</code>: Array of store property keys to exclude
            from persistence
<p class="strf-option-desc">
Use this for sensitive data or temporary state that doesn't need
              persistence.
</p> </li> <li> <code>timeout</code>: Expiration duration in milliseconds
<p class="strf-option-desc">
After this duration, the stored data will be considered expired
              and removed.
</p> </li> <li> <code>syncTabs</code>: Boolean flag to enable cross-tab
            synchronization
<p class="strf-option-desc">
When true, changes made in one browser tab will be reflected in
              all others. Requires <code>channelName</code> to be set during <code>startStoragefy</code>.
</p> </li> </ul> </div> </section> <section class="strf-section"> <h2>6. Handling Store Changes</h2> <p>
The Vue adapter automatically subscribes to store changes using Pinia's <code>$subscribe</code> method and persists updates to your chosen storage. When data changes in
        other tabs (with <code>syncTabs: true</code>), the adapter will update
        the local store without triggering additional storage operations.
</p> <pre class="strf-code-block">        <code>
// Store changes are automatically persisted
userStore.$patch(&#123; 
  name: "New Username",
  preferences: &#123; theme: "dark" &#125;
&#125;);

// The above change is automatically synchronized to storage
// and to other tabs if syncTabs is enabled
        </code>
      </pre> </section> <section class="strf-section"> <h2>7. API Reference</h2> <div class="strf-api-method"> <h3><code>getPiniaAdapter([options])</code></h3> <p>Returns a configured Pinia adapter instance. Options include:</p> <ul> <li> <code>adapterParams</code>: Configuration for the underlying storage
            adapter
</li> </ul> <p>
Returns: <code>&#123; setInStorage, getFromStorage &#125;</code> methods
</p> </div> <div class="strf-api-method"> <h3><code>setPiniaStorage(store, key, [options])</code></h3> <p>
Helper function that internally calls <code>getFromStorage</code> followed
          by <code>setInStorage</code>.
</p> <ul> <li><code>store</code>: Pinia store instance</li> <li><code>key</code>: Storage key string</li> <li> <code>options</code>: Configuration options (ignoreKeys, timeout,
            syncTabs)
</li> </ul> <p>Returns: Promise resolving to true on success</p> </div> <div class="strf-api-method"> <h3><code>PiniaAdapter</code> Class Methods</h3> <ul> <li> <code>setInStorage(store, key, options)</code>: Persists store state
            and sets up subscription
</li> <li> <code>getFromStorage(store, key)</code>: Loads persisted state into
            store
</li> <li> <code>destroy()</code>: Cleans up subscriptions when adapter is no
            longer needed
</li> </ul> </div> </section> <section class="strf-section"> <h2>8. Best Practices</h2> <ul> <li>
Always call <code>getFromStorage</code> before <code>setInStorage</code> to hydrate your store with existing data
</li> <li>
Use <code>ignoreKeys</code> for sensitive data like authentication tokens
          or large temporary objects
</li> <li>
Set appropriate <code>timeout</code> values for different types of data
          (e.g., longer for preferences, shorter for session data)
</li> <li>
Enable <code>syncTabs</code> for shared state across multiple browser tabs
</li> <li>
Consider using encryption (<code>encrypt: true</code>) when storing
          sensitive user data
</li> </ul> </section> </div>  </section> </main> <footer class="strf-footer"> <div>
Developed by
<br> <a href="https://www.linkedin.com/in/arthurjgermano" target="_blank">
Arthur JosÃ© Germano
</a> </div> <div>MIT License â€“ Â© 2025</div> </footer> </body></html>