<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/storagefy/favicon.svg"><meta name="generator" content="Astro v5.7.4"><title>Storagefy | Frontend Storage Adapter</title><!-- Fonts --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet"><!-- Meta tags --><meta name="description" content="Frontend storage adapter with framework integrations for IndexedDB, LocalStorage, and SessionStorage as well stores like Pinia, Svelte and React"><meta property="og:title" content="Storagefy"><meta property="og:description" content="Cross-framework storage solution for modern web applications"><meta property="og:type" content="website"><meta property="og:url" content="https://arthurgermano.github.com/storagefy"><script>
      (() => {
        try {
          const raw = localStorage.getItem("storagefy__Storagefy_App");
          const parsed = JSON.parse(raw || "{}");
          const mode = parsed?.mode;

          // Delay to ensure body is available
          requestAnimationFrame(() => {
            if (!document.body) return;

            if (mode === "dark") {
              document.body.classList.add("dark");
            } else {
              document.body.classList.remove("dark");
            }
          });
        } catch (err) {
          console.error("Failed to load theme mode from storage:", err);
        }
      })();
    </script><link rel="stylesheet" href="/storagefy/_astro/exports-usage.BQxDOPS-.css"></head> <body class=""> <header class="strf-header"> <span></span> <a href="/storagefy/" class="strf-logo" style="margin-left: -1rem"> <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M12 2C17 2 21 3.79 21 6V18C21 20.21 17 22 12 22C7 22 3 20.21 3 18V6C3 3.79 7 2 12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M21 6C21 8.21 17 10 12 10C7 10 3 8.21 3 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M21 12C21 14.21 17 16 12 16C7 16 3 14.21 3 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </svg> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z22jFD6" prefix="v0" component-url="/storagefy/_astro/STRGF_Title.KDvzcBB3.js" component-export="default" renderer-url="/storagefy/_astro/client.DxL-F4FW.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;STRGF_Title&quot;,&quot;value&quot;:true}" await-children><div id="strf-title" data-v-5dc29489><!--[--><span data-v-5dc29489>S</span><span data-v-5dc29489>T</span><span data-v-5dc29489>O</span><span data-v-5dc29489>R</span><span data-v-5dc29489>A</span><span data-v-5dc29489>G</span><span data-v-5dc29489>E</span><span data-v-5dc29489>F</span><span data-v-5dc29489>Y</span><!--]--></div><!--astro:end--></astro-island> </a> <div style="min-width: 3rem"> <script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><astro-island uid="1VrJTH" component-url="/storagefy/_astro/STRGF_ThemeButton.D2e8TspR.js" component-export="default" renderer-url="/storagefy/_astro/client.DxL-F4FW.js" props="{}" ssr client="only" opts="{&quot;name&quot;:&quot;STRGF_ThemeButton&quot;,&quot;value&quot;:true}"></astro-island> </div> </header> <main class="strf-layout"> <aside class="strf-sidebar" id="sidebar"> <nav> <ul class="strf-nav-group"> <li><a href="/storagefy/">Getting Started</a></li> <li><a href="/storagefy/exports-usage">Exports Usage</a></li> <li class="strf-nav-section">Storage</li> <ul> <li> <a href="/storagefy/storage/local-storage">Local Storage Adapter</a> </li> <li> <a href="/storagefy/storage/session-storage">Session Storage Adapter</a> </li> <li><a href="/storagefy/storage/indexeddb">Indexed DB Adapter</a></li> </ul> <li class="strf-nav-section">Store</li> <ul> <li><a href="/storagefy/store/react-store">React Store Adapter</a></li> <li><a href="/storagefy/store/svelte-store">Svelte Store Adapter</a></li> <li><a href="/storagefy/store/vue-store">Vue Store Adapter</a></li> </ul> <li> <a href="https://github.com/arthurgermano/storagefy" target="_blank">
GitHub
</a> </li> <li> <a href="https://npmjs.com/package/storagefy" target="_blank">
NPM
</a> </li> </ul> </nav> </aside> <section class="strf-main-content"> <button id="menuToggle" class="strf-mobile-toggle">☰</button>  <div class="strf-main-content"> <section class="strf-section"> <h1>Svelte Store Adapter</h1> <p>
Storagefy's Svelte adapter provides seamless integration between Svelte's reactive stores and 
        your choice of persistent storage backend. This adapter works with Svelte's standard store contract, 
        allowing you to easily persist and synchronize writable stores across page reloads and browser sessions.
</p> </section> <section class="strf-section"> <h2>1. Basic Usage</h2> <p>
The Svelte adapter works with Svelte's built-in stores, enabling straightforward state persistence 
        with minimal configuration:
</p> <pre class="strf-code-block">        <code>
import &#123; writable &#125; from 'svelte/store';
import &#123; startStoragefy, getSvelteAdapter &#125; from "storagefy";

// Initialize the storage backend
startStoragefy(&#123;
  dbName: "my-svelte-app",
  adapter: "indexedDB", // or "localStorage" or "sessionStorage"
  encrypt: true,
  channelName: "svelte-sync" // for cross-tab synchronization
&#125;);

// Create a Svelte store
const themeStore = writable(&#123; mode: 'light', accent: 'blue' &#125;);

// Get the Svelte adapter
const &#123; setInStorage, getFromStorage &#125; = getSvelteAdapter();

// Load existing data first
await getFromStorage(themeStore, "theme-settings");

// Then set up persistence
await setInStorage(themeStore, "theme-settings", &#123;
  timeout: 2592000000, // 30 days expiration
  ignoreKeys: ["tempTheme"],
  syncTabs: true
&#125;);
        </code>
      </pre> </section> <section class="strf-section"> <h2>2. Using the Helper Function</h2> <p>
For a more concise approach, use the <code>setSvelteStorage</code> helper function:
</p> <pre class="strf-code-block">        <code>
import &#123; writable &#125; from 'svelte/store';
import &#123; startStoragefy, setSvelteStorage &#125; from "storagefy";

// Initialize storage backend
startStoragefy(&#123;
  dbName: "my-svelte-app",
  adapter: "localStorage"
&#125;);

// Create a Svelte store
const userPrefs = writable(&#123;
  notifications: true,
  darkMode: false
&#125;);

// Use the helper function to load and persist in one step
await setSvelteStorage(userPrefs, "user-preferences", &#123;
  timeout: 86400000, // 24 hours
  ignoreKeys: ["tempPrefs"],
  syncTabs: true
&#125;);
        </code>
      </pre> </section> <section class="strf-section"> <h2>3. Test It</h2> <astro-island uid="Z21D4jM" component-url="/storagefy/_astro/STRGF_ShoppingDemo.DERiBFp-.js" component-export="default" renderer-url="/storagefy/_astro/client.svelte.CE9Ko-11.js" props="{}" ssr client="only" opts="{&quot;name&quot;:&quot;STRGF_ShopDemo&quot;,&quot;value&quot;:true}"></astro-island> </section> <section class="strf-section"> <h2>4. Advanced Configuration</h2> <p>
You can directly instantiate the <code>SvelteAdapter</code> class for more advanced control:
</p> <pre class="strf-code-block">        <code>
import &#123; writable &#125; from 'svelte/store';
import &#123; SvelteAdapter, IndexedDBAdapter &#125; from "storagefy";

// Create storage adapter instance
const storageAdapter = new IndexedDBAdapter(&#123; 
  dbName: "svelte-app",
  encrypt: true
&#125;);

// Create Svelte adapter with the storage adapter
const svelteAdapter = new SvelteAdapter(storageAdapter);

// Create a Svelte store
const cartStore = writable(&#123; items: [], total: 0 &#125;);

// Hydrate store from storage
await svelteAdapter.getFromStorage(cartStore, "shopping-cart");

// Set up persistence
await svelteAdapter.setInStorage(cartStore, "shopping-cart", &#123;
  ignoreKeys: ["pendingActions"],
  timeout: 3600000 // 1 hour
&#125;);
        </code>
      </pre> </section> <section class="strf-section"> <h2>5. Configuration Options</h2> <p>
The <code>setInStorage</code> method accepts the following options:
</p> <div class="strf-options"> <h3>Options Object</h3> <ul> <li> <code>ignoreKeys</code>: Array of store property keys to exclude from persistence
<p class="strf-option-desc">
Use this for sensitive data or temporary state that shouldn't be persisted.
</p> </li> <li> <code>timeout</code>: Expiration duration in milliseconds
<p class="strf-option-desc">
After this duration, the stored data will be considered expired and removed.
</p> </li> <li> <code>syncTabs</code>: Boolean flag to enable cross-tab synchronization
<p class="strf-option-desc">
When true, changes made in one browser tab will be reflected in all others.
              Requires <code>channelName</code> to be set during <code>startStoragefy</code>.
</p> </li> </ul> </div> </section> <section class="strf-section"> <h2>6. Store Compatibility</h2> <p>
The Svelte adapter works with stores that follow Svelte's store contract:
</p> <ul> <li> <strong>Writable stores</strong>: Full read/write support with <code>subscribe</code>, <code>set</code>, and <code>update</code> methods
</li> <li> <strong>Custom stores</strong>: Compatible as long as they implement the <code>subscribe</code> and <code>set</code> methods
</li> </ul> <pre class="strf-code-block">        <code>
// Works with standard writable stores
import &#123; writable &#125; from 'svelte/store';
const standardStore = writable(&#123; count: 0 &#125;);

// Works with custom stores that implement the store contract
function createCustomStore(initial) &#123;
  const &#123; subscribe, set, update &#125; = writable(initial);
  
  return &#123;
    subscribe,
    set,
    increment: () => update(n => (&#123; count: n.count + 1 &#125;)),
    reset: () => set(&#123; count: 0 &#125;)
  &#125;;
&#125;

const customStore = createCustomStore(&#123; count: 0 &#125;);
await setSvelteStorage(customStore, "counter");
        </code>
      </pre> </section> <section class="strf-section"> <h2>7. Cross-Tab Synchronization</h2> <p>
When <code>syncTabs: true</code> is set, your Svelte stores will automatically stay in sync across browser tabs:
</p> <pre class="strf-code-block">        <code>
// In Tab 1
const sharedStore = writable(&#123; value: 'initial' &#125;);
await setSvelteStorage(sharedStore, "shared-data", &#123; syncTabs: true &#125;);

// Later in Tab 1
sharedStore.update(state => (&#123; ...state, value: 'updated' &#125;));

// In Tab 2 (automatically updated)
// sharedStore value will now be &#123; value: 'updated' &#125;
        </code>
      </pre> <p>
This feature uses the <code>BroadcastChannel</code> API to synchronize changes across tabs or windows.
        Make sure to specify a <code>channelName</code> when calling <code>startStoragefy</code>.
</p> </section> <section class="strf-section"> <h2>8. API Reference</h2> <div class="strf-api-method"> <h3><code>getSvelteAdapter([options])</code></h3> <p>
Returns a configured Svelte adapter instance. Options include:
</p> <ul> <li><code>adapterParams</code>: Configuration for the underlying storage adapter</li> </ul> <p>Returns: <code>&#123; setInStorage, getFromStorage &#125;</code> methods</p> </div> <div class="strf-api-method"> <h3><code>setSvelteStorage(store, key, [options])</code></h3> <p>
Helper function that internally calls <code>getFromStorage</code> followed by <code>setInStorage</code>.
</p> <ul> <li><code>store</code>: Svelte writable store instance</li> <li><code>key</code>: Storage key string</li> <li><code>options</code>: Configuration options (ignoreKeys, timeout, syncTabs)</li> </ul> <p>Returns: Promise resolving to true on success</p> </div> <div class="strf-api-method"> <h3><code>SvelteAdapter</code> Class Methods</h3> <ul> <li> <code>setInStorage(store, key, options)</code>: Persists store state and sets up subscription
</li> <li> <code>getFromStorage(store, key)</code>: Loads persisted state into store
</li> <li> <code>destroy()</code>: Cleans up subscriptions when adapter is no longer needed
</li> </ul> </div> </section> <section class="strf-section"> <h2>9. Best Practices</h2> <ul> <li>
Always call <code>getFromStorage</code> before <code>setInStorage</code> to hydrate your store with existing data
</li> <li>
For simplicity, use the <code>setSvelteStorage</code> helper which handles this sequence automatically
</li> <li>
Use appropriate timeout values based on your data's volatility (longer for preferences, shorter for temporary state)
</li> <li>
Call <code>destroy()</code> on the adapter when you no longer need it to clean up subscriptions
</li> <li>
For larger applications, consider a more structured approach to key naming, such as prefixing with module names
</li> <li>
Be thoughtful about what you persist - don't store large objects unnecessarily
</li> </ul> </section> </div>  </section> </main> <footer class="strf-footer"> <div>
Developed by
<br> <a href="https://www.linkedin.com/in/arthurjgermano" target="_blank">
Arthur José Germano
</a> </div> <div>MIT License – © 2025</div> </footer> </body></html>