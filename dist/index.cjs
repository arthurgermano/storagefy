var le=Object.create;var C=Object.defineProperty;var he=Object.getOwnPropertyDescriptor;var de=Object.getOwnPropertyNames;var fe=Object.getPrototypeOf,pe=Object.prototype.hasOwnProperty;var ue=(n,e)=>{for(var t in e)C(n,t,{get:e[t],enumerable:!0})},Y=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of de(e))!pe.call(n,i)&&i!==t&&C(n,i,{get:()=>e[i],enumerable:!(r=he(e,i))||r.enumerable});return n};var f=(n,e,t)=>(t=n!=null?le(fe(n)):{},Y(e||!n||!n.__esModule?C(t,"default",{value:n,enumerable:!0}):t,n)),ge=n=>Y(C({},"__esModule",{value:!0}),n);var Ce={};ue(Ce,{IndexedDBAdapter:()=>_,LocalStorageAdapter:()=>A,PiniaAdapter:()=>T,ReactAdapter:()=>N,SessionStorageAdapter:()=>D,SvelteAdapter:()=>O,getPiniaAdapter:()=>se,getReactAdapter:()=>oe,getStorageAdapter:()=>be,getSvelteAdapter:()=>ce,setPiniaStorage:()=>Ae,setReactStorage:()=>De,setSvelteStorage:()=>Ie,startStoragefy:()=>Ee});module.exports=ge(Ce);globalThis.storagefyDebug=!1;globalThis.storagefyDebugLevel=0;var o=(...n)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=0&&(n.unshift("Storagefy Error:"),console.error(...n))},K=(...n)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=1&&(n.unshift("Storagefy Warn:"),console.warn(...n))},a=(...n)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=2&&(n.unshift("Storagefy:"),console.info(...n))};var $=f(require("misc-helpers/src/utils/base64To.js"),1),P=f(require("misc-helpers/src/utils/base64From.js"),1),J=new TextEncoder,ye=new TextDecoder,b,g;function Se(){try{if(a("CryptoHelper - Attempting to initialize crypto engine"),typeof window<"u"&&window.crypto){b=window.crypto,g=b.subtle,a("CryptoHelper - Crypto initialized from window.crypto");return}if(typeof global<"u"&&global.crypto?.webcrypto){b=global.crypto.webcrypto,g=b.subtle,a("CryptoHelper - Crypto initialized from global.webcrypto");return}throw new Error("Crypto API not available")}catch(n){throw o("Failed to initialize crypto:",n),n}}try{Se()}catch(n){o("Failed to initialize crypto:",n)}var we=async n=>{try{return a("CryptoHelper - Generating key material from password"),g.importKey("raw",J.encode(n),"PBKDF2",!1,["deriveKey"])}catch(e){throw o("Error generating key material:",e),e}},R=async(n,e,t=!1)=>{try{if(typeof n!="string"||!n.length)throw new Error("Invalid password");a("CryptoHelper - Deriving key with PBKDF2",{passwordLength:n.length,extractable:t});let r=await we(n);return g.deriveKey({name:"PBKDF2",salt:J.encode(e),iterations:1e5,hash:"SHA-256"},r,{name:"AES-GCM",length:256},t,["encrypt","decrypt"])}catch(r){throw o("Error deriving key:",r),r}},j=async(n,e,t=!1)=>{if(e===void 0||typeof e=="function"||typeof e=="symbol")throw new Error("Invalid data type for encryption");try{a("CryptoHelper - Encrypting data",{raw:t});let r=b.getRandomValues(new Uint8Array(12)),i=J.encode(JSON.stringify(e)),s=await g.encrypt({name:"AES-GCM",iv:r},n,i);if(t)return{iv:r,data:new Uint8Array(s)};let c=(0,$.default)(String.fromCharCode(...r)),l=(0,$.default)(String.fromCharCode(...new Uint8Array(s)));return{iv:c,data:l}}catch(r){throw o("Error encrypting data:",r),r}},V=async(n,e,t=!1)=>{let r,i;try{if(a("CryptoHelper - Decrypting data",{raw:t}),t)r=new Uint8Array(e.iv),i=new Uint8Array(e.data);else{let c=l=>new Uint8Array((0,P.default)(l).split("").map(h=>h.charCodeAt(0)));r=c(e.iv),i=c(e.data)}let s=await g.decrypt({name:"AES-GCM",iv:r},n,i);return JSON.parse(ye.decode(s))}catch(s){throw o("Error decrypting data:",s),s}};function Q(n){if(!n)return n;a("CryptoHelper - Obfuscating string");try{let e=[...n].map(t=>String.fromCharCode(t.charCodeAt(0)+1)).join("");return(0,$.default)(e)}catch{return n}}function y(n){if(!n)return n;a("CryptoHelper - Deobfuscating string");try{return[...(0,P.default)(n)].map(t=>String.fromCharCode(t.charCodeAt(0)-1)).join("")}catch{return n}}var X=f(require("misc-helpers/src/utils/generateSimpleId.js"),1),F=class{constructor(e){try{typeof e!="string"&&(e=(0,X.default)("storagefy_channel")),this.channel=new BroadcastChannel(e),this.channelName=e,a(`CrossTabChannel initialized on channel "${e}"`)}catch(t){throw o("Failed to initialize BroadcastChannel:",t),t}}subscribe(e){if(typeof e!="function"){K("CrossTabChannel.subscribe: Provided callback is not a function.");return}this.channel.onmessage=t=>{a("CrossTabChannel - Received message:",t.data);try{e(t.data)}catch(r){o("Error in CrossTabChannel subscriber callback:",r)}},a("CrossTabChannel - Subscribed to incoming messages.")}emit(e){try{this.channel.postMessage(e),a("CrossTabChannel - Emitted message:",e)}catch(t){o("CrossTabChannel.emit: Failed to send message:",t)}}close(){try{this.channel.close(),a("CrossTabChannel - Channel closed.")}catch(e){o("CrossTabChannel.close: Error closing channel:",e)}}},Z=F;var H=class{constructor(e){e?(a("StorageAdapter - Initializing cross-tab channel:",e),this.channelName=e,this.channel=new Z(e)):(this.channel=null,this.channelName=null,K("StorageAdapter - No channel name provided, cross-tab syncing disabled."))}async get(e){throw new Error("Not implemented")}async set(e,t,r){throw new Error("Not implemented")}async delete(e){throw new Error("Not implemented")}async list(e=""){throw new Error("Not implemented")}async reset(){throw new Error("Not implemented")}async clear(){throw new Error("Not implemented")}async clearExpire(){throw new Error("Not implemented")}async setExpire(e,t){throw new Error("Not implemented")}async deleteExpire(e){throw new Error("Not implemented")}async has(e){throw new Error("Not implemented")}async _encrypt(e,t){if(!this.encrypt||!e)return t;try{let r=await R(e),i=await j(r,t,!1);return a(`StorageAdapter - Successfully encrypted value for key "${e}".`),JSON.stringify(i)}catch(r){return o("Encryption failed:",r),null}}async _decrypt(e,t){if(!this.encrypt||!e)return JSON.parse(t);try{let r=await R(e),i=JSON.parse(t),s=await V(r,i,!1);return a(`StorageAdapter - Successfully decrypted value for key "${e}".`),JSON.parse(s)}catch(r){return o("Decryption failed:",r),null}}_fullKey(e){let t=`${this.prefix}${e}`;if(this.encrypt){let r=Q(t);return a(`StorageAdapter - Obfuscated key "${e}" to "${r}".`),r}return a(`StorageAdapter - Using plain key: "${t}"`),t}_startExpireWatcher(){this._expireTimer&&clearInterval(this._expireTimer),!(this.expireCheckInterval<=0)&&(this._expireTimer=setInterval(()=>{try{a("StorageAdapter - Running expiration cleanup..."),this.clearExpire()}catch(e){o("Error clearing expired keys:",e)}},this.expireCheckInterval),a(`StorageAdapter - Expire watcher started, interval: ${this.expireCheckInterval}ms`))}destroy(){this._expireTimer&&(clearInterval(this._expireTimer),this._expireTimer=null,a("StorageAdapter - Expire watcher stopped.")),this._unloadHandler&&(window.removeEventListener("beforeunload",this._unloadHandler),this._unloadHandler=null,a("StorageAdapter - Removed unload handler."))}async getAll(e){return a(`StorageAdapter - Getting all keys under table: "${e}"`),this.list(`${e}__`)}async getExpire(e){try{let t=await this._loadExpires();return a(`StorageAdapter - Getting expiration for key "${e}":`,t[e]||null),t[e]||null}catch(t){return o(`Error getting expire for key '${e}':`,t),null}}emitDataChange(e,t,r){!this.channelName||!r||(a(`StorageAdapter - Emitting data change for key "${e}" from origin "${r}"`),this.channel.emit({adapterId:this.adapterId,key:e,value:t,origin:r}))}onDataChanged(e){!this.channelName||typeof e!="function"||(a("StorageAdapter - Subscribing to cross-tab data changes."),this.channel.subscribe(e))}},S=H;var ee=f(require("misc-helpers/src/utils/sleep.js"),1),te=f(require("misc-helpers/src/utils/generateSimpleId.js"),1);var B=class extends S{constructor({dbName:e,storeName:t,version:r=1,encrypt:i=!1,expireCheckInterval:s=1e3,channelName:c=!1,enableSyncTabs:l=!1,description:h=""}){if(super(c),typeof indexedDB>"u")throw o("IndexedDB is not available in this environment"),new Error("IndexedDB is not available in this environment");this.isReady=!1,this.dbName=e,this.storeName=t||`${e}_store`,this.encrypt=i,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=(0,te.default)(e),this.enableSyncTabs=l||!1,this.expireCheckInterval=s,this.dbPromise=null,this._initDB({dbName:e,version:r,description:h}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),a(`IndexedDBAdapter - initialized with dbName: ${e}, storeName: ${this.storeName}`)}_initDB({dbName:e,version:t,description:r}){a(`IndexedDBAdapter -Initializing IndexedDB with dbName: ${e}, storeName: ${this.storeName}`),this.dbPromise=new Promise((i,s)=>{let c=indexedDB.open(e,t);c.onupgradeneeded=l=>{let h=l.target.result;h.objectStoreNames.contains(this.storeName)||h.createObjectStore(this.storeName);let d={dbName:e,version:t,description:r,createdAt:Date.now()};l.target.transaction.objectStore(this.storeName).put(JSON.stringify(d),this.metaKey)},c.onsuccess=l=>{let h=l.target.result,v=h.transaction(this.storeName,"readwrite").objectStore(this.storeName),I=v.get(this.metaKey);I.onsuccess=()=>{if(!I.result){let L={dbName:e,version:t,description:r,createdAt:Date.now()};v.put(JSON.stringify(L),this.metaKey)}this.isReady=!0,i(h)},I.onerror=L=>{o("Error checking meta:",L),i(h)}},c.onerror=l=>{o("Error opening database:",l.target.error),s(l.target.error)}})}async waitReadiness(e=50,t=20){return a(`IndexedDBAdapter - Waiting for database readiness with timeout: ${e}ms, tries: ${t}`),new Promise(async(r,i)=>{let s=0;for(;!this.isReady&&s++<=t;){if(this.isReady)return r(),!0;await(0,ee.default)(e)}if(this.isReady)return r(),!0;i(new Error("Database is not ready"))})}async _withStore(e,t){try{a(`IndexedDBAdapter - Executing operation in ${e} mode`);let s=(await this.dbPromise).transaction(this.storeName,e).objectStore(this.storeName);return await t(s)}catch(r){throw o("Database operation failed:",r),r}}async _loadExpires(){return a("IndexedDBAdapter - Loading expiration timestamps"),this._withStore("readonly",async e=>new Promise(t=>{let r=e.get(this.expireKey);r.onsuccess=()=>{t(r.result?JSON.parse(r.result):{})},r.onerror=()=>{t({})}}))}async get(e){try{a(`IndexedDBAdapter - Getting key: ${e}`);let t=this._fullKey(e),r=await this._withStore("readonly",s=>new Promise(c=>{let l=s.get(t);l.onsuccess=()=>c(l.result),l.onerror=()=>c(null)}));if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return o(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(a(`IndexedDBAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let s=await this._encrypt(e,t);return s?(await this._withStore("readwrite",c=>new Promise(l=>{let h=c.put(s,i);h.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),l(!0)},h.onerror=()=>l(!1)})),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return o(`Error setting key '${e}':`,i),!1}}async delete(e){try{a(`IndexedDBAdapter - Deleting key: ${e}`);let t=this._fullKey(e);await this._withStore("readwrite",i=>new Promise(s=>{let c=i.delete(t);c.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),s(!0)},c.onerror=()=>s()}));let r=await this._loadExpires();delete r[e],await this._withStore("readwrite",i=>new Promise(s=>{let c=i.put(JSON.stringify(r),this.expireKey);c.onsuccess=()=>s(),c.onerror=()=>s()}))}catch(t){o(`Error deleting key '${e}':`,t)}}async list(){let e=[];try{a(`IndexedDBAdapter - Listing keys with prefix: ${this.prefix}`),await this._withStore("readonly",async t=>new Promise(r=>{let i=t.getAllKeys();i.onsuccess=async()=>{let s=i.result||[];for(let c of s)if(this.encrypt&&(c=y(c)),!(c===this.metaKey||c===this.expireKey)&&c.startsWith(this.prefix)){let l=await this.get(c.replace(this.prefix,""));l!==null&&e.push({key:c.replace(this.prefix,""),value:l})}r()},i.onerror=()=>r()}))}catch(t){o("Error listing keys:",t)}return e}async has(e){try{a(`IndexedDBAdapter - Checking existence of key: ${e}`);let t=this._fullKey(e);return await this._withStore("readonly",r=>new Promise(i=>{let s=r.getKey(t);s.onsuccess=()=>i(s.result!==void 0),s.onerror=()=>i(!1)}))}catch(t){return o(`Error checking key '${e}':`,t),!1}}async clear(){try{a("IndexedDBAdapter - Clearing all data"),await this.reset(),await this._withStore("readwrite",e=>new Promise(t=>{let r=e.delete(this.metaKey);r.onsuccess=()=>{let i=e.delete(this.expireKey);i.onsuccess=()=>t(),i.onerror=()=>t()},r.onerror=()=>t()}))}catch(e){o("Error clearing storage:",e)}}async reset(){try{a("IndexedDBAdapter - Resetting storage"),await this._withStore("readwrite",async e=>new Promise(t=>{let r=e.getAllKeys();r.onsuccess=()=>{let i=r.result||[];if(i.length===0){t();return}let s=0,c=l=>()=>{++s===i.length&&(this.enableSyncTabs&&this.emitDataChange(l.replace(this.prefix,""),"reset"),t())};for(let l of i){let h=e.delete(l);h.onsuccess=c(l),h.onerror=c(l)}},r.onerror=()=>t()}))}catch(e){o("Error resetting storage:",e)}}async setExpire(e,t){try{a(`IndexedDBAdapter - Setting expire for key: ${e}, timestamp: ${t}`);let r=await this._loadExpires();r[e]=t,await this._withStore("readwrite",i=>new Promise(s=>{let c=i.put(JSON.stringify(r),this.expireKey);c.onsuccess=()=>s(),c.onerror=()=>s()}))}catch(r){o(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{a(`IndexedDBAdapter - Deleting expire for key: ${e}`);let t=await this._loadExpires();delete t[e],await this._withStore("readwrite",r=>new Promise(i=>{let s=r.put(JSON.stringify(t),this.expireKey);s.onsuccess=()=>i(),s.onerror=()=>i()}))}catch(t){o(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{a("IndexedDBAdapter - Clearing expired keys");let e=Date.now(),t=await this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);if(r){let i=await this._loadExpires();await this._withStore("readwrite",s=>new Promise(c=>{let l=s.put(JSON.stringify(i),this.expireKey);l.onsuccess=()=>c(),l.onerror=()=>c()}))}}catch(e){o("Error clearing expired keys:",e)}}},_=B;var re=f(require("misc-helpers/src/utils/generateSimpleId.js"),1);var G=class extends S{constructor({dbName:e,version:t=1,encrypt:r=!1,expireCheckInterval:i=1e3,description:s="",channelName:c=!1,enableSyncTabs:l=!1}){if(super(c),typeof localStorage>"u")throw o("LocalStorage is not available in this environment"),new Error("LocalStorage is not available in this environment");this.dbName=e,this.encrypt=r,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=(0,re.default)(e),this.expireCheckInterval=i,this.enableSyncTabs=l||!1,this._initMeta({dbName:e,version:t,description:s}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),a(`LocalStorageAdapter -  initialized with dbName: ${e}, version: ${t}, encrypt: ${r}, description: ${s}`)}_initMeta({dbName:e,version:t,description:r}){try{a("LocalStorageAdapter - Initializing metadata for LocalStorageAdapter");let i={dbName:e,version:t,description:r,createdAt:Date.now()};localStorage.setItem(this.metaKey,JSON.stringify(i))}catch(i){o("Error initializing meta:",i)}}_loadExpires(){try{a("LocalStorageAdapter - Loading expiration metadata");let e=localStorage.getItem(this.expireKey);return e?JSON.parse(e):{}}catch(e){return o("Error loading expires:",e),{}}}async get(e){try{a(`LocalStorageAdapter - Getting key: ${e}`);let t=this._fullKey(e),r=localStorage.getItem(t);if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return o(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(a(`LocalStorageAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let s=await this._encrypt(e,t);return s?(localStorage.setItem(i,s),this.enableSyncTabs&&this.emitDataChange(e,void 0,"set"),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return o(`Error setting key '${e}':`,i),!1}}async delete(e){try{a(`LocalStorageAdapter - Deleting key: ${e}`);let t=this._fullKey(e);localStorage.removeItem(t);let r=this._loadExpires();delete r[e],localStorage.setItem(this.expireKey,JSON.stringify(r)),this.enableSyncTabs&&this.emitDataChange(e,void 0,"delete")}catch(t){o(`Error deleting key '${e}':`,t)}}async list(){let e=[];a(`LocalStorageAdapter - Listing keys with prefix: ${this.prefix}`);try{for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);if(this.encrypt&&(r=y(r)),!(r===this.metaKey||r===this.expireKey)&&r.startsWith(this.prefix)){let i=await this.get(r.replace(this.prefix,""));i!==null&&e.push({key:r.replace(this.prefix,""),value:i})}}}catch(t){throw o("Error listing keys:",t),t}return e}async has(e){try{a(`LocalStorageAdapter - Checking existence of key: ${e}`);let t=this._fullKey(e);return localStorage.getItem(t)!==null}catch(t){return o(`Error checking key '${e}':`,t),!1}}async clear(){try{a("LocalStorageAdapter - Clearing all data"),await this.reset(),localStorage.removeItem(this.metaKey),localStorage.removeItem(this.expireKey)}catch(e){o("Error clearing storage:",e)}}async reset(){try{a("LocalStorageAdapter - Resetting storage");let e=[];for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);r.startsWith(this.prefix)&&e.push(r)}for(let t of e)localStorage.removeItem(t),this.enableSyncTabs&&this.emitDataChange(t.replace(this.prefix,""),void 0,"reset")}catch(e){o("Error resetting storage:",e)}}async setExpire(e,t){try{a(`LocalStorageAdapter - Setting expiration for key: ${e}`,{timestamp:t});let r=this._loadExpires();r[e]=t,localStorage.setItem(this.expireKey,JSON.stringify(r))}catch(r){o(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{a(`LocalStorageAdapter - Deleting expiration for key: ${e}`);let t=this._loadExpires();delete t[e],localStorage.setItem(this.expireKey,JSON.stringify(t))}catch(t){o(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{a("LocalStorageAdapter - Clearing expired keys");let e=Date.now(),t=this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);r&&localStorage.setItem(this.expireKey,JSON.stringify(this._loadExpires()))}catch(e){o("Error clearing expired keys:",e)}}},A=G;var ie=f(require("misc-helpers/src/utils/generateSimpleId.js"),1);var q=class extends S{constructor({dbName:e,version:t=1,encrypt:r=!1,expireCheckInterval:i=1e3,channelName:s=!1,description:c="",enableSyncTabs:l=!1}){if(super(s),typeof sessionStorage>"u")throw o("SessionStorage is not available in this environment"),new Error("SessionStorage is not available in this environment");this.dbName=e,this.encrypt=r,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=(0,ie.default)(e),this.expireCheckInterval=i,this.enableSyncTabs=l||!1,this._initMeta({dbName:e,version:t,description:c}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),a(`SessionStorageAdapter - initialized with prefix: ${this.prefix}, encrypt: ${this.encrypt}`)}_initMeta({dbName:e,version:t,description:r}){try{a(`SessionStorageAdapter - Initializing metadata for ${e} v${t}`);let i={dbName:e,version:t,description:r,createdAt:Date.now()};sessionStorage.setItem(this.metaKey,JSON.stringify(i))}catch(i){o("Error initializing meta:",i)}}_loadExpires(){try{a("SessionStorageAdapter - Loading expiration map");let e=sessionStorage.getItem(this.expireKey);return e?JSON.parse(e):{}}catch(e){return o("Error loading expires:",e),{}}}async get(e){try{a(`SessionStorageAdapter - Getting key '${e}'`);let t=this._fullKey(e),r=sessionStorage.getItem(t);if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return o(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(a(`SessionStorageAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let s=await this._encrypt(e,t);return s?(sessionStorage.setItem(i,s),this.enableSyncTabs&&this.emitDataChange(e,s,"set"),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return o(`Error setting key '${e}':`,i),!1}}async delete(e){try{a(`SessionStorageAdapter - Deleting key '${e}'`);let t=this._fullKey(e);sessionStorage.removeItem(t);let r=this._loadExpires();delete r[e],sessionStorage.setItem(this.expireKey,JSON.stringify(r)),this.enableSyncTabs&&this.emitDataChange(e,void 0,"delete")}catch(t){o(`Error deleting key '${e}':`,t)}}async list(){let e=[];try{a(`SessionStorageAdapter - Listing keys with prefix '${this.prefix}'`);for(let t=0;t<sessionStorage.length;t++){let r=sessionStorage.key(t);if(this.encrypt&&(r=y(r)),!(r===this.metaKey||r===this.expireKey)&&r.startsWith(this.prefix)){let i=await this.get(r.replace(this.prefix,""));i!==null&&e.push({key:r.replace(this.prefix,""),value:i})}}}catch(t){throw o("Error listing keys:",t),t}return e}async has(e){try{a(`SessionStorageAdapter - Checking existence of key '${e}'`);let t=this._fullKey(e);return sessionStorage.getItem(t)!==null}catch(t){return o(`Error checking key '${e}':`,t),!1}}async clear(){try{a("SessionStorageAdapter - Clearing all data"),await this.reset(),sessionStorage.removeItem(this.metaKey),sessionStorage.removeItem(this.expireKey)}catch(e){o("Error clearing storage:",e)}}async reset(){try{a("SessionStorageAdapter - Resetting storage");let e=[];for(let t=0;t<sessionStorage.length;t++){let r=sessionStorage.key(t);r.startsWith(this.prefix)&&e.push(r)}for(let t of e)sessionStorage.removeItem(t),this.enableSyncTabs&&this.emitDataChange(t.replace(this.prefix,""),void 0,"reset")}catch(e){o("Error resetting storage:",e)}}async setExpire(e,t){try{a(`SessionStorageAdapter - Setting expire for key '${e}'`);let r=this._loadExpires();r[e]=t,sessionStorage.setItem(this.expireKey,JSON.stringify(r))}catch(r){o(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{a(`SessionStorageAdapter - Deleting expire for key '${e}'`);let t=this._loadExpires();delete t[e],sessionStorage.setItem(this.expireKey,JSON.stringify(t))}catch(t){o(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{a("SessionStorageAdapter - Clearing expired keys");let e=Date.now(),t=this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);r&&sessionStorage.setItem(this.expireKey,JSON.stringify(this._loadExpires()))}catch(e){o("Error clearing expired keys:",e)}}},D=q;var k=class{async setInStorage(e,t,r={}){throw new Error("Not implemented")}async getFromStorage(e,t,r){throw new Error("Not implemented")}destroy(e){if(this._unsubscribe&&this._unsubscribe[e]){a("StoreAdapter - destroy - Unsubscribing from store changes."),this._unsubscribe[e](),delete this._unsubscribe[e];return}a("StoreAdapter - destroy - No unsubscribe function to call.")}},w=k;var ne=f(require("misc-helpers/src/utils/assign.js"),1);var W=class extends w{constructor(e){if(super(),!e)throw o("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this._unsubscribe={}}_checkStore(e){if(!e||!e.$subscribe||!e.$patch)throw o("Store provided is not defined"),new Error("Store provided is not defined")}_registerOnDataChanged(e){a("PiniaAdapter - Registering onDataChanged listener"),e&&this.adapter.onDataChanged(async t=>{try{if(t.adapterId==this.adapter.adapterId||!t.origin)return;let r;if(t.value?r=await this.adapter._decrypt(t.key,t.value):r=await this.adapter.get(t.key),JSON.stringify(e.$state)===JSON.stringify(r))return;e.$state={...e.$state,...r,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}}catch(r){o("PiniaAdapter - onDataChanged - error:",r)}})}async setInStorage(e,t,r={}){try{return a("PiniaAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this._unsubscribe[t]&&(this._unsubscribe[t](),delete this._unsubscribe[t]),new Promise((i,s)=>{this._unsubscribe[t]=e.$subscribe(async(c,l)=>{try{if(!l)return i(!0);if(l.STORAGEFY_SILENT_CHANNEL_UPDATE)return delete l.STORAGEFY_SILENT_CHANNEL_UPDATE,i(!0);let h={...l};for(let d in h)r.ignoreKeys.includes(d)&&(h[d]=void 0);return await this.adapter.set(t,h,r.timeout),i(!0)}catch(h){return s(h)}}),e.$patch({...e.$state}),r.syncTabs&&this._registerOnDataChanged(e)})}catch(i){throw o(i),i}}async getFromStorage(e,t){try{a("PiniaAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);return r?(e.$patch((0,ne.default)({},r)),!0):void 0}catch(r){throw o(r),r}}},T=W;var ae=f(require("misc-helpers/src/utils/assign.js"),1);var U=class extends w{constructor(e){if(super(),!e)throw o("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this._unsubscribe={}}_getPayload(e,t){return{...e,...t,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}}_registerOnDataChanged(e){a("ReactAdapter - Registering onDataChanged listener"),e&&this.adapter.onDataChanged(async t=>{try{if(t.adapterId==this.adapter.adapterId||!t.origin)return;let r;if(t.value?r=await this.adapter._decrypt(t.key,t.value):r=await this.adapter.get(t.key),typeof e.dispatch=="function"&&typeof e.getState=="function"){let s=e.getState();if(JSON.stringify(s)===JSON.stringify(r))return;e.dispatch({type:"STORAGEFY_UPDATE",payload:this._getPayload(s,r)});return}if(typeof e.getState=="function"&&typeof e.setState=="function"){let s=e.getState();if(JSON.stringify(s)===JSON.stringify(r))return;e.setState(this._getPayload(s,r));return}if(typeof e.set=="function"&&typeof e.get=="function"){let s=e.get();if(JSON.stringify(s)===JSON.stringify(r))return;e.set(this._getPayload(s,r));return}if(typeof e.update=="function"){e.update(s=>JSON.stringify(s)===JSON.stringify(r)?s:this._getPayload(s,r));return}let i=typeof e.getState=="function"?e.getState():typeof e.get=="function"?e.get():{};if(JSON.stringify(i)===JSON.stringify(r))return;typeof e.set=="function"?e.set(this._getPayload(i,r)):o("Unable to update store: No compatible update method found")}catch(r){o("Error in _registerOnDataChanged:",r)}})}async setInStorage(e,t,r={}){try{return a("ReactAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this._unsubscribe[t]&&(this._unsubscribe[t](),delete this._unsubscribe[t]),new Promise((i,s)=>{let c=async l=>{try{if(!l)return;if(l.STORAGEFY_SILENT_CHANNEL_UPDATE)return delete l.STORAGEFY_SILENT_CHANNEL_UPDATE,i(!0);let h={...l};for(let d in h)r.ignoreKeys.includes(d)&&(h[d]=void 0);await this.adapter.set(t,h,r.timeout)}catch(h){o(h)}};if(typeof e.subscribe=="function"&&typeof e.getState=="function")c(e.getState()),this._unsubscribe[t]=e.subscribe(()=>{c(e.getState())});else if(typeof e.subscribe=="function")this._unsubscribe[t]=e.subscribe(c);else{s(new Error("Unsupported store type"));return}r.syncTabs&&this._registerOnDataChanged(e),i(!0)})}catch(i){throw o(i),i}}async getFromStorage(e,t){try{a("ReactAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);if(!r)return;if(typeof e.dispatch=="function")e.dispatch({type:"SET_STATE_FROM_STORAGE",payload:r});else if(typeof e.setState=="function")e.setState((0,ae.default)({},r));else throw new Error("Cannot update store: setState or dispatch method not found");return!0}catch(r){throw o(r),r}}_checkStore(e){if(!e)throw o("Store provided is not defined"),new Error("Store provided is not defined");if(typeof e.getState=="function"&&typeof e.dispatch=="function"&&typeof e.subscribe=="function"||typeof e.getState=="function"&&typeof e.setState=="function"&&typeof e.subscribe=="function"||(console.log("STORE>>",e),Array.isArray(e)&&e.length===2&&typeof e[0]=="function"&&typeof e[1]=="function"))return;let t=typeof e.getState=="function"||typeof e._getState=="function",r=typeof e.setState=="function"||typeof e._setState=="function";if(!(typeof e.subscribe=="function"))throw o("Store must have a subscribe method"),new Error("Store must have a subscribe method");if(!t&&!r)throw o("Store must have either getState/setState or _getState/_setState methods"),new Error("Store must have either getState/setState or _getState/_setState methods")}},N=U;var z=f(require("misc-helpers/src/utils/assign.js"),1);var M=class extends w{constructor(e){if(super(),!e)throw o("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this._unsubscribe={}}_registerOnDataChanged(e){a("SvelteAdapter - Registering onDataChanged listener");try{if(!e)return;this.adapter.onDataChanged(async t=>{if(t.adapterId==this.adapter.adapterId||!t.origin)return;let r;e.subscribe(c=>{r=(0,z.default)({},c)})();let s;t.value?s=await this.adapter._decrypt(t.key,t.value):s=await this.adapter.get(t.key),JSON.stringify(r)!==JSON.stringify(s)&&e.update(c=>({...c,...s,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}))})}catch(t){throw o("SvelteAdapter - onDataChanged error:",t),t}}async setInStorage(e,t,r={}){try{return a("SvelteAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this._unsubscribe[t]&&(this._unsubscribe[t](),delete this._unsubscribe[t]),new Promise((i,s)=>{let c=e.subscribe(async l=>{try{if(!l)return i(!0);let h={...l};for(let d in h)r.ignoreKeys.includes(d)&&(h[d]=void 0);return await this.adapter.set(t,h,r.timeout),i(!0)}catch(h){return s(h)}});this._unsubscribe[t]=c,r.syncTabs&&this._registerOnDataChanged(e)})}catch(i){throw o(i),i}}async getFromStorage(e,t){try{a("SvelteAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);return r?(e.set((0,z.default)({},r)),!0):void 0}catch(r){throw o(r),r}}_checkStore(e){if(!e||typeof e.subscribe!="function"||typeof e.set!="function")throw o("Store provided is not a valid Svelte writable store"),new Error("Store provided is not a valid Svelte writable store")}},O=M;var xe={dbName:"storagefy",storeName:"storagefy_db",version:1,encrypt:!1,expireCheckInterval:1e3,description:"Storagefy database",adapter:"indexedDB"},p,u,m,x;function Ee(n={}){let e={...xe,...n};if(!n.forceRecreate&&p)return p;switch(e.adapter){case"localStorage":if(n.fresh)return new A(e);p=new A(e);break;case"sessionStorage":if(n.fresh)return new D(e);p=new D(e);break;default:if(n.fresh)return new _(e);p=new _(e)}return p}function be(){if(!p)throw new Error("Storage adapter not initialized. Call startStoragefy first.");return p}function E({adapter:n,adapterParams:e,forceRecreate:t},r,i){if(n)return new i(n);if(r&&!t)return r;if(e){let s=_e(e);return new i(s)}if(!p)throw new Error("Storage adapter not initialized. Call startStoragefy first.");return new i(p)}function _e(n){switch(n.adapter){case"localStorage":return new A(n);case"sessionStorage":return new D(n);default:return new _(n)}}function se({adapter:n=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?E({adapter:n,adapterParams:e,forceRecreate:t},null,T):(u=E({adapter:n,adapterParams:e,forceRecreate:t},u,T),{setInStorage:u.setInStorage.bind(u),getFromStorage:u.getFromStorage.bind(u)})}function oe({adapter:n=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?E({adapter:n,adapterParams:e,forceRecreate:t},null,N):(m=E({adapter:n,adapterParams:e,forceRecreate:t},m,N),m)}function ce({adapter:n=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?E({adapter:n,adapterParams:e,forceRecreate:t},null,O):(x=E({adapter:n,adapterParams:e,forceRecreate:t},x,O),x)}async function Ae(n,e,t={}){try{if(u||se(),!n)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await u.getFromStorage(n,e),await u.setInStorage(n,e,t)}catch(r){throw logError(r),r}}async function De(n,e,t={}){try{if(m||oe(),!n)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await m.getFromStorage(n,e),await m.setInStorage(n,e,t)}catch(r){throw logError(r),r}}async function Ie(n,e,t={}){try{if(x||ce(),!n)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await x.getFromStorage(n,e),await x.setInStorage(n,e,t)}catch(r){throw logError(r),r}}0&&(module.exports={IndexedDBAdapter,LocalStorageAdapter,PiniaAdapter,ReactAdapter,SessionStorageAdapter,SvelteAdapter,getPiniaAdapter,getReactAdapter,getStorageAdapter,getSvelteAdapter,setPiniaStorage,setReactStorage,setSvelteStorage,startStoragefy});
//# sourceMappingURL=index.cjs.map