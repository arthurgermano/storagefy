var le=Object.create;var C=Object.defineProperty;var he=Object.getOwnPropertyDescriptor;var fe=Object.getOwnPropertyNames;var de=Object.getPrototypeOf,pe=Object.prototype.hasOwnProperty;var ue=(s,e)=>{for(var t in e)C(s,t,{get:e[t],enumerable:!0})},Y=(s,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of fe(e))!pe.call(s,i)&&i!==t&&C(s,i,{get:()=>e[i],enumerable:!(r=he(e,i))||r.enumerable});return s};var f=(s,e,t)=>(t=s!=null?le(de(s)):{},Y(e||!s||!s.__esModule?C(t,"default",{value:s,enumerable:!0}):t,s)),ge=s=>Y(C({},"__esModule",{value:!0}),s);var Ce={};ue(Ce,{IndexedDBAdapter:()=>_,LocalStorageAdapter:()=>A,PiniaAdapter:()=>T,ReactAdapter:()=>N,SessionStorageAdapter:()=>D,SvelteAdapter:()=>O,getPiniaAdapter:()=>oe,getReactAdapter:()=>ae,getStorageAdapter:()=>be,getSvelteAdapter:()=>ce,setPiniaStorage:()=>Ae,setReactStorage:()=>De,setSvelteStorage:()=>Ie,startStoragefy:()=>Ee});module.exports=ge(Ce);globalThis.storagefyDebug=!0;globalThis.storagefyDebugLevel=0;var o=(...s)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=0&&(s.unshift("Storagefy Error:"),console.error(...s))},K=(...s)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=1&&(s.unshift("Storagefy Warn:"),console.warn(...s))},n=(...s)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=2&&(s.unshift("Storagefy:"),console.info(...s))};var $=f(require("misc-helpers/src/utils/base64To.js"),1),P=f(require("misc-helpers/src/utils/base64From.js"),1),J=new TextEncoder,ye=new TextDecoder,b,g;function Se(){try{if(n("CryptoHelper - Attempting to initialize crypto engine"),typeof window<"u"&&window.crypto){b=window.crypto,g=b.subtle,n("CryptoHelper - Crypto initialized from window.crypto");return}if(typeof global<"u"&&global.crypto?.webcrypto){b=global.crypto.webcrypto,g=b.subtle,n("CryptoHelper - Crypto initialized from global.webcrypto");return}throw new Error("Crypto API not available")}catch(s){throw o("Failed to initialize crypto:",s),s}}try{Se()}catch(s){o("Failed to initialize crypto:",s)}var we=async s=>{try{return n("CryptoHelper - Generating key material from password"),g.importKey("raw",J.encode(s),"PBKDF2",!1,["deriveKey"])}catch(e){throw o("Error generating key material:",e),e}},R=async(s,e,t=!1)=>{try{if(typeof s!="string"||!s.length)throw new Error("Invalid password");n("CryptoHelper - Deriving key with PBKDF2",{passwordLength:s.length,extractable:t});let r=await we(s);return g.deriveKey({name:"PBKDF2",salt:J.encode(e),iterations:1e5,hash:"SHA-256"},r,{name:"AES-GCM",length:256},t,["encrypt","decrypt"])}catch(r){throw o("Error deriving key:",r),r}},j=async(s,e,t=!1)=>{if(e===void 0||typeof e=="function"||typeof e=="symbol")throw new Error("Invalid data type for encryption");try{n("CryptoHelper - Encrypting data",{raw:t});let r=b.getRandomValues(new Uint8Array(12)),i=J.encode(JSON.stringify(e)),a=await g.encrypt({name:"AES-GCM",iv:r},s,i);if(t)return{iv:r,data:new Uint8Array(a)};let c=(0,$.default)(String.fromCharCode(...r)),l=(0,$.default)(String.fromCharCode(...new Uint8Array(a)));return{iv:c,data:l}}catch(r){throw o("Error encrypting data:",r),r}},V=async(s,e,t=!1)=>{let r,i;try{if(n("CryptoHelper - Decrypting data",{raw:t}),t)r=new Uint8Array(e.iv),i=new Uint8Array(e.data);else{let c=l=>new Uint8Array((0,P.default)(l).split("").map(h=>h.charCodeAt(0)));r=c(e.iv),i=c(e.data)}let a=await g.decrypt({name:"AES-GCM",iv:r},s,i);return JSON.parse(ye.decode(a))}catch(a){throw o("Error decrypting data:",a),a}};function Q(s){if(!s)return s;n("CryptoHelper - Obfuscating string");try{let e=[...s].map(t=>String.fromCharCode(t.charCodeAt(0)+1)).join("");return(0,$.default)(e)}catch{return s}}function y(s){if(!s)return s;n("CryptoHelper - Deobfuscating string");try{return[...(0,P.default)(s)].map(t=>String.fromCharCode(t.charCodeAt(0)-1)).join("")}catch{return s}}var X=f(require("misc-helpers/src/utils/generateSimpleId.js"),1),F=class{constructor(e){try{typeof e!="string"&&(e=(0,X.default)("storagefy_channel")),this.channel=new BroadcastChannel(e),this.channelName=e,n(`CrossTabChannel initialized on channel "${e}"`)}catch(t){throw o("Failed to initialize BroadcastChannel:",t),t}}subscribe(e){if(typeof e!="function"){K("CrossTabChannel.subscribe: Provided callback is not a function.");return}this.channel.onmessage=t=>{n("CrossTabChannel - Received message:",t.data);try{e(t.data)}catch(r){o("Error in CrossTabChannel subscriber callback:",r)}},n("CrossTabChannel - Subscribed to incoming messages.")}emit(e){try{this.channel.postMessage(e),n("CrossTabChannel - Emitted message:",e)}catch(t){o("CrossTabChannel.emit: Failed to send message:",t)}}close(){try{this.channel.close(),n("CrossTabChannel - Channel closed.")}catch(e){o("CrossTabChannel.close: Error closing channel:",e)}}},Z=F;var H=class{constructor(e){e?(n("StorageAdapter - Initializing cross-tab channel:",e),this.channelName=e,this.channel=new Z(e)):(this.channel=null,this.channelName=null,K("StorageAdapter - No channel name provided, cross-tab syncing disabled."))}async get(e){throw new Error("Not implemented")}async set(e,t,r){throw new Error("Not implemented")}async delete(e){throw new Error("Not implemented")}async list(e=""){throw new Error("Not implemented")}async reset(){throw new Error("Not implemented")}async clear(){throw new Error("Not implemented")}async clearExpire(){throw new Error("Not implemented")}async setExpire(e,t){throw new Error("Not implemented")}async deleteExpire(e){throw new Error("Not implemented")}async has(e){throw new Error("Not implemented")}async _encrypt(e,t){if(!this.encrypt||!e)return t;try{let r=await R(e),i=await j(r,t,!1);return n(`StorageAdapter - Successfully encrypted value for key "${e}".`),JSON.stringify(i)}catch(r){return o("Encryption failed:",r),null}}async _decrypt(e,t){if(!this.encrypt||!e)return JSON.parse(t);try{let r=await R(e),i=JSON.parse(t),a=await V(r,i,!1);return n(`StorageAdapter - Successfully decrypted value for key "${e}".`),JSON.parse(a)}catch(r){return o("Decryption failed:",r),null}}_fullKey(e){let t=`${this.prefix}${e}`;if(this.encrypt){let r=Q(t);return n(`StorageAdapter - Obfuscated key "${e}" to "${r}".`),r}return n(`StorageAdapter - Using plain key: "${t}"`),t}_startExpireWatcher(){this._expireTimer&&clearInterval(this._expireTimer),!(this.expireCheckInterval<=0)&&(this._expireTimer=setInterval(()=>{try{n("StorageAdapter - Running expiration cleanup..."),this.clearExpire()}catch(e){o("Error clearing expired keys:",e)}},this.expireCheckInterval),n(`StorageAdapter - Expire watcher started, interval: ${this.expireCheckInterval}ms`))}destroy(){this._expireTimer&&(clearInterval(this._expireTimer),this._expireTimer=null,n("StorageAdapter - Expire watcher stopped.")),this._unloadHandler&&(window.removeEventListener("beforeunload",this._unloadHandler),this._unloadHandler=null,n("StorageAdapter - Removed unload handler."))}async getAll(e){return n(`StorageAdapter - Getting all keys under table: "${e}"`),this.list(`${e}__`)}async getExpire(e){try{let t=await this._loadExpires();return n(`StorageAdapter - Getting expiration for key "${e}":`,t[e]||null),t[e]||null}catch(t){return o(`Error getting expire for key '${e}':`,t),null}}emitDataChange(e,t,r){!this.channelName||!r||(n(`StorageAdapter - Emitting data change for key "${e}" from origin "${r}"`),this.channel.emit({adapterId:this.adapterId,key:e,value:t,origin:r}))}onDataChanged(e){!this.channelName||typeof e!="function"||(n("StorageAdapter - Subscribing to cross-tab data changes."),this.channel.subscribe(e))}},S=H;var ee=f(require("misc-helpers/src/utils/sleep.js"),1),te=f(require("misc-helpers/src/utils/generateSimpleId.js"),1);var B=class extends S{constructor({dbName:e,storeName:t,version:r=1,encrypt:i=!1,expireCheckInterval:a=1e3,channelName:c=!1,enableSyncTabs:l=!1,description:h=""}){if(super(c),typeof indexedDB>"u")throw o("IndexedDB is not available in this environment"),new Error("IndexedDB is not available in this environment");this.isReady=!1,this.dbName=e,this.storeName=t||`${e}_store`,this.encrypt=i,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=(0,te.default)(e),this.enableSyncTabs=l||!1,this.expireCheckInterval=a,this.dbPromise=null,this._initDB({dbName:e,version:r,description:h}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),n(`IndexedDBAdapter - initialized with dbName: ${e}, storeName: ${this.storeName}`)}_initDB({dbName:e,version:t,description:r}){n(`IndexedDBAdapter -Initializing IndexedDB with dbName: ${e}, storeName: ${this.storeName}`),this.dbPromise=new Promise((i,a)=>{let c=indexedDB.open(e,t);c.onupgradeneeded=l=>{let h=l.target.result;h.objectStoreNames.contains(this.storeName)||h.createObjectStore(this.storeName);let u={dbName:e,version:t,description:r,createdAt:Date.now()};l.target.transaction.objectStore(this.storeName).put(JSON.stringify(u),this.metaKey)},c.onsuccess=l=>{let h=l.target.result,v=h.transaction(this.storeName,"readwrite").objectStore(this.storeName),I=v.get(this.metaKey);I.onsuccess=()=>{if(!I.result){let L={dbName:e,version:t,description:r,createdAt:Date.now()};v.put(JSON.stringify(L),this.metaKey)}this.isReady=!0,i(h)},I.onerror=L=>{o("Error checking meta:",L),i(h)}},c.onerror=l=>{o("Error opening database:",l.target.error),a(l.target.error)}})}async waitReadiness(e=50,t=20){return n(`IndexedDBAdapter - Waiting for database readiness with timeout: ${e}ms, tries: ${t}`),new Promise(async(r,i)=>{let a=0;for(;!this.isReady&&a++<=t;){if(this.isReady)return r(),!0;await(0,ee.default)(e)}if(this.isReady)return r(),!0;i(new Error("Database is not ready"))})}async _withStore(e,t){try{n(`IndexedDBAdapter - Executing operation in ${e} mode`);let a=(await this.dbPromise).transaction(this.storeName,e).objectStore(this.storeName);return await t(a)}catch(r){throw o("Database operation failed:",r),r}}async _loadExpires(){return n("IndexedDBAdapter - Loading expiration timestamps"),this._withStore("readonly",async e=>new Promise(t=>{let r=e.get(this.expireKey);r.onsuccess=()=>{t(r.result?JSON.parse(r.result):{})},r.onerror=()=>{t({})}}))}async get(e){try{n(`IndexedDBAdapter - Getting key: ${e}`);let t=this._fullKey(e),r=await this._withStore("readonly",a=>new Promise(c=>{let l=a.get(t);l.onsuccess=()=>c(l.result),l.onerror=()=>c(null)}));if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return o(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(n(`IndexedDBAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let a=await this._encrypt(e,t);return a?(await this._withStore("readwrite",c=>new Promise(l=>{let h=c.put(a,i);h.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),l(!0)},h.onerror=()=>l(!1)})),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return o(`Error setting key '${e}':`,i),!1}}async delete(e){try{n(`IndexedDBAdapter - Deleting key: ${e}`);let t=this._fullKey(e);await this._withStore("readwrite",i=>new Promise(a=>{let c=i.delete(t);c.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),a(!0)},c.onerror=()=>a()}));let r=await this._loadExpires();delete r[e],await this._withStore("readwrite",i=>new Promise(a=>{let c=i.put(JSON.stringify(r),this.expireKey);c.onsuccess=()=>a(),c.onerror=()=>a()}))}catch(t){o(`Error deleting key '${e}':`,t)}}async list(){let e=[];try{n(`IndexedDBAdapter - Listing keys with prefix: ${this.prefix}`),await this._withStore("readonly",async t=>new Promise(r=>{let i=t.getAllKeys();i.onsuccess=async()=>{let a=i.result||[];for(let c of a)if(this.encrypt&&(c=y(c)),!(c===this.metaKey||c===this.expireKey)&&c.startsWith(this.prefix)){let l=await this.get(c.replace(this.prefix,""));l!==null&&e.push({key:c.replace(this.prefix,""),value:l})}r()},i.onerror=()=>r()}))}catch(t){o("Error listing keys:",t)}return e}async has(e){try{n(`IndexedDBAdapter - Checking existence of key: ${e}`);let t=this._fullKey(e);return await this._withStore("readonly",r=>new Promise(i=>{let a=r.getKey(t);a.onsuccess=()=>i(a.result!==void 0),a.onerror=()=>i(!1)}))}catch(t){return o(`Error checking key '${e}':`,t),!1}}async clear(){try{n("IndexedDBAdapter - Clearing all data"),await this.reset(),await this._withStore("readwrite",e=>new Promise(t=>{let r=e.delete(this.metaKey);r.onsuccess=()=>{let i=e.delete(this.expireKey);i.onsuccess=()=>t(),i.onerror=()=>t()},r.onerror=()=>t()}))}catch(e){o("Error clearing storage:",e)}}async reset(){try{n("IndexedDBAdapter - Resetting storage"),await this._withStore("readwrite",async e=>new Promise(t=>{let r=e.getAllKeys();r.onsuccess=()=>{let i=r.result||[];if(i.length===0){t();return}let a=0,c=l=>()=>{++a===i.length&&(this.enableSyncTabs&&this.emitDataChange(l.replace(this.prefix,""),"reset"),t())};for(let l of i){let h=e.delete(l);h.onsuccess=c(l),h.onerror=c(l)}},r.onerror=()=>t()}))}catch(e){o("Error resetting storage:",e)}}async setExpire(e,t){try{n(`IndexedDBAdapter - Setting expire for key: ${e}, timestamp: ${t}`);let r=await this._loadExpires();r[e]=t,await this._withStore("readwrite",i=>new Promise(a=>{let c=i.put(JSON.stringify(r),this.expireKey);c.onsuccess=()=>a(),c.onerror=()=>a()}))}catch(r){o(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{n(`IndexedDBAdapter - Deleting expire for key: ${e}`);let t=await this._loadExpires();delete t[e],await this._withStore("readwrite",r=>new Promise(i=>{let a=r.put(JSON.stringify(t),this.expireKey);a.onsuccess=()=>i(),a.onerror=()=>i()}))}catch(t){o(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{n("IndexedDBAdapter - Clearing expired keys");let e=Date.now(),t=await this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);if(r){let i=await this._loadExpires();await this._withStore("readwrite",a=>new Promise(c=>{let l=a.put(JSON.stringify(i),this.expireKey);l.onsuccess=()=>c(),l.onerror=()=>c()}))}}catch(e){o("Error clearing expired keys:",e)}}},_=B;var re=f(require("misc-helpers/src/utils/generateSimpleId.js"),1);var G=class extends S{constructor({dbName:e,version:t=1,encrypt:r=!1,expireCheckInterval:i=1e3,description:a="",channelName:c=!1,enableSyncTabs:l=!1}){if(super(c),typeof localStorage>"u")throw o("LocalStorage is not available in this environment"),new Error("LocalStorage is not available in this environment");this.dbName=e,this.encrypt=r,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=(0,re.default)(e),this.expireCheckInterval=i,this.enableSyncTabs=l||!1,this._initMeta({dbName:e,version:t,description:a}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),n(`LocalStorageAdapter -  initialized with dbName: ${e}, version: ${t}, encrypt: ${r}, description: ${a}`)}_initMeta({dbName:e,version:t,description:r}){try{n("LocalStorageAdapter - Initializing metadata for LocalStorageAdapter");let i={dbName:e,version:t,description:r,createdAt:Date.now()};localStorage.setItem(this.metaKey,JSON.stringify(i))}catch(i){o("Error initializing meta:",i)}}_loadExpires(){try{n("LocalStorageAdapter - Loading expiration metadata");let e=localStorage.getItem(this.expireKey);return e?JSON.parse(e):{}}catch(e){return o("Error loading expires:",e),{}}}async get(e){try{n(`LocalStorageAdapter - Getting key: ${e}`);let t=this._fullKey(e),r=localStorage.getItem(t);if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return o(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(n(`LocalStorageAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let a=await this._encrypt(e,t);return a?(localStorage.setItem(i,a),this.enableSyncTabs&&this.emitDataChange(e,void 0,"set"),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return o(`Error setting key '${e}':`,i),!1}}async delete(e){try{n(`LocalStorageAdapter - Deleting key: ${e}`);let t=this._fullKey(e);localStorage.removeItem(t);let r=this._loadExpires();delete r[e],localStorage.setItem(this.expireKey,JSON.stringify(r)),this.enableSyncTabs&&this.emitDataChange(e,void 0,"delete")}catch(t){o(`Error deleting key '${e}':`,t)}}async list(){let e=[];n(`LocalStorageAdapter - Listing keys with prefix: ${this.prefix}`);try{for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);if(this.encrypt&&(r=y(r)),!(r===this.metaKey||r===this.expireKey)&&r.startsWith(this.prefix)){let i=await this.get(r.replace(this.prefix,""));i!==null&&e.push({key:r.replace(this.prefix,""),value:i})}}}catch(t){throw o("Error listing keys:",t),t}return e}async has(e){try{n(`LocalStorageAdapter - Checking existence of key: ${e}`);let t=this._fullKey(e);return localStorage.getItem(t)!==null}catch(t){return o(`Error checking key '${e}':`,t),!1}}async clear(){try{n("LocalStorageAdapter - Clearing all data"),await this.reset(),localStorage.removeItem(this.metaKey),localStorage.removeItem(this.expireKey)}catch(e){o("Error clearing storage:",e)}}async reset(){try{n("LocalStorageAdapter - Resetting storage");let e=[];for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);r.startsWith(this.prefix)&&e.push(r)}for(let t of e)localStorage.removeItem(t),this.enableSyncTabs&&this.emitDataChange(t.replace(this.prefix,""),void 0,"reset")}catch(e){o("Error resetting storage:",e)}}async setExpire(e,t){try{n(`LocalStorageAdapter - Setting expiration for key: ${e}`,{timestamp:t});let r=this._loadExpires();r[e]=t,localStorage.setItem(this.expireKey,JSON.stringify(r))}catch(r){o(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{n(`LocalStorageAdapter - Deleting expiration for key: ${e}`);let t=this._loadExpires();delete t[e],localStorage.setItem(this.expireKey,JSON.stringify(t))}catch(t){o(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{n("LocalStorageAdapter - Clearing expired keys");let e=Date.now(),t=this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);r&&localStorage.setItem(this.expireKey,JSON.stringify(this._loadExpires()))}catch(e){o("Error clearing expired keys:",e)}}},A=G;var ie=f(require("misc-helpers/src/utils/generateSimpleId.js"),1);var q=class extends S{constructor({dbName:e,version:t=1,encrypt:r=!1,expireCheckInterval:i=1e3,channelName:a=!1,description:c="",enableSyncTabs:l=!1}){if(super(a),typeof sessionStorage>"u")throw o("SessionStorage is not available in this environment"),new Error("SessionStorage is not available in this environment");this.dbName=e,this.encrypt=r,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=(0,ie.default)(e),this.expireCheckInterval=i,this.enableSyncTabs=l||!1,this._initMeta({dbName:e,version:t,description:c}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),n(`SessionStorageAdapter - initialized with prefix: ${this.prefix}, encrypt: ${this.encrypt}`)}_initMeta({dbName:e,version:t,description:r}){try{n(`SessionStorageAdapter - Initializing metadata for ${e} v${t}`);let i={dbName:e,version:t,description:r,createdAt:Date.now()};sessionStorage.setItem(this.metaKey,JSON.stringify(i))}catch(i){o("Error initializing meta:",i)}}_loadExpires(){try{n("SessionStorageAdapter - Loading expiration map");let e=sessionStorage.getItem(this.expireKey);return e?JSON.parse(e):{}}catch(e){return o("Error loading expires:",e),{}}}async get(e){try{n(`SessionStorageAdapter - Getting key '${e}'`);let t=this._fullKey(e),r=sessionStorage.getItem(t);if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return o(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(n(`SessionStorageAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let a=await this._encrypt(e,t);return a?(sessionStorage.setItem(i,a),this.enableSyncTabs&&this.emitDataChange(e,a,"set"),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return o(`Error setting key '${e}':`,i),!1}}async delete(e){try{n(`SessionStorageAdapter - Deleting key '${e}'`);let t=this._fullKey(e);sessionStorage.removeItem(t);let r=this._loadExpires();delete r[e],sessionStorage.setItem(this.expireKey,JSON.stringify(r)),this.enableSyncTabs&&this.emitDataChange(e,void 0,"delete")}catch(t){o(`Error deleting key '${e}':`,t)}}async list(){let e=[];try{n(`SessionStorageAdapter - Listing keys with prefix '${this.prefix}'`);for(let t=0;t<sessionStorage.length;t++){let r=sessionStorage.key(t);if(this.encrypt&&(r=y(r)),!(r===this.metaKey||r===this.expireKey)&&r.startsWith(this.prefix)){let i=await this.get(r.replace(this.prefix,""));i!==null&&e.push({key:r.replace(this.prefix,""),value:i})}}}catch(t){throw o("Error listing keys:",t),t}return e}async has(e){try{n(`SessionStorageAdapter - Checking existence of key '${e}'`);let t=this._fullKey(e);return sessionStorage.getItem(t)!==null}catch(t){return o(`Error checking key '${e}':`,t),!1}}async clear(){try{n("SessionStorageAdapter - Clearing all data"),await this.reset(),sessionStorage.removeItem(this.metaKey),sessionStorage.removeItem(this.expireKey)}catch(e){o("Error clearing storage:",e)}}async reset(){try{n("SessionStorageAdapter - Resetting storage");let e=[];for(let t=0;t<sessionStorage.length;t++){let r=sessionStorage.key(t);r.startsWith(this.prefix)&&e.push(r)}for(let t of e)sessionStorage.removeItem(t),this.enableSyncTabs&&this.emitDataChange(t.replace(this.prefix,""),void 0,"reset")}catch(e){o("Error resetting storage:",e)}}async setExpire(e,t){try{n(`SessionStorageAdapter - Setting expire for key '${e}'`);let r=this._loadExpires();r[e]=t,sessionStorage.setItem(this.expireKey,JSON.stringify(r))}catch(r){o(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{n(`SessionStorageAdapter - Deleting expire for key '${e}'`);let t=this._loadExpires();delete t[e],sessionStorage.setItem(this.expireKey,JSON.stringify(t))}catch(t){o(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{n("SessionStorageAdapter - Clearing expired keys");let e=Date.now(),t=this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);r&&sessionStorage.setItem(this.expireKey,JSON.stringify(this._loadExpires()))}catch(e){o("Error clearing expired keys:",e)}}},D=q;var W=class{async setInStorage(e,t,r={}){throw new Error("Not implemented")}async getFromStorage(e,t,r){throw new Error("Not implemented")}destroy(e){if(this.stores&&this.stores[e]&&typeof this.stores[e].unsubscribe=="function"){n("StoreAdapter - destroy - Unsubscribing from store changes."),this.stores[e].unsubscribe,delete this.stores[e];return}n("StoreAdapter - destroy - No unsubscribe function to call.")}},w=W;var se=f(require("misc-helpers/src/utils/assign.js"),1);var U=class extends w{constructor(e){if(super(),!e)throw o("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this.stores={}}_checkStore(e){if(!e||!e.$subscribe||!e.$patch)throw o("Store provided is not defined"),new Error("Store provided is not defined")}_registerOnDataChanged(e){n("PiniaAdapter - Registering onDataChanged listener"),!(!e||!this.stores||!this.stores[e])&&this.adapter.onDataChanged(async t=>{try{if(t.adapterId==this.adapter.adapterId||!t.origin||!this.stores||!this.stores[t.key]||!this.stores[t.key].store)return;let r;if(t.value?r=await this.adapter._decrypt(t.key,t.value):r=await this.adapter.get(t.key),JSON.stringify(!this.stores[t.key].store.$state)===JSON.stringify(r))return;this.stores[t.key].store.$state={...this.stores[t.key].store.$state,...r,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}}catch(r){o("PiniaAdapter - onDataChanged - error:",r)}})}async setInStorage(e,t,r={}){try{return n("PiniaAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this.stores[t]&&this.stores[t].unsubscribe&&typeof this.stores[t].unsubscribe=="function"&&this.stores[t].unsubscribe(),delete this.stores[t],this.stores[t]={key:t,options:r,store:e,unsubscribe:null},new Promise((i,a)=>{this.stores[t].unsubscribe=e.$subscribe(async(c,l)=>{try{if(!l)return i(!0);if(l.STORAGEFY_SILENT_CHANNEL_UPDATE)return delete l.STORAGEFY_SILENT_CHANNEL_UPDATE,i(!0);let h={...l};for(let u in h)r.ignoreKeys.includes(u)&&(h[u]=void 0);return await this.adapter.set(t,h,r.timeout),i(!0)}catch(h){return a(h)}}),e.$patch({...e.$state}),r.syncTabs&&this._registerOnDataChanged(t)})}catch(i){throw o(i),i}}async getFromStorage(e,t){try{n("PiniaAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);return r?(e.$patch((0,se.default)({},r)),!0):void 0}catch(r){throw o(r),r}}},T=U;var ne=f(require("misc-helpers/src/utils/assign.js"),1);var z=class extends w{constructor(e){if(super(),!e)throw o("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this.stores={}}_getPayload(e,t){return{...e,...t,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}}_registerOnDataChanged(e){!e||!this.stores||!this.stores[e]||(n("ReactAdapter - Registering onDataChanged listener"),this.adapter.onDataChanged(async t=>{try{if(t.adapterId==this.adapter.adapterId||!t.origin||!this.stores||!this.stores[t.key]||!this.stores[t.key].store)return;let r=this.stores[t.key].store,i;if(t.value?i=await this.adapter._decrypt(t.key,t.value):i=await this.adapter.get(t.key),typeof r.dispatch=="function"&&typeof r.getState=="function"){let c=r.getState();if(JSON.stringify(c)===JSON.stringify(i))return;r.dispatch({type:"STORAGEFY_UPDATE",payload:this._getPayload(c,i)});return}if(typeof r.getState=="function"&&typeof r.setState=="function"){let c=r.getState();if(JSON.stringify(c)===JSON.stringify(i))return;r.setState(this._getPayload(c,i));return}if(typeof r.set=="function"&&typeof r.get=="function"){let c=r.get();if(JSON.stringify(c)===JSON.stringify(i))return;r.set(this._getPayload(c,i));return}if(typeof r.update=="function"){r.update(c=>JSON.stringify(c)===JSON.stringify(i)?c:this._getPayload(c,i));return}let a=typeof r.getState=="function"?r.getState():typeof r.get=="function"?r.get():{};if(JSON.stringify(a)===JSON.stringify(i))return;typeof r.set=="function"?r.set(this._getPayload(a,i)):o("Unable to update store: No compatible update method found")}catch(r){o("Error in _registerOnDataChanged:",r)}}))}async setInStorage(e,t,r={}){try{return n("ReactAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this.stores[t]&&this.stores[t].unsubscribe&&typeof this.stores[t].unsubscribe=="function"&&this.stores[t].unsubscribe(),delete this.stores[t],this.stores[t]={key:t,options:r,store:e,unsubscribe:null},new Promise((i,a)=>{let c=async l=>{try{if(!l)return;if(l.STORAGEFY_SILENT_CHANNEL_UPDATE)return delete l.STORAGEFY_SILENT_CHANNEL_UPDATE,i(!0);let h={...l};for(let u in h)r.ignoreKeys.includes(u)&&(h[u]=void 0);await this.adapter.set(t,h,r.timeout)}catch(h){o(h)}};if(typeof e.subscribe=="function"&&typeof e.getState=="function")c(e.getState()),this.stores[t].unsubscribe=e.subscribe(()=>{c(e.getState())});else if(typeof e.subscribe=="function")this.stores[t].unsubscribe=e.subscribe(c);else{a(new Error("Unsupported store type"));return}r.syncTabs&&this._registerOnDataChanged(t),i(!0)})}catch(i){throw o(i),i}}async getFromStorage(e,t){try{n("ReactAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);if(!r)return;if(typeof e.dispatch=="function")e.dispatch({type:"SET_STATE_FROM_STORAGE",payload:r});else if(typeof e.setState=="function")e.setState((0,ne.default)({},r));else throw new Error("Cannot update store: setState or dispatch method not found");return!0}catch(r){throw o(r),r}}_checkStore(e){if(!e)throw o("Store provided is not defined"),new Error("Store provided is not defined");if(typeof e.getState=="function"&&typeof e.dispatch=="function"&&typeof e.subscribe=="function"||typeof e.getState=="function"&&typeof e.setState=="function"&&typeof e.subscribe=="function"||Array.isArray(e)&&e.length===2&&typeof e[0]=="function"&&typeof e[1]=="function")return;let t=typeof e.getState=="function"||typeof e._getState=="function",r=typeof e.setState=="function"||typeof e._setState=="function";if(!(typeof e.subscribe=="function"))throw o("Store must have a subscribe method"),new Error("Store must have a subscribe method");if(!t&&!r)throw o("Store must have either getState/setState or _getState/_setState methods"),new Error("Store must have either getState/setState or _getState/_setState methods")}},N=z;var k=f(require("misc-helpers/src/utils/assign.js"),1);var M=class extends w{constructor(e){if(super(),!e)throw o("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this.stores={}}_registerOnDataChanged(e){if(n("SvelteAdapter - Registering onDataChanged listener"),!(!e||!this.stores||!this.stores[e]))try{if(!store)return;this.adapter.onDataChanged(async t=>{if(t.adapterId==this.adapter.adapterId||!t.origin||!this.stores||!this.stores[t.key]||!this.stores[t.key].store)return;let r;this.stores[t.key].store.subscribe(c=>{r=(0,k.default)({},c)})();let a;t.value?a=await this.adapter._decrypt(t.key,t.value):a=await this.adapter.get(t.key),JSON.stringify(r)!==JSON.stringify(a)&&this.stores[t.key].store.update(c=>({...c,...a,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}))})}catch(t){throw o("SvelteAdapter - onDataChanged error:",t),t}}async setInStorage(e,t,r={}){try{return n("SvelteAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this.stores[t]&&this.stores[t].unsubscribe&&typeof this.stores[t].unsubscribe=="function"&&this.stores[t].unsubscribe(),delete this.stores[t],this.stores[t]={key:t,options:r,store:e,unsubscribe:null},new Promise((i,a)=>{this.stores[t].unsubscribe=e.subscribe(async c=>{try{if(!c)return i(!0);let l={...c};for(let h in l)r.ignoreKeys.includes(h)&&(l[h]=void 0);return await this.adapter.set(t,l,r.timeout),i(!0)}catch(l){return a(l)}}),r.syncTabs&&this._registerOnDataChanged(t)})}catch(i){throw o(i),i}}async getFromStorage(e,t){try{n("SvelteAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);return r?(e.set((0,k.default)({},r)),!0):void 0}catch(r){throw o(r),r}}_checkStore(e){if(!e||typeof e.subscribe!="function"||typeof e.set!="function")throw o("Store provided is not a valid Svelte writable store"),new Error("Store provided is not a valid Svelte writable store")}},O=M;var xe={dbName:"storagefy",storeName:"storagefy_db",version:1,encrypt:!1,expireCheckInterval:1e3,description:"Storagefy database",adapter:"indexedDB"},d,p,m,x;function Ee(s={}){let e={...xe,...s};if(!s.forceRecreate&&d)return d;switch(e.adapter){case"localStorage":if(s.fresh)return new A(e);d=new A(e);break;case"sessionStorage":if(s.fresh)return new D(e);d=new D(e);break;default:if(s.fresh)return new _(e);d=new _(e)}return d}function be(){if(!d)throw new Error("Storage adapter not initialized. Call startStoragefy first.");return d}function E({adapter:s,adapterParams:e,forceRecreate:t},r,i){if(s)return new i(s);if(r&&!t)return r;if(e){let a=_e(e);return new i(a)}if(!d)throw new Error("Storage adapter not initialized. Call startStoragefy first.");return new i(d)}function _e(s){switch(s.adapter){case"localStorage":return new A(s);case"sessionStorage":return new D(s);default:return new _(s)}}function oe({adapter:s=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?E({adapter:s,adapterParams:e,forceRecreate:t},null,T):(p=E({adapter:s,adapterParams:e,forceRecreate:t},p,T),{setInStorage:p.setInStorage.bind(p),getFromStorage:p.getFromStorage.bind(p)})}function ae({adapter:s=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?E({adapter:s,adapterParams:e,forceRecreate:t},null,N):(m=E({adapter:s,adapterParams:e,forceRecreate:t},m,N),m)}function ce({adapter:s=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?E({adapter:s,adapterParams:e,forceRecreate:t},null,O):(x=E({adapter:s,adapterParams:e,forceRecreate:t},x,O),x)}async function Ae(s,e,t={}){try{if(p||oe(),!s)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await p.getFromStorage(s,e),await p.setInStorage(s,e,t)}catch(r){throw logError(r),r}}async function De(s,e,t={}){try{if(m||ae(),!s)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await m.getFromStorage(s,e),await m.setInStorage(s,e,t)}catch(r){throw logError(r),r}}async function Ie(s,e,t={}){try{if(x||ce(),!s)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await x.getFromStorage(s,e),await x.setInStorage(s,e,t)}catch(r){throw logError(r),r}}0&&(module.exports={IndexedDBAdapter,LocalStorageAdapter,PiniaAdapter,ReactAdapter,SessionStorageAdapter,SvelteAdapter,getPiniaAdapter,getReactAdapter,getStorageAdapter,getSvelteAdapter,setPiniaStorage,setReactStorage,setSvelteStorage,startStoragefy});
//# sourceMappingURL=index.cjs.map