{"version":3,"sources":["../src/helpers/loggerHelper.js","../src/helpers/cryptoHelper.js","../src/helpers/CrossTabChannel.js","../src/adapters/StorageAdapter.js","../src/adapters/IndexedDBAdapter.js","../src/adapters/LocalStorageAdapter.js","../src/adapters/SessionStorageAdapter.js","../src/stores/StoreAdapter.js","../src/stores/PiniaAdapter.js","../src/stores/ReactAdapter.js","../src/stores/SvelteAdapter.js","../src/index.js"],"sourcesContent":["/**\n * Global debug flag.\n * Set to `true` to enable logging.\n * @type {boolean}\n */\nglobalThis.storagefyDebug = false;\n\n/**\n * Global debug level.\n * Controls the verbosity of logs.\n * \n * Levels:\n * - 0: Only errors\n * - 1: Warnings\n * - 2: Info\n * - 3: Trace\n * \n * @type {number}\n */\nglobalThis.storagefyDebugLevel = 0;\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Logs an error message if `storagefyDebug` is enabled.\n * \n * @param {...any} args - Arguments to log.\n */\nexport const logError = (...args) => {\n  if (globalThis.storagefyDebug && globalThis.storagefyDebugLevel >= 0) {\n    args.unshift(\"Storagefy Error:\");\n    console.error(...args);\n  }\n};\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Logs a warning message if `storagefyDebug` is enabled and level is >= 1.\n * \n * @param {...any} args - Arguments to log.\n */\nexport const logWarn = (...args) => {\n  if (globalThis.storagefyDebug && globalThis.storagefyDebugLevel >= 1) {\n    args.unshift(\"Storagefy Warn:\");\n    console.warn(...args);\n  }\n};\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Logs an info message if `storagefyDebug` is enabled and level is >= 2.\n * \n * @param {...any} args - Arguments to log.\n */\nexport const logInfo = (...args) => {\n  if (globalThis.storagefyDebug && globalThis.storagefyDebugLevel >= 2) {\n    args.unshift(\"Storagefy:\");\n    console.info(...args);\n  }\n};\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Logs a trace message if `storagefyDebug` is enabled and level is >= 3.\n * \n * @param {...any} args - Arguments to log.\n */\nexport const logTrace = (...args) => {\n  if (globalThis.storagefyDebug && globalThis.storagefyDebugLevel >= 3) {\n    args.unshift(\"Storagefy:\");\n    console.trace(...args);\n  }\n};\n\n// ------------------------------------------------------------------------------------------------\n","import { logError, logWarn, logInfo } from \"./loggerHelper.js\";\nimport base64To from \"misc-helpers/src/utils/base64To.js\";\nimport base64From from \"misc-helpers/src/utils/base64From.js\";\n\n// ------------------------------------------------------------------------------------------------\n\nconst ENCODER = new TextEncoder();\nconst DECODER = new TextDecoder();\n\n// ------------------------------------------------------------------------------------------------\n\nlet crypto;\nlet subtle;\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Initializes the Web Crypto API depending on environment (Browser or Node).\n */\nfunction getCrypto() {\n  try {\n    logInfo(\"CryptoHelper - Attempting to initialize crypto engine\");\n\n    if (typeof window !== \"undefined\" && window.crypto) {\n      crypto = window.crypto;\n      subtle = crypto.subtle;\n      logInfo(\"CryptoHelper - Crypto initialized from window.crypto\");\n      return;\n    }\n\n    if (typeof global !== \"undefined\") {\n      if (global.crypto?.webcrypto) {\n        crypto = global.crypto.webcrypto;\n        subtle = crypto.subtle;\n        logInfo(\"CryptoHelper - Crypto initialized from global.webcrypto\");\n        return;\n      }\n    }\n\n    throw new Error(\"Crypto API not available\");\n  } catch (error) {\n    logError(\"Failed to initialize crypto:\", error);\n    throw error;\n  }\n}\n\ntry {\n  getCrypto();\n} catch (error) {\n  logError(\"Failed to initialize crypto:\", error);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Creates a key material from a password to be used in key derivation.\n * @private\n * @param {string} password - The password to convert.\n * @returns {Promise<CryptoKey>} A CryptoKey representing the key material.\n */\nconst generateKeyMaterial = async (password) => {\n  try {\n    logInfo(\"CryptoHelper - Generating key material from password\");\n    return subtle.importKey(\"raw\", ENCODER.encode(password), \"PBKDF2\", false, [\n      \"deriveKey\",\n    ]);\n  } catch (error) {\n    logError(\"Error generating key material:\", error);\n    throw error;\n  }\n};\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Derives a cryptographic key using PBKDF2 from a password and salt.\n * @param {string} password - The password.\n * @param {string} salt - The salt.\n * @param {boolean} [extractable=false] - Whether the derived key is extractable.\n * @returns {Promise<CryptoKey>} The derived key.\n */\nexport const deriveKey = async (password, salt, extractable = false) => {\n  try {\n    if (typeof password !== \"string\" || !password.length) {\n      throw new Error(\"Invalid password\");\n    }\n    logInfo(\"CryptoHelper - Deriving key with PBKDF2\", {\n      passwordLength: password.length,\n      extractable,\n    });\n    const keyMaterial = await generateKeyMaterial(password);\n    return subtle.deriveKey(\n      {\n        name: \"PBKDF2\",\n        salt: ENCODER.encode(salt),\n        iterations: 100000,\n        hash: \"SHA-256\",\n      },\n      keyMaterial,\n      { name: \"AES-GCM\", length: 256 },\n      extractable,\n      [\"encrypt\", \"decrypt\"]\n    );\n  } catch (error) {\n    logError(\"Error deriving key:\", error);\n    throw error;\n  }\n};\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Encrypts a JavaScript object using AES-GCM.\n * @param {CryptoKey} key - The AES key.\n * @param {any} dataObj - The data to encrypt.\n * @param {boolean} [raw=false] - If true, returns raw bytes.\n * @returns {Promise<Object>} The encrypted data (base64 or raw format).\n */\nexport const encryptData = async (key, dataObj, raw = false) => {\n  if (\n    dataObj === undefined ||\n    typeof dataObj === \"function\" ||\n    typeof dataObj === \"symbol\"\n  ) {\n    throw new Error(\"Invalid data type for encryption\");\n  }\n\n  try {\n    logInfo(\"CryptoHelper - Encrypting data\", { raw });\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoded = ENCODER.encode(JSON.stringify(dataObj));\n    const encrypted = await subtle.encrypt(\n      { name: \"AES-GCM\", iv },\n      key,\n      encoded\n    );\n\n    if (raw) {\n      return { iv, data: new Uint8Array(encrypted) };\n    }\n\n    const ivBase64 = base64To(String.fromCharCode(...iv));\n    const encryptedBase64 = base64To(\n      String.fromCharCode(...new Uint8Array(encrypted))\n    );\n\n    return { iv: ivBase64, data: encryptedBase64 };\n  } catch (error) {\n    logError(\"Error encrypting data:\", error);\n    throw error;\n  }\n};\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Decrypts encrypted data using AES-GCM.\n * @param {CryptoKey} key - The AES key.\n * @param {Object} encryptedObj - Encrypted data.\n * @param {boolean} [raw=false] - Whether the encrypted data is in raw format.\n * @returns {Promise<any>} The decrypted original data.\n */\nexport const decryptData = async (key, encryptedObj, raw = false) => {\n  let iv, encrypted;\n\n  try {\n    logInfo(\"CryptoHelper - Decrypting data\", { raw });\n\n    if (raw) {\n      iv = new Uint8Array(encryptedObj.iv);\n      encrypted = new Uint8Array(encryptedObj.data);\n    } else {\n      const decodeBase64 = (b64) =>\n        new Uint8Array(\n          base64From(b64)\n            .split(\"\")\n            .map((char) => char.charCodeAt(0))\n        );\n      iv = decodeBase64(encryptedObj.iv);\n      encrypted = decodeBase64(encryptedObj.data);\n    }\n\n    const decrypted = await subtle.decrypt(\n      { name: \"AES-GCM\", iv },\n      key,\n      encrypted\n    );\n\n    return JSON.parse(DECODER.decode(decrypted));\n  } catch (error) {\n    logError(\"Error decrypting data:\", error);\n    throw error;\n  }\n};\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Encrypts (obfuscates) a string key using a simple transformation.\n * This is not a secure encryption method and is intended only for light obfuscation\n * (e.g., hiding keys in client-side storage from plain sight).\n *\n * Internally uses `simpleObfuscate()` to perform a base64 + character shift.\n *\n * @param {string} key - The key to obfuscate.\n * @returns {string} The obfuscated key.\n * @throws {Error} If obfuscation fails.\n */\nexport function encryptKey(key) {\n  try {\n    if (!key) {\n      return key;\n    }\n\n    // Light obfuscation using character shifting + base64\n    return this.simpleObfuscate(key);\n  } catch (error) {\n    logError(\"Error in encryptKey:\", error);\n    throw error;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Applies a simple obfuscation to a string:\n * 1. Shifts each character code by +1.\n * 2. Converts the result to base64 format using `base64To()`.\n *\n * This is useful for making strings less readable, though not secure.\n *\n * @param {string} str - The input string to obfuscate.\n * @returns {string} The obfuscated string.\n * @throws {Error} If the obfuscation process fails.\n */\nexport function simpleObfuscate(str) {\n  if (!str) return str;\n\n  logInfo(\"CryptoHelper - Obfuscating string\");\n\n  try {\n    // Shift each character's char code by +1\n    const shifted = [...str]\n      .map((char) => String.fromCharCode(char.charCodeAt(0) + 1))\n      .join(\"\");\n\n    // Convert to base64\n    return base64To(shifted);\n  } catch (error) {\n    return str;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Reverses a previously obfuscated string:\n * 1. Decodes from base64 using `base64From()`.\n * 2. Shifts each character code by -1 to restore the original.\n *\n * @param {string} str - The obfuscated string to restore.\n * @returns {string} The original (deobfuscated) string.\n * @throws {Error} If the deobfuscation process fails.\n */\nexport function simpleDeobfuscate(str) {\n  if (!str) return str;\n\n  logInfo(\"CryptoHelper - Deobfuscating string\");\n\n  try {\n    // Decode base64\n    const decoded = base64From(str);\n\n    // Shift each character's char code back by -1\n    return [...decoded]\n      .map((char) => String.fromCharCode(char.charCodeAt(0) - 1))\n      .join(\"\");\n  } catch (error) {\n    return str;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n","import { logError, logWarn, logInfo } from \"./loggerHelper.js\";\nimport generateSimpleId from \"misc-helpers/src/utils/generateSimpleId.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * @class CrossTabChannel\n * A lightweight wrapper around the BroadcastChannel API for sending and receiving messages\n * between browser tabs or contexts under the same origin.\n *\n * This class provides a simple interface to emit data and subscribe to data changes\n * across tabs, making it ideal for syncing state in multi-tab applications.\n */\nclass CrossTabChannel {\n  /**\n   * Constructs a new CrossTabChannel instance using the specified channel name.\n   *\n   * @param {string} [channelName='storagefy_channel'] - The name of the BroadcastChannel.\n   *                                                     Tabs sharing this name can communicate with each other.\n   */\n  constructor(channelName) {\n    // Initialize the BroadcastChannel with the given name.\n    try {\n      if (typeof channelName !== \"string\") {\n        channelName = generateSimpleId(\"storagefy_channel\");\n      }\n      this.channel = new BroadcastChannel(channelName);\n      this.channelName = channelName;\n      logInfo(`CrossTabChannel initialized on channel \"${channelName}\"`);\n    } catch (error) {\n      logError(\"Failed to initialize BroadcastChannel:\", error);\n      throw error;\n    }\n  }\n\n  // ------------------------------------------------------------------------------------------------\n\n  /**\n   * Subscribes to incoming messages on the channel.\n   * The callback will be called with the message data whenever another tab posts a message.\n   *\n   * @param {Function} callback - A function that handles incoming message data.\n   */\n  subscribe(callback) {\n    if (typeof callback !== \"function\") {\n      logWarn(\"CrossTabChannel.subscribe: Provided callback is not a function.\");\n      return;\n    }\n\n    this.channel.onmessage = (event) => {\n      logInfo(\"CrossTabChannel - Received message:\", event.data);\n      try {\n        callback(event.data);\n      } catch (error) {\n        logError(\"Error in CrossTabChannel subscriber callback:\", error);\n      }\n    };\n\n    logInfo(\"CrossTabChannel - Subscribed to incoming messages.\");\n  }\n\n  // ------------------------------------------------------------------------------------------------\n  \n  /**\n   * Sends a message to all tabs subscribed to the same channel.\n   *\n   * @param {*} data - The data to broadcast. Must be serializable.\n   */\n  emit(data) {\n    try {\n      this.channel.postMessage(data);\n      logInfo(\"CrossTabChannel - Emitted message:\", data);\n    } catch (error) {\n      logError(\"CrossTabChannel.emit: Failed to send message:\", error);\n    }\n  }\n\n  // ------------------------------------------------------------------------------------------------\n\n  /**\n   * Closes the channel to stop listening for or sending messages.\n   * This is useful for cleanup when the channel is no longer needed.\n   */\n  close() {\n    try {\n      this.channel.close();\n      logInfo(\"CrossTabChannel - Channel closed.\");\n    } catch (error) {\n      logError(\"CrossTabChannel.close: Error closing channel:\", error);\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default CrossTabChannel;\n\n// ------------------------------------------------------------------------------------------------\n","import * as cryptoHelper from \"../helpers/cryptoHelper.js\";\nimport CrossTabChannel from \"../helpers/CrossTabChannel.js\";\nimport { logInfo, logWarn, logError } from \"../helpers/loggerHelper.js\";\n\n// -------------------------------------------------------------------------------------------------\n\n/**\n * @class StorageAdapter\n * @abstract\n * Base class for implementing storage adapters with optional encryption and expiration.\n *\n * Subclasses must implement core storage methods such as `get`, `set`, `delete`, etc.\n * This class optionally sets up a cross-tab communication channel for broadcasting and\n * receiving data changes across browser tabs or contexts.\n */\nclass StorageAdapter {\n  /**\n   * Constructs a new StorageAdapter instance.\n   *\n   * @param {string} [channelName] - Optional name of the communication channel to enable cross-tab syncing.\n   *                                 If provided, a CrossTabChannel is initialized for emitting and receiving changes.\n   */\n  constructor(channelName) {\n    // If a channel name is provided, initialize the cross-tab channel.\n    if (channelName) {\n      logInfo(\"StorageAdapter - Initializing cross-tab channel:\", channelName);\n      this.channelName = channelName;\n      this.channel = new CrossTabChannel(channelName);\n    } else {\n      // If no channel name is provided, disable cross-tab syncing.\n      this.channel = null;\n      this.channelName = null;\n      logWarn(\n        \"StorageAdapter - No channel name provided, cross-tab syncing disabled.\"\n      );\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Retrieve the value for a given key.\n   * @abstract\n   * @param {string} key - The storage key.\n   * @returns {Promise<any>}\n   * @throws Will throw if not implemented.\n   */\n  async get(key) {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Store a value under a key.\n   * @abstract\n   * @param {string} key - The storage key.\n   * @param {any} value - The value to store.\n   * @param {number} [expire] - Optional expiration in milliseconds from now.\n   * @returns {Promise<void>}\n   * @throws Will throw if not implemented.\n   */\n  async set(key, value, expire) {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Delete a specific key.\n   * @abstract\n   * @param {string} key - The storage key to remove.\n   * @returns {Promise<void>}\n   * @throws Will throw if not implemented.\n   */\n  async delete(key) {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * List all keys with a given prefix.\n   * @abstract\n   * @param {string} [prefix=\"\"] - Prefix to filter keys.\n   * @returns {Promise<string[]>}\n   * @throws Will throw if not implemented.\n   */\n  async list(prefix = \"\") {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Reset the entire adapter (e.g., delete all tables, indexes, etc.).\n   * @abstract\n   * @returns {Promise<void>}\n   * @throws Will throw if not implemented.\n   */\n  async reset() {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Clear all stored values.\n   * @abstract\n   * @returns {Promise<void>}\n   * @throws Will throw if not implemented.\n   */\n  async clear() {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Remove all expired keys.\n   * @abstract\n   * @returns {Promise<void>}\n   * @throws Will throw if not implemented.\n   */\n  async clearExpire() {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Set an expiration time (in ms) for a given key.\n   * @abstract\n   * @param {string} key - Key to expire.\n   * @param {number} time - Expiration timestamp in ms.\n   * @returns {Promise<void>}\n   * @throws Will throw if not implemented.\n   */\n  async setExpire(key, time) {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Remove expiration for a specific key.\n   * @abstract\n   * @param {string} key - Key to remove expiration from.\n   * @returns {Promise<void>}\n   * @throws Will throw if not implemented.\n   */\n  async deleteExpire(key) {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Check if a key exists.\n   * @abstract\n   * @param {string} key - Key to check.\n   * @returns {Promise<boolean>}\n   * @throws Will throw if not implemented.\n   */\n  async has(key) {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Encrypt a value\n   * @protected\n   * @param {any} value - Value to encrypt.\n   * @returns {Promise<string|null>} - Encrypted JSON string or null on failure.\n   */\n  async _encrypt(key, value) {\n    if (!this.encrypt || !key) return value;\n    try {\n      const cKey = await cryptoHelper.deriveKey(key);\n      const encrypted = await cryptoHelper.encryptData(cKey, value, false);\n      logInfo(\n        `StorageAdapter - Successfully encrypted value for key \"${key}\".`\n      );\n      return JSON.stringify(encrypted);\n    } catch (err) {\n      logError(\"Encryption failed:\", err);\n      return null;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Decrypt a previously encrypted value.\n   * @protected\n   * @param {string} value - Encrypted stringified data.\n   * @returns {Promise<any|null>} - Decrypted object or null on failure.\n   */\n  async _decrypt(key, value) {\n    if (!this.encrypt || !key) return JSON.parse(value);\n    try {\n      const cKey = await cryptoHelper.deriveKey(key);\n      const encryptedObj = JSON.parse(value);\n      const decrypted = await cryptoHelper.decryptData(\n        cKey,\n        encryptedObj,\n        false\n      );\n      logInfo(\n        `StorageAdapter - Successfully decrypted value for key \"${key}\".`\n      );\n      return JSON.parse(decrypted);\n    } catch (err) {\n      logError(\"Decryption failed:\", err);\n      return null;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Generate the full namespaced key.\n   * @protected\n   * @param {string} key - The base key.\n   * @returns {string} - The namespaced key.\n   */\n  _fullKey(key) {\n    const full = `${this.prefix}${key}`;\n    if (this.encrypt) {\n      const obfuscated = cryptoHelper.simpleObfuscate(full);\n      logInfo(`StorageAdapter - Obfuscated key \"${key}\" to \"${obfuscated}\".`);\n      return obfuscated;\n    }\n    logInfo(`StorageAdapter - Using plain key: \"${full}\"`);\n    return full;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Starts the expiration watcher to periodically clear expired keys.\n   * @protected\n   */\n  _startExpireWatcher() {\n    if (this._expireTimer) clearInterval(this._expireTimer);\n    if (this.expireCheckInterval <= 0) {\n      return;\n    }\n    this._expireTimer = setInterval(() => {\n      try {\n        logInfo(\"StorageAdapter - Running expiration cleanup...\");\n        this.clearExpire();\n      } catch (err) {\n        logError(\"Error clearing expired keys:\", err);\n      }\n    }, this.expireCheckInterval);\n    logInfo(\n      `StorageAdapter - Expire watcher started, interval: ${this.expireCheckInterval}ms`\n    );\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Cleans up timers and listeners.\n   */\n  destroy() {\n    if (this._expireTimer) {\n      clearInterval(this._expireTimer);\n      this._expireTimer = null;\n      logInfo(\"StorageAdapter - Expire watcher stopped.\");\n    }\n\n    if (this._unloadHandler) {\n      window.removeEventListener(\"beforeunload\", this._unloadHandler);\n      this._unloadHandler = null;\n      logInfo(\"StorageAdapter - Removed unload handler.\");\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * List all keys under a specific table prefix.\n   * @param {string} tableName - Table prefix.\n   * @returns {Promise<string[]>} - List of keys.\n   */\n  async getAll(tableName) {\n    logInfo(`StorageAdapter - Getting all keys under table: \"${tableName}\"`);\n    return this.list(`${tableName}__`);\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Get the expiration timestamp for a key.\n   * @param {string} key - Key to check.\n   * @returns {Promise<number|null>} - Expiration timestamp or null.\n   */\n  async getExpire(key) {\n    try {\n      const expires = await this._loadExpires();\n      logInfo(\n        `StorageAdapter - Getting expiration for key \"${key}\":`,\n        expires[key] || null\n      );\n      return expires[key] || null;\n    } catch (err) {\n      logError(`Error getting expire for key '${key}':`, err);\n      return null;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Emits a data change event through the communication channel,\n   * typically used to notify other tabs, windows, or contexts that\n   * a value has been updated.\n   *\n   * @param {string} key - The key of the updated data.\n   * @param {*} value - The new value associated with the key. May be encrypted depending on adapter logic.\n   * @param {string} origin - A unique identifier for the source of the change (e.g., tab ID or UUID).\n   */\n  emitDataChange(key, value, origin) {\n    // Ensure the communication channel is active and an origin is provided.\n    if (!this.channelName || !origin) {\n      return;\n    }\n    logInfo(\n      `StorageAdapter - Emitting data change for key \"${key}\" from origin \"${origin}\"`\n    );\n    // Emit a structured message containing change metadata and the new value.\n    this.channel.emit({\n      adapterId: this.adapterId, // Identifies which adapter emitted the change.\n      key, // The key that was changed.\n      value, // The new (possibly encrypted) value.\n      origin, // Identifies the origin of this change.\n    });\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Registers a callback function to be invoked when data changes\n   * are emitted through the communication channel.\n   *\n   * This is used to keep stores or application state in sync when\n   * updates happen from external sources (e.g., other tabs or devices).\n   *\n   * @param {Function} callback - A function to handle incoming data change events.\n   *                              The callback receives an object with properties:\n   *                              `{ adapterId, key, value, origin }`\n   */\n  onDataChanged(callback) {\n    // Validate that a channel exists and the provided callback is a function.\n    if (!this.channelName || typeof callback !== \"function\") {\n      return;\n    }\n\n    // Subscribe the callback to the channel to receive emitted data changes.\n    logInfo(\"StorageAdapter - Subscribing to cross-tab data changes.\");\n    this.channel.subscribe(callback);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default StorageAdapter;\n\n// ------------------------------------------------------------------------------------------------\n","/**\n * IndexedDBAdapter is a storage adapter that utilizes the browser's IndexedDB to persist key-value data.\n * Supports optional encryption and expiration features, and handles initialization, reads, writes,\n * and periodic expiration cleanup.\n *\n * @module IndexedDBAdapter\n * @example\n * // Basic usage:\n * const adapter = new IndexedDBAdapter({\n *   dbName: 'myDatabase',\n *   storeName: 'myStore',\n *   encrypt: true,\n * });\n * await adapter.set('key', 'value', 3600000); // Expires in 1 hour\n * const value = await adapter.get('key');\n */\n\nimport StorageAdapter from \"./StorageAdapter.js\";\nimport sleep from \"misc-helpers/src/utils/sleep.js\";\nimport generateSimpleId from \"misc-helpers/src/utils/generateSimpleId.js\";\nimport { logError, logWarn, logInfo } from \"../helpers/loggerHelper.js\";\nimport { simpleDeobfuscate } from \"../helpers/cryptoHelper.js\";\n\n// -------------------------------------------------------------------------------------------------\n\n/**\n * Class representing an IndexedDB storage adapter.\n * @class IndexedDBAdapter\n * @extends StorageAdapter\n */\nclass IndexedDBAdapter extends StorageAdapter {\n  /**\n   * Creates an instance of IndexedDBAdapter.\n   * @param {Object} config Configuration object\n   * @param {string} config.dbName Name of the IndexedDB database\n   * @param {string} [config.storeName] Name of the object store (defaults to `${dbName}_store`)\n   * @param {number} [config.version=1] Database version\n   * @param {boolean} [config.encrypt=false] Whether to encrypt stored data\n   * @param {number} [config.expireCheckInterval=1000] Interval for expiration checks in ms\n   * @param {string} [config.description=\"\"] Description of the database\n   * @param {string} [config.channelName=false] - Optional channel name for cross-tab communication.\n   * @param {boolean} [config.enableSyncTabs=false] - Whether to enable sync automatically on change key value\n   * @throws {Error} Throws if IndexedDB is not available in the environment\n   */\n  constructor({\n    dbName,\n    storeName,\n    version = 1,\n    encrypt = false,\n    expireCheckInterval = 1000,\n    channelName = false,\n    enableSyncTabs = false,\n    description = \"\",\n  }) {\n    super(channelName);\n    if (typeof indexedDB === \"undefined\") {\n      logError(\"IndexedDB is not available in this environment\");\n      throw new Error(\"IndexedDB is not available in this environment\");\n    }\n\n    this.isReady = false;\n    this.dbName = dbName;\n    this.storeName = storeName || `${dbName}_store`;\n    this.encrypt = encrypt;\n    this.expireKey = `STRGF_${dbName}__expires`;\n    this.metaKey = `STRGF_${dbName}__meta`;\n    this.prefix = `${dbName}__`;\n    this.adapterId = generateSimpleId(dbName);\n    this.enableSyncTabs = enableSyncTabs || false;\n    this.expireCheckInterval = expireCheckInterval;\n    this.dbPromise = null;\n    this._initDB({ dbName, version, description });\n    this._startExpireWatcher();\n\n    this._unloadHandler = () => this.destroy();\n    window.addEventListener(\"beforeunload\", this._unloadHandler);\n\n    logInfo(\n      `IndexedDBAdapter - initialized with dbName: ${dbName}, storeName: ${this.storeName}`\n    );\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Initializes the IndexedDB database.\n   * @private\n   * @param {Object} params Initialization parameters\n   * @param {string} params.dbName Database name\n   * @param {number} params.version Database version\n   * @param {string} params.description Database description\n   * @returns {Promise} Resolves with the database instance when ready\n   */\n  _initDB({ dbName, version, description }) {\n    logInfo(\n      `IndexedDBAdapter -Initializing IndexedDB with dbName: ${dbName}, storeName: ${this.storeName}`\n    );\n    this.dbPromise = new Promise((resolve, reject) => {\n      const request = indexedDB.open(dbName, version);\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName);\n        }\n\n        // Store metadata\n        const meta = {\n          dbName,\n          version,\n          description,\n          createdAt: Date.now(),\n        };\n        const transaction = event.target.transaction;\n        const store = transaction.objectStore(this.storeName);\n        store.put(JSON.stringify(meta), this.metaKey);\n      };\n\n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        // Check if metadata exists, if not create it\n        const transaction = db.transaction(this.storeName, \"readwrite\");\n        const store = transaction.objectStore(this.storeName);\n        const metaRequest = store.get(this.metaKey);\n        metaRequest.onsuccess = () => {\n          if (!metaRequest.result) {\n            const meta = {\n              dbName,\n              version,\n              description,\n              createdAt: Date.now(),\n            };\n            store.put(JSON.stringify(meta), this.metaKey);\n          }\n          this.isReady = true;\n          resolve(db);\n        };\n        metaRequest.onerror = (err) => {\n          logError(\"Error checking meta:\", err);\n          resolve(db); // Still resolve with db even if meta check failed\n        };\n      };\n\n      request.onerror = (event) => {\n        logError(\"Error opening database:\", event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Waits for the database to be ready.\n   * @async\n   * @param {number} [timeout=15] Delay between readiness checks in ms\n   * @param {number} [tries=20] Maximum number of readiness checks\n   * @returns {Promise<void>} Resolves when database is ready\n   * @throws {Error} Throws if database doesn't become ready within the specified attempts\n   */\n  async waitReadiness(timeout = 50, tries = 20) {\n    logInfo(\n      `IndexedDBAdapter - Waiting for database readiness with timeout: ${timeout}ms, tries: ${tries}`\n    );\n    return new Promise(async (resolve, reject) => {\n      try {\n        await sleep(timeout);\n        if (this.isReady) {\n          resolve();\n          return true;\n        }\n\n        let attempt = 0;\n        while (!this.isReady && attempt++ < tries) {\n          setTimeout(() => {\n            if (this.isReady) {\n              resolve();\n              return true;\n            }\n          }, timeout);\n        }\n      } catch (error) {\n        return reject(error);\n      }\n\n      reject(new Error(\"Database is not ready\"));\n    });\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Helper method to execute operations within a store transaction.\n   * @private\n   * @async\n   * @param {string} mode Transaction mode ('readonly' or 'readwrite')\n   * @param {Function} callback Operation to execute with the store\n   * @returns {Promise} Resolves with the callback result\n   * @throws {Error} Throws if the operation fails\n   */\n  async _withStore(mode, callback) {\n    try {\n      logInfo(`IndexedDBAdapter - Executing operation in ${mode} mode`);\n      const db = await this.dbPromise;\n      const transaction = db.transaction(this.storeName, mode);\n      const store = transaction.objectStore(this.storeName);\n      return await callback(store);\n    } catch (err) {\n      logError(\"Database operation failed:\", err);\n      throw err;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Loads all expiration timestamps.\n   * @private\n   * @async\n   * @returns {Promise<Object>} Object mapping keys to expiration timestamps\n   */\n  async _loadExpires() {\n    logInfo(\"IndexedDBAdapter - Loading expiration timestamps\");\n    return this._withStore(\"readonly\", async (store) => {\n      return new Promise((resolve) => {\n        const request = store.get(this.expireKey);\n        request.onsuccess = () => {\n          resolve(request.result ? JSON.parse(request.result) : {});\n        };\n        request.onerror = () => {\n          resolve({});\n        };\n      });\n    });\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Retrieves a value from storage by key.\n   * @async\n   * @param {string} key Key to retrieve\n   * @returns {Promise<*>} The stored value, or null if not found or expired\n   * @example\n   * const value = await adapter.get('myKey');\n   */\n  async get(key) {\n    try {\n      logInfo(`IndexedDBAdapter - Getting key: ${key}`);\n      const fullKey = this._fullKey(key);\n      const raw = await this._withStore(\"readonly\", (store) => {\n        return new Promise((resolve) => {\n          const request = store.get(fullKey);\n          request.onsuccess = () => resolve(request.result);\n          request.onerror = () => resolve(null);\n        });\n      });\n\n      if (!raw) return null;\n\n      const expires = await this.getExpire(key);\n      if (expires && Date.now() >= expires) {\n        await this.delete(key);\n        return null;\n      }\n\n      return await this._decrypt(key, raw);\n    } catch (err) {\n      logError(`Error getting key '${key}':`, err);\n      return null;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Stores a value in storage with optional expiration.\n   * @async\n   * @param {string} key Key to store under\n   * @param {*} value Value to store (will be JSON stringified)\n   * @param {number} [expire] Expiration time in milliseconds from now\n   * @returns {Promise<boolean>} True if successful, false otherwise\n   * @example\n   * await adapter.set('myKey', { data: 'value' }, 3600000); // Expires in 1 hour\n   */\n  async set(key, value, expire) {\n    try {\n      logInfo(`IndexedDBAdapter - Setting key: ${key}`, { value, expire });\n      if (!key && !value) {\n        return false;\n      }\n      const fullKey = this._fullKey(key);\n      if (key && (value === undefined || value === null)) {\n        await this.delete(fullKey);\n        return null;\n      }\n      value = JSON.stringify(value);\n\n      const encrypted = await this._encrypt(key, value);\n      if (!encrypted) return false;\n\n      await this._withStore(\"readwrite\", (store) => {\n        return new Promise((resolve) => {\n          const request = store.put(encrypted, fullKey);\n          request.onsuccess = () => {\n            if (this.enableSyncTabs) {\n              this.emitDataChange(key, undefined, \"reset\");\n            }\n            resolve(true);\n          };\n          request.onerror = () => resolve(false);\n        });\n      });\n\n      if (typeof expire !== \"number\") {\n        await this.deleteExpire(key);\n        return true;\n      }\n\n      if (expire > 0) {\n        await this.setExpire(key, Date.now() + expire);\n        return true;\n      }\n\n      await this.delete(key);\n      return null;\n    } catch (err) {\n      logError(`Error setting key '${key}':`, err);\n      return false;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Deletes a key from storage.\n   * @async\n   * @param {string} key Key to delete\n   * @returns {Promise<void>}\n   * @example\n   * await adapter.delete('myKey');\n   */\n  async delete(key) {\n    try {\n      logInfo(`IndexedDBAdapter - Deleting key: ${key}`);\n      const fullKey = this._fullKey(key);\n      await this._withStore(\"readwrite\", (store) => {\n        return new Promise((resolve) => {\n          const request = store.delete(fullKey);\n          request.onsuccess = () => {\n            if (this.enableSyncTabs) {\n              this.emitDataChange(key, undefined, \"reset\");\n            }\n            resolve(true);\n          };\n          request.onerror = () => resolve();\n        });\n      });\n\n      const exp = await this._loadExpires();\n      delete exp[key];\n      await this._withStore(\"readwrite\", (store) => {\n        return new Promise((resolve) => {\n          const request = store.put(JSON.stringify(exp), this.expireKey);\n          request.onsuccess = () => resolve();\n          request.onerror = () => resolve();\n        });\n      });\n    } catch (err) {\n      logError(`Error deleting key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Lists all keys with a given prefix and their values.\n   * @async\n   * @returns {Promise<Array<{key: string, value: *}>>} Array of key-value pairs\n   * @example\n   * const items = await adapter.list('user_');\n   */\n  async list() {\n    const results = [];\n    try {\n      logInfo(`IndexedDBAdapter - Listing keys with prefix: ${this.prefix}`);\n      await this._withStore(\"readonly\", async (store) => {\n        return new Promise((resolve) => {\n          const request = store.getAllKeys();\n          request.onsuccess = async () => {\n            const keys = request.result || [];\n            for (let k of keys) {\n              if (this.encrypt) {\n                k = simpleDeobfuscate(k);\n              }\n              if (k === this.metaKey || k === this.expireKey) continue;\n              if (k.startsWith(this.prefix)) {\n                const value = await this.get(k.replace(this.prefix, \"\"));\n                if (value !== null) {\n                  results.push({ key: k.replace(this.prefix, \"\"), value });\n                }\n              }\n            }\n            resolve();\n          };\n          request.onerror = () => resolve();\n        });\n      });\n    } catch (err) {\n      logError(\"Error listing keys:\", err);\n    }\n    return results;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Checks if a key exists in storage.\n   * @async\n   * @param {string} key Key to check\n   * @returns {Promise<boolean>} True if key exists, false otherwise\n   * @example\n   * const exists = await adapter.has('myKey');\n   */\n  async has(key) {\n    try {\n      logInfo(`IndexedDBAdapter - Checking existence of key: ${key}`);\n      const fullKey = this._fullKey(key);\n      return await this._withStore(\"readonly\", (store) => {\n        return new Promise((resolve) => {\n          const request = store.getKey(fullKey);\n          request.onsuccess = () => resolve(request.result !== undefined);\n          request.onerror = () => resolve(false);\n        });\n      });\n    } catch (err) {\n      logError(`Error checking key '${key}':`, err);\n      return false;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Clears all data from storage including metadata.\n   * @async\n   * @returns {Promise<void>}\n   * @example\n   * await adapter.clear();\n   */\n  async clear() {\n    try {\n      logInfo(\"IndexedDBAdapter - Clearing all data\");\n      await this.reset();\n      await this._withStore(\"readwrite\", (store) => {\n        return new Promise((resolve) => {\n          const request = store.delete(this.metaKey);\n          request.onsuccess = () => {\n            const request2 = store.delete(this.expireKey);\n            request2.onsuccess = () => resolve();\n            request2.onerror = () => resolve();\n          };\n          request.onerror = () => resolve();\n        });\n      });\n    } catch (err) {\n      logError(\"Error clearing storage:\", err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Resets storage by removing all keys with the adapter's prefix.\n   * @async\n   * @returns {Promise<void>}\n   * @example\n   * await adapter.reset();\n   */\n  async reset() {\n    try {\n      logInfo(\"IndexedDBAdapter - Resetting storage\");\n      await this._withStore(\"readwrite\", async (store) => {\n        return new Promise((resolve) => {\n          const request = store.getAllKeys();\n          request.onsuccess = () => {\n            const keys = request.result || [];\n\n            if (keys.length === 0) {\n              resolve();\n              return;\n            }\n\n            let completed = 0;\n            const checkCompletion = (key) => {\n              return () => {\n                if (++completed === keys.length) {\n                  if (this.enableSyncTabs) {\n                    this.emitDataChange(key.replace(this.prefix, \"\"), \"reset\");\n                  }\n                  resolve();\n                }\n              };\n            };\n\n            for (const key of keys) {\n              const deleteRequest = store.delete(key);\n              deleteRequest.onsuccess = checkCompletion(key);\n              deleteRequest.onerror = checkCompletion(key);\n            }\n          };\n          request.onerror = () => resolve();\n        });\n      });\n    } catch (error) {\n      logError(\"Error resetting storage:\", error);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Sets expiration timestamp for a key.\n   * @async\n   * @param {string} key Key to set expiration for\n   * @param {number} timestamp Expiration timestamp in milliseconds\n   * @returns {Promise<void>}\n   * @example\n   * await adapter.setExpire('myKey', Date.now() + 3600000); // Expire in 1 hour\n   */\n  async setExpire(key, timestamp) {\n    try {\n      logInfo(\n        `IndexedDBAdapter - Setting expire for key: ${key}, timestamp: ${timestamp}`\n      );\n      const expires = await this._loadExpires();\n      expires[key] = timestamp;\n      await this._withStore(\"readwrite\", (store) => {\n        return new Promise((resolve) => {\n          const request = store.put(JSON.stringify(expires), this.expireKey);\n          request.onsuccess = () => resolve();\n          request.onerror = () => resolve();\n        });\n      });\n    } catch (err) {\n      logError(`Error setting expire for key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Removes expiration for a key.\n   * @async\n   * @param {string} key Key to remove expiration from\n   * @returns {Promise<void>}\n   * @example\n   * await adapter.deleteExpire('myKey');\n   */\n  async deleteExpire(key) {\n    try {\n      logInfo(`IndexedDBAdapter - Deleting expire for key: ${key}`);\n      const expires = await this._loadExpires();\n      delete expires[key];\n      await this._withStore(\"readwrite\", (store) => {\n        return new Promise((resolve) => {\n          const request = store.put(JSON.stringify(expires), this.expireKey);\n          request.onsuccess = () => resolve();\n          request.onerror = () => resolve();\n        });\n      });\n    } catch (err) {\n      logError(`Error deleting expire for key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Clears all expired keys from storage.\n   * @async\n   * @returns {Promise<void>}\n   * @example\n   * await adapter.clearExpire();\n   */\n  async clearExpire() {\n    try {\n      logInfo(\"IndexedDBAdapter - Clearing expired keys\");\n      const now = Date.now();\n      const expires = await this._loadExpires();\n      let changed = false;\n\n      for (const key in expires) {\n        if (expires[key] <= now) {\n          await this.delete(key);\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        const currentExpires = await this._loadExpires();\n        await this._withStore(\"readwrite\", (store) => {\n          return new Promise((resolve) => {\n            const request = store.put(\n              JSON.stringify(currentExpires),\n              this.expireKey\n            );\n            request.onsuccess = () => resolve();\n            request.onerror = () => resolve();\n          });\n        });\n      }\n    } catch (err) {\n      logError(\"Error clearing expired keys:\", err);\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------------------------\n\nexport default IndexedDBAdapter;\n\n// ----------------------------------------------------------------------------------------------\n","import StorageAdapter from \"./StorageAdapter.js\";\nimport generateSimpleId from \"misc-helpers/src/utils/generateSimpleId.js\";\nimport { logError, logWarn, logInfo } from \"../helpers/loggerHelper.js\";\nimport { simpleDeobfuscate } from \"../helpers/cryptoHelper.js\";\n\n// -------------------------------------------------------------------------------------------------\n\n/**\n * A storage adapter for `localStorage` that supports encryption, expirations, and metadata.\n * Extends the base `StorageAdapter` class.\n */\nclass LocalStorageAdapter extends StorageAdapter {\n  /**\n   * @param {Object} options\n   * @param {string} options.dbName - The database namespace.\n   * @param {number} [options.version=1] - The version of the storage schema.\n   * @param {boolean} [options.encrypt=false] - Whether to encrypt stored values.\n   * @param {number} [options.expireCheckInterval=1000] - Interval for expiration checks.\n   * @param {string} [options.description=\"\"] - Description of the storage instance.\n   * @param {string} [options.channelName=false] - Optional channel name for cross-tab communication.\n   * @param {boolean} [options.enableSyncTabs=false] - Whether to enable sync automatically on change key value\n   * @throws {Error} If `localStorage` is not available.\n   */\n  constructor({\n    dbName,\n    version = 1,\n    encrypt = false,\n    expireCheckInterval = 1000,\n    description = \"\",\n    channelName = false,\n    enableSyncTabs = false,\n  }) {\n    super(channelName);\n    if (typeof localStorage === \"undefined\") {\n      logError(\"LocalStorage is not available in this environment\");\n      throw new Error(\"LocalStorage is not available in this environment\");\n    }\n\n    this.dbName = dbName;\n    this.encrypt = encrypt;\n    this.expireKey = `STRGF_${dbName}__expires`;\n    this.metaKey = `STRGF_${dbName}__meta`;\n    this.prefix = `${dbName}__`;\n    this.adapterId = generateSimpleId(dbName);\n    this.expireCheckInterval = expireCheckInterval;\n    this.enableSyncTabs = enableSyncTabs || false;\n\n    this._initMeta({ dbName, version, description });\n    this._startExpireWatcher();\n\n    this._unloadHandler = () => this.destroy();\n    window.addEventListener(\"beforeunload\", this._unloadHandler);\n\n    logInfo(\n      `LocalStorageAdapter -  initialized with dbName: ${dbName}, version: ${version}, encrypt: ${encrypt}, description: ${description}`\n    );\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Initializes metadata for the storage namespace.\n   * @private\n   * @param {Object} param0\n   * @param {string} param0.dbName\n   * @param {number} param0.version\n   * @param {string} param0.description\n   */\n  _initMeta({ dbName, version, description }) {\n    try {\n      logInfo(\n        \"LocalStorageAdapter - Initializing metadata for LocalStorageAdapter\"\n      );\n      const meta = {\n        dbName,\n        version,\n        description,\n        createdAt: Date.now(),\n      };\n      localStorage.setItem(this.metaKey, JSON.stringify(meta));\n    } catch (err) {\n      logError(\"Error initializing meta:\", err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Loads expiration metadata from storage.\n   * @private\n   * @returns {Object} Key-value map of expiration timestamps.\n   */\n  _loadExpires() {\n    try {\n      logInfo(\"LocalStorageAdapter - Loading expiration metadata\");\n      const raw = localStorage.getItem(this.expireKey);\n      return raw ? JSON.parse(raw) : {};\n    } catch (err) {\n      logError(\"Error loading expires:\", err);\n      return {};\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Retrieves a stored item.\n   * @param {string} key\n   * @returns {Promise<any|null>} The stored value, or `null` if not found or expired.\n   */\n  async get(key) {\n    try {\n      logInfo(`LocalStorageAdapter - Getting key: ${key}`);\n      const fullKey = this._fullKey(key);\n      const raw = localStorage.getItem(fullKey);\n      if (!raw) return null;\n\n      const expires = await this.getExpire(key);\n      if (expires && Date.now() >= expires) {\n        await this.delete(key);\n        return null;\n      }\n\n      return await this._decrypt(key, raw);\n    } catch (err) {\n      logError(`Error getting key '${key}':`, err);\n      return null;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Stores a value.\n   * @param {string} key\n   * @param {any} value\n   * @param {number} [expire] - Optional expiration in milliseconds from now.\n   * @returns {Promise<boolean|null>}\n   */\n  async set(key, value, expire) {\n    try {\n      logInfo(`LocalStorageAdapter - Setting key: ${key}`, { value, expire });\n      if (!key && !value) return false;\n      const fullKey = this._fullKey(key);\n      if (key && (value === undefined || value === null)) {\n        await this.delete(fullKey);\n        return null;\n      }\n      value = JSON.stringify(value);\n\n      const encrypted = await this._encrypt(key, value);\n      if (!encrypted) return false;\n      localStorage.setItem(fullKey, encrypted);\n\n      if (this.enableSyncTabs) {\n        this.emitDataChange(key, undefined, \"set\");\n      }\n\n      if (typeof expire !== \"number\") {\n        await this.deleteExpire(key);\n        return true;\n      }\n\n      if (expire > 0) {\n        await this.setExpire(key, Date.now() + expire);\n        return true;\n      }\n\n      await this.delete(key);\n      return null;\n    } catch (err) {\n      logError(`Error setting key '${key}':`, err);\n      return false;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Deletes a value and its expiration.\n   * @param {string} key\n   * @returns {Promise<void>}\n   */\n  async delete(key) {\n    try {\n      logInfo(`LocalStorageAdapter - Deleting key: ${key}`);\n      const fullKey = this._fullKey(key);\n      localStorage.removeItem(fullKey);\n\n      const exp = this._loadExpires();\n      delete exp[key];\n      localStorage.setItem(this.expireKey, JSON.stringify(exp));\n      if (this.enableSyncTabs) {\n        this.emitDataChange(key, undefined, \"delete\");\n      }\n    } catch (err) {\n      logError(`Error deleting key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Lists all keys and their values for the current prefix.\n   * @returns {Promise<Array<{ key: string, value: any }>>}\n   */\n  async list() {\n    const results = [];\n    logInfo(`LocalStorageAdapter - Listing keys with prefix: ${this.prefix}`);\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        let k = localStorage.key(i);\n        if (this.encrypt) {\n          k = simpleDeobfuscate(k);\n        }\n        if (k === this.metaKey || k === this.expireKey) continue;\n        if (k.startsWith(this.prefix)) {\n          const value = await this.get(k.replace(this.prefix, \"\"));\n          if (value !== null) {\n            results.push({ key: k.replace(this.prefix, \"\"), value });\n          }\n        }\n      }\n    } catch (err) {\n      logError(\"Error listing keys:\", err);\n      throw err;\n    }\n    return results;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Checks whether a key exists.\n   * @param {string} key\n   * @returns {Promise<boolean>}\n   */\n  async has(key) {\n    try {\n      logInfo(`LocalStorageAdapter - Checking existence of key: ${key}`);\n      const fullKey = this._fullKey(key);\n      return localStorage.getItem(fullKey) !== null;\n    } catch (err) {\n      logError(`Error checking key '${key}':`, err);\n      return false;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Clears all data, metadata, and expiration info.\n   * @returns {Promise<void>}\n   */\n  async clear() {\n    try {\n      logInfo(\"LocalStorageAdapter - Clearing all data\");\n      await this.reset();\n      localStorage.removeItem(this.metaKey);\n      localStorage.removeItem(this.expireKey);\n    } catch (err) {\n      logError(\"Error clearing storage:\", err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Removes all keys related to the current storage instance.\n   * @returns {Promise<void>}\n   */\n  async reset() {\n    try {\n      logInfo(\"LocalStorageAdapter - Resetting storage\");\n      const keysToRemove = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key.startsWith(this.prefix)) {\n          keysToRemove.push(key);\n        }\n      }\n\n      for (const key of keysToRemove) {\n        localStorage.removeItem(key);\n        if (this.enableSyncTabs) {\n          this.emitDataChange(key.replace(this.prefix, \"\"), undefined, \"reset\");\n        }\n      }\n    } catch (error) {\n      logError(\"Error resetting storage:\", error);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Sets an expiration timestamp for a key.\n   * @param {string} key\n   * @param {number} timestamp - Unix timestamp in milliseconds.\n   * @returns {Promise<void>}\n   */\n  async setExpire(key, timestamp) {\n    try {\n      logInfo(`LocalStorageAdapter - Setting expiration for key: ${key}`, {\n        timestamp,\n      });\n      const expires = this._loadExpires();\n      expires[key] = timestamp;\n      localStorage.setItem(this.expireKey, JSON.stringify(expires));\n    } catch (err) {\n      logError(`Error setting expire for key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Removes the expiration timestamp for a key.\n   * @param {string} key\n   * @returns {Promise<void>}\n   */\n  async deleteExpire(key) {\n    try {\n      logInfo(`LocalStorageAdapter - Deleting expiration for key: ${key}`);\n      const expires = this._loadExpires();\n      delete expires[key];\n      localStorage.setItem(this.expireKey, JSON.stringify(expires));\n    } catch (err) {\n      logError(`Error deleting expire for key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Removes all expired items from storage.\n   * @returns {Promise<void>}\n   */\n  async clearExpire() {\n    try {\n      logInfo(\"LocalStorageAdapter - Clearing expired keys\");\n      const now = Date.now();\n      const expires = this._loadExpires();\n      let changed = false;\n\n      for (const key in expires) {\n        if (expires[key] <= now) {\n          await this.delete(key);\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        localStorage.setItem(\n          this.expireKey,\n          JSON.stringify(this._loadExpires())\n        );\n      }\n    } catch (err) {\n      logError(\"Error clearing expired keys:\", err);\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------------------------\n\nexport default LocalStorageAdapter;\n\n// ----------------------------------------------------------------------------------------------\n","import StorageAdapter from \"./StorageAdapter.js\";\nimport generateSimpleId from \"misc-helpers/src/utils/generateSimpleId.js\";\nimport { simpleDeobfuscate } from \"../helpers/cryptoHelper.js\";\nimport { logError, logWarn, logInfo } from \"../helpers/loggerHelper.js\";\n\n// -------------------------------------------------------------------------------------------------\n\n/**\n * @class SessionStorageAdapter\n * @extends StorageAdapter\n * Adapter for browser sessionStorage with optional encryption and expiration support.\n */\nclass SessionStorageAdapter extends StorageAdapter {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {string} options.dbName - The namespace for storage keys.\n   * @param {number} [options.version=1] - Schema version of the storage.\n   * @param {boolean} [options.encrypt=false] - Whether to encrypt stored values.\n   * @param {number} [options.expireCheckInterval=1000] - Interval to check for expired items (ms).\n   * @param {string} [options.description=\"\"] - Optional description metadata.\n   * @param {string} [options.channelName=false] - Optional channel name for cross-tab communication.\n   * @param {boolean} [options.enableSyncTabs=false] - Whether to enable sync automatically on change key value\n   * @throws Will throw if sessionStorage is not available.\n   */\n  constructor({\n    dbName,\n    version = 1,\n    encrypt = false,\n    expireCheckInterval = 1000,\n    channelName = false,\n    description = \"\",\n    enableSyncTabs = false,\n  }) {\n    super(channelName);\n    if (typeof sessionStorage === \"undefined\") {\n      logError(\"SessionStorage is not available in this environment\");\n      throw new Error(\"SessionStorage is not available in this environment\");\n    }\n\n    this.dbName = dbName;\n    this.encrypt = encrypt;\n\n    this.expireKey = `STRGF_${dbName}__expires`;\n    this.metaKey = `STRGF_${dbName}__meta`;\n    this.prefix = `${dbName}__`;\n    this.adapterId = generateSimpleId(dbName);\n    this.expireCheckInterval = expireCheckInterval;\n    this.enableSyncTabs = enableSyncTabs || false;\n\n    this._initMeta({ dbName, version, description });\n    this._startExpireWatcher();\n\n    this._unloadHandler = () => this.destroy();\n    window.addEventListener(\"beforeunload\", this._unloadHandler);\n    logInfo(\n      `SessionStorageAdapter - initialized with prefix: ${this.prefix}, encrypt: ${this.encrypt}`\n    );\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Initializes metadata for the current storage instance.\n   * @private\n   * @param {Object} meta\n   * @param {string} meta.dbName\n   * @param {number} meta.version\n   * @param {string} meta.description\n   */\n  _initMeta({ dbName, version, description }) {\n    try {\n      logInfo(\n        `SessionStorageAdapter - Initializing metadata for ${dbName} v${version}`\n      );\n      const meta = {\n        dbName,\n        version,\n        description,\n        createdAt: Date.now(),\n      };\n      sessionStorage.setItem(this.metaKey, JSON.stringify(meta));\n    } catch (err) {\n      logError(\"Error initializing meta:\", err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Loads expiration map from sessionStorage.\n   * @private\n   * @returns {Object<string, number>}\n   */\n  _loadExpires() {\n    try {\n      logInfo(\"SessionStorageAdapter - Loading expiration map\");\n      const raw = sessionStorage.getItem(this.expireKey);\n      return raw ? JSON.parse(raw) : {};\n    } catch (err) {\n      logError(\"Error loading expires:\", err);\n      return {};\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Retrieves a value from storage, handling expiration.\n   * @param {string} key\n   * @returns {Promise<any|null>}\n   */\n  async get(key) {\n    try {\n      logInfo(`SessionStorageAdapter - Getting key '${key}'`);\n      const fullKey = this._fullKey(key);\n      const raw = sessionStorage.getItem(fullKey);\n      if (!raw) return null;\n\n      const expires = await this.getExpire(key);\n      if (expires && Date.now() >= expires) {\n        await this.delete(key);\n        return null;\n      }\n\n      return await this._decrypt(key, raw);\n    } catch (err) {\n      logError(`Error getting key '${key}':`, err);\n      return null;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Stores a value, with optional expiration.\n   * @param {string} key\n   * @param {any} value\n   * @param {number} [expire] - Time in ms until expiration.\n   * @returns {Promise<boolean|null>}\n   */\n  async set(key, value, expire) {\n    try {\n      logInfo(`SessionStorageAdapter - Setting key: ${key}`, { value, expire });\n      if (!key && !value) return false;\n\n      const fullKey = this._fullKey(key);\n      if (key && (value === undefined || value === null)) {\n        await this.delete(fullKey);\n        return null;\n      }\n\n      value = JSON.stringify(value);\n      const encrypted = await this._encrypt(key, value);\n      if (!encrypted) return false;\n\n      sessionStorage.setItem(fullKey, encrypted);\n      if (this.enableSyncTabs) {\n        this.emitDataChange(key, encrypted, \"set\");\n      }\n\n      if (typeof expire !== \"number\") {\n        await this.deleteExpire(key);\n        return true;\n      }\n\n      if (expire > 0) {\n        await this.setExpire(key, Date.now() + expire);\n        return true;\n      }\n\n      await this.delete(key);\n      return null;\n    } catch (err) {\n      logError(`Error setting key '${key}':`, err);\n      return false;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Deletes a key from storage and its expiration.\n   * @param {string} key\n   * @returns {Promise<void>}\n   */\n  async delete(key) {\n    try {\n      logInfo(`SessionStorageAdapter - Deleting key '${key}'`);\n      const fullKey = this._fullKey(key);\n      sessionStorage.removeItem(fullKey);\n\n      const exp = this._loadExpires();\n      delete exp[key];\n      sessionStorage.setItem(this.expireKey, JSON.stringify(exp));\n      if (this.enableSyncTabs) {\n        this.emitDataChange(key, undefined, \"delete\");\n      }\n    } catch (err) {\n      logError(`Error deleting key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Lists all stored key-value pairs under a prefix.\n   * @returns {Promise<Array<{key: string, value: any}>>}\n   */\n  async list() {\n    const results = [];\n    try {\n      logInfo(\n        `SessionStorageAdapter - Listing keys with prefix '${this.prefix}'`\n      );\n      for (let i = 0; i < sessionStorage.length; i++) {\n        let k = sessionStorage.key(i);\n        if (this.encrypt) {\n          k = simpleDeobfuscate(k);\n        }\n        if (k === this.metaKey || k === this.expireKey) continue;\n        if (k.startsWith(this.prefix)) {\n          const value = await this.get(k.replace(this.prefix, \"\"));\n          if (value !== null) {\n            results.push({ key: k.replace(this.prefix, \"\"), value });\n          }\n        }\n      }\n    } catch (err) {\n      logError(\"Error listing keys:\", err);\n      throw err;\n    }\n    return results;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Checks if a key exists.\n   * @param {string} key\n   * @returns {Promise<boolean>}\n   */\n  async has(key) {\n    try {\n      logInfo(`SessionStorageAdapter - Checking existence of key '${key}'`);\n      const fullKey = this._fullKey(key);\n      return sessionStorage.getItem(fullKey) !== null;\n    } catch (err) {\n      logError(`Error checking key '${key}':`, err);\n      return false;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Clears all stored data and metadata.\n   * @returns {Promise<void>}\n   */\n  async clear() {\n    try {\n      logInfo(\"SessionStorageAdapter - Clearing all data\");\n      await this.reset();\n      sessionStorage.removeItem(this.metaKey);\n      sessionStorage.removeItem(this.expireKey);\n    } catch (err) {\n      logError(\"Error clearing storage:\", err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Removes all keys matching the current prefix.\n   * @returns {Promise<void>}\n   */\n  async reset() {\n    try {\n      logInfo(\"SessionStorageAdapter - Resetting storage\");\n      const keysToRemove = [];\n\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key.startsWith(this.prefix)) {\n          keysToRemove.push(key);\n        }\n      }\n\n      for (const key of keysToRemove) {\n        sessionStorage.removeItem(key);\n        if (this.enableSyncTabs) {\n          this.emitDataChange(key.replace(this.prefix, \"\"), undefined, \"reset\");\n        }\n      }\n    } catch (error) {\n      logError(\"Error resetting storage:\", error);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Sets an expiration timestamp for a key.\n   * @param {string} key\n   * @param {number} timestamp - Expiration time (epoch ms).\n   * @returns {Promise<void>}\n   */\n  async setExpire(key, timestamp) {\n    try {\n      logInfo(`SessionStorageAdapter - Setting expire for key '${key}'`);\n      const expires = this._loadExpires();\n      expires[key] = timestamp;\n      sessionStorage.setItem(this.expireKey, JSON.stringify(expires));\n    } catch (err) {\n      logError(`Error setting expire for key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Removes expiration data for a given key.\n   * @param {string} key\n   * @returns {Promise<void>}\n   */\n  async deleteExpire(key) {\n    try {\n      logInfo(`SessionStorageAdapter - Deleting expire for key '${key}'`);\n      const expires = this._loadExpires();\n      delete expires[key];\n      sessionStorage.setItem(this.expireKey, JSON.stringify(expires));\n    } catch (err) {\n      logError(`Error deleting expire for key '${key}':`, err);\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Clears all expired keys based on their timestamps.\n   * @returns {Promise<void>}\n   */\n  async clearExpire() {\n    try {\n      logInfo(\"SessionStorageAdapter - Clearing expired keys\");\n      const now = Date.now();\n      const expires = this._loadExpires();\n      let changed = false;\n\n      for (const key in expires) {\n        if (expires[key] <= now) {\n          await this.delete(key);\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        sessionStorage.setItem(\n          this.expireKey,\n          JSON.stringify(this._loadExpires())\n        );\n      }\n    } catch (err) {\n      logError(\"Error clearing expired keys:\", err);\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------------------------\n\nexport default SessionStorageAdapter;\n\n// ----------------------------------------------------------------------------------------------\n","import { logInfo } from \"../helpers/loggerHelper.js\";\n\n/**\n * Abstract base class for storage adapters. Provides the interface for concrete storage implementations.\n * All storage adapters should extend this class and implement its abstract methods.\n *\n * @module StoreAdapter\n * @abstract\n * @example\n * // Example of implementing a custom adapter:\n * class CustomAdapter extends StoreAdapter {\n *   async setInStorage(store, key, options) {\n *     // Implementation here\n *   }\n *   \n *   async getFromStorage(store, key) {\n *     // Implementation here\n *   }\n * }\n */\n\nclass StoreAdapter {\n  /**\n   * Stores data in the specified storage with the given key.\n   * @abstract\n   * @async\n   * @param {string} store The name/identifier of the storage location\n   * @param {string} key The key under which to store the data\n   * @param {Object} [options={}] Storage options\n   * @param {*} options.value The value to store\n   * @param {string[]} [options.ignoreKeys] Array of keys to ignore in the stored value\n   * @param {number} [options.timeout] Timeout in milliseconds for the operation\n   * @returns {Promise<void>}\n   * @throws {Error} Must be implemented by subclasses\n   * @throws {Error} May throw on timeout or storage failure\n   * @example\n   * await adapter.setInStorage('userData', 'preferences', {\n   *   value: { theme: 'dark', tokens: 'secret' },\n   *   ignoreKeys: ['tokens'], // Will exclude these keys from storage\n   *   timeout: 5000 // 5 second timeout\n   * });\n   */\n  async setInStorage(store, key, options = {}) {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Retrieves data from the specified storage by key.\n   * @abstract\n   * @async\n   * @param {string} store The name/identifier of the storage location\n   * @param {string} key The key to retrieve\n   * @param {number} [timeout] Optional timeout in milliseconds for the operation\n   * @returns {Promise<*>} The stored value or null if not found\n   * @throws {Error} Must be implemented by subclasses\n   * @throws {Error} May throw on timeout or storage failure\n   * @example\n   * const preferences = await adapter.getFromStorage('userData', 'preferences', 2000); // 2 second timeout\n   */\n  async getFromStorage(store, key, timeout) {\n    throw new Error(\"Not implemented\");\n  }\n\n  // ----------------------------------------------------------------------------------------------\n  \n  /**\n   * Cleans up resources and subscriptions when the adapter is no longer needed.\n   * Should be called before discarding the adapter instance.\n   * @returns {void}\n   * @example\n   * adapter.destroy();\n   */\n  destroy() {\n    if (this._unsubscribe) {\n      logInfo(\"StoreAdapter - destroy - Unsubscribing from store changes.\");\n      this._unsubscribe();\n      this._unsubscribe = null;\n      return;\n    }\n    logInfo(\"StoreAdapter - destroy - No unsubscribe function to call.\");\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default StoreAdapter;\n\n// ------------------------------------------------------------------------------------------------","import StoreAdapter from \"./StoreAdapter.js\";\nimport assign from \"misc-helpers/src/utils/assign.js\";\nimport { logError, logWarn, logInfo } from \"../helpers/loggerHelper.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Pinia storage adapter that syncs Pinia store state with a persistence layer.\n * @class PiniaAdapter\n * @extends StoreAdapter\n * @example\n * // Basic usage with IndexedDB adapter:\n * const piniaAdapter = new PiniaAdapter(new IndexedDBAdapter({ dbName: 'my-app' }));\n * await piniaAdapter.setInStorage(useUserStore(), 'user-state');\n * await piniaAdapter.getFromStorage(useUserStore(), 'user-state');\n */\nclass PiniaAdapter extends StoreAdapter {\n  /**\n   * Creates a PiniaAdapter instance.\n   * @param {StoreAdapter} adapter The storage adapter to use for persistence (e.g., IndexedDBAdapter)\n   * @throws {Error} Throws if no adapter is provided\n   */\n  constructor(adapter) {\n    super();\n    if (!adapter) {\n      logError(\"Adapter provided is not defined\");\n      throw new Error(\"Adapter provided is not defined\");\n    }\n    this.adapter = adapter;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Validates that a Pinia store has the required methods.\n   * @private\n   * @param {Object} store Pinia store instance to validate\n   * @throws {Error} Throws if store is invalid or missing required methods\n   */\n  _checkStore(store) {\n    if (!store || !store.$subscribe || !store.$patch) {\n      logError(\"Store provided is not defined\");\n      throw new Error(\"Store provided is not defined\");\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Registers a listener on the adapter to respond to external data changes,\n   * ensuring the connected store is synchronized with updates that come\n   * from other sources (e.g., different tabs or windows).\n   *\n   * @private\n   * @param {Object} store - A reactive store (e.g., a Pinia) that will be updated when external changes occur.\n   */\n  _registerOnDataChanged(store) {\n    logInfo(\"PiniaAdapter - Registering onDataChanged listener\");\n    if (!store) {\n      return;\n    }\n    this.adapter.onDataChanged(async (data) => {\n      try {\n        if (data.adapterId == this.adapter.adapterId || !data.origin) {\n          return;\n        }\n\n        let dataToPatch;\n        if (!data.value) {\n          dataToPatch = await this.adapter.get(data.key);\n        } else {\n          dataToPatch = await this.adapter._decrypt(data.key, data.value);\n        }\n\n        if (JSON.stringify(store.$state) === JSON.stringify(dataToPatch)) {\n          return;\n        }\n\n        store.$state = {\n          ...store.$state,\n          ...dataToPatch,\n          STORAGEFY_SILENT_CHANNEL_UPDATE: true,\n        };\n      } catch (error) {\n        logError(\"PiniaAdapter - onDataChanged - error:\", error);\n      }\n    });\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Syncs Pinia store state to persistent storage and sets up subscription for future changes.\n   * @async\n   * @param {Object} store Pinia store instance\n   * @param {string} key Storage key to use\n   * @param {Object} [options={}] Configuration options\n   * @param {string[]} [options.ignoreKeys=[]] Keys to exclude from persistence\n   * @param {number} [options.timeout] Operation timeout in milliseconds\n   * @returns {Promise<boolean>} Resolves to true on success\n   * @throws {Error} Throws if store is invalid or persistence fails\n   * @example\n   * // Persist store while ignoring sensitive data\n   * await piniaAdapter.setInStorage(useUserStore(), 'user-data', {\n   *   ignoreKeys: ['password', 'token'],\n   *   timeout: 5000\n   * });\n   */\n  async setInStorage(store, key, options = {}) {\n    try {\n      logInfo(\"PiniaAdapter - setInStorage - key:\", key);\n      this._checkStore(store);\n      options.ignoreKeys = options.ignoreKeys || [];\n\n      // Clean up previous subscription if exists\n      if (this._unsubscribe) {\n        this._unsubscribe();\n      }\n\n      return new Promise((resolve, reject) => {\n        this._unsubscribe = store.$subscribe(async (mutation, state) => {\n          try {\n            if (!state) {\n              return resolve(true);\n            }\n            if (state.STORAGEFY_SILENT_CHANNEL_UPDATE) {\n              delete state.STORAGEFY_SILENT_CHANNEL_UPDATE;\n              return resolve(true);\n            }\n\n            const stateProps = { ...state };\n            for (let propKey in stateProps) {\n              if (options.ignoreKeys.includes(propKey)) {\n                stateProps[propKey] = undefined;\n              }\n            }\n\n            await this.adapter.set(key, stateProps, options.timeout);\n\n            return resolve(true);\n          } catch (error) {\n            return reject(error);\n          }\n        });\n\n        store.$patch({ ...store.$state });\n\n        if (options.syncTabs) {\n          this._registerOnDataChanged(store);\n        }\n      });\n    } catch (error) {\n      logError(error);\n      throw error;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Loads persisted state into a Pinia store.\n   * @async\n   * @param {Object} store Pinia store instance to hydrate\n   * @param {string} key Storage key to load from\n   * @returns {Promise<boolean>} Resolves to true on success, undefined if no data found\n   * @throws {Error} Throws if store is invalid or loading fails\n   * @example\n   * // Hydrate store from persisted state\n   * await piniaAdapter.getFromStorage(useUserStore(), 'user-data');\n   */\n  async getFromStorage(store, key) {\n    try {\n      logInfo(\"PiniaAdapter - getFromStorage - key:\", key);\n      this._checkStore(store);\n      const storage = await this.adapter.get(key);\n      if (!storage) {\n        return;\n      }\n\n      store.$patch(assign({}, storage));\n      return true;\n    } catch (error) {\n      logError(error);\n      throw error;\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default PiniaAdapter;\n\n// ------------------------------------------------------------------------------------------------\n","import StoreAdapter from \"./StoreAdapter.js\";\nimport assign from \"misc-helpers/src/utils/assign.js\";\nimport { logError, logWarn, logInfo } from \"../helpers/loggerHelper.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * React state persistence adapter that syncs React state management stores with a storage backend.\n * Supports Redux, Zustand, and other React state management libraries with compatible interfaces.\n * @class ReactAdapter\n * @extends StoreAdapter\n * @example\n * // Basic usage with Redux and IndexedDB\n * const reduxAdapter = new ReactAdapter(new IndexedDBAdapter({ dbName: 'app-state' }));\n * await reduxAdapter.setInStorage(store, 'redux-state');\n * await reduxAdapter.getFromStorage(store, 'redux-state');\n *\n * // Usage with Zustand\n * const zustandAdapter = new ReactAdapter(new LocalStorageAdapter());\n * await zustandAdapter.setInStorage(useStore, 'zustand-state');\n */\nclass ReactAdapter extends StoreAdapter {\n  /**\n   * Creates a ReactAdapter instance.\n   * @param {StoreAdapter} adapter The storage adapter to use for persistence (IndexedDB, LocalStorage, etc.)\n   * @throws {Error} Throws if no adapter is provided\n   */\n  constructor(adapter) {\n    super();\n    if (!adapter) {\n      logError(\"Adapter provided is not defined\");\n      throw new Error(\"Adapter provided is not defined\");\n    }\n    this.adapter = adapter;\n    this._unsubscribe = null;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  _getPayload(current, payload) {\n    return {\n      ...current,\n      ...payload,\n      STORAGEFY_SILENT_CHANNEL_UPDATE: true,\n    };\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Registers a listener on the adapter to respond to external data changes,\n   * ensuring the connected store is synchronized with updates that come\n   * from other sources (e.g., different tabs or windows).\n   *\n   * @private\n   * @param {Object} store - A reactive store (e.g., a Redux, Jotai, Zustand or Custom store) that will be updated when external changes occur.\n   */\n  _registerOnDataChanged(store) {\n    logInfo(\"ReactAdapter - Registering onDataChanged listener\");\n    if (!store) {\n      return;\n    }\n\n    this.adapter.onDataChanged(async (data) => {\n      try {\n        // Skip if the data change originated from this adapter or has no origin\n        if (data.adapterId == this.adapter.adapterId || !data.origin) {\n          return;\n        }\n\n        let dataToPatch;\n        if (!data.value) {\n          dataToPatch = await this.adapter.get(data.key);\n        } else {\n          dataToPatch = await this.adapter._decrypt(data.key, data.value);\n        }\n\n        // Redux store (has dispatch and getState methods)\n        if (\n          typeof store.dispatch === \"function\" &&\n          typeof store.getState === \"function\"\n        ) {\n          const currentState = store.getState();\n          if (JSON.stringify(currentState) === JSON.stringify(dataToPatch)) {\n            return;\n          }\n\n          store.dispatch({\n            type: \"STORAGEFY_UPDATE\",\n            payload: this._getPayload(currentState, dataToPatch),\n          });\n          return;\n        }\n\n        // Zustand store\n        if (\n          typeof store.getState === \"function\" &&\n          typeof store.setState === \"function\"\n        ) {\n          const currentState = store.getState();\n          if (JSON.stringify(currentState) === JSON.stringify(dataToPatch)) {\n            return;\n          }\n          store.setState(this._getPayload(currentState, dataToPatch));\n          return;\n        }\n\n        // JOTAI\n        if (\n          typeof store.set === \"function\" &&\n          typeof store.get === \"function\"\n        ) {\n          const currentState = store.get();\n          if (JSON.stringify(currentState) === JSON.stringify(dataToPatch)) {\n            return;\n          }\n\n          store.set(this._getPayload(currentState, dataToPatch));\n          return;\n        }\n\n        if (typeof store.update === \"function\") {\n          store.update((state) => {\n            if (JSON.stringify(state) === JSON.stringify(dataToPatch)) {\n              return state;\n            }\n            return this._getPayload(state, dataToPatch);\n          });\n          return;\n        }\n\n        // Last resort: try to find a method to update the store\n        const currentState =\n          typeof store.getState === \"function\"\n            ? store.getState()\n            : typeof store.get === \"function\"\n            ? store.get()\n            : {};\n\n        if (JSON.stringify(currentState) === JSON.stringify(dataToPatch)) {\n          return;\n        }\n\n        if (typeof store.set === \"function\") {\n          store.set(this._getPayload(currentState, dataToPatch));\n        } else {\n          logError(\"Unable to update store: No compatible update method found\");\n        }\n      } catch (error) {\n        logError(\"Error in _registerOnDataChanged:\", error);\n      }\n    });\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Syncs React store state to persistent storage and sets up subscription for future changes.\n   * Supports both Redux-style (getState/subscribe) and Zustand-style stores.\n   * @async\n   * @param {Object} store React state store instance (Redux, Zustand, etc.)\n   * @param {string} key Storage key to use\n   * @param {Object} [options={}] Configuration options\n   * @param {string[]} [options.ignoreKeys=[]] Keys to exclude from persistence\n   * @param {number} [options.timeout] Operation timeout in milliseconds\n   * @returns {Promise<boolean>} Resolves to true when subscription is established\n   * @throws {Error} Throws if store is invalid or unsupported\n   * @example\n   * // Persist Redux store while ignoring sensitive data\n   * await reactAdapter.setInStorage(reduxStore, 'user-state', {\n   *   ignoreKeys: ['authToken', 'password'],\n   *   timeout: 3000\n   * });\n   *\n   * // Persist Zustand store\n   * await reactAdapter.setInStorage(zustandStore, 'app-settings');\n   */\n  async setInStorage(store, key, options = {}) {\n    try {\n      logInfo(\"ReactAdapter - setInStorage - key:\", key);\n      this._checkStore(store);\n      options.ignoreKeys = options.ignoreKeys || [];\n\n      // Clean up previous subscription if exists\n      if (this._unsubscribe) {\n        this._unsubscribe();\n      }\n\n      return new Promise((resolve, reject) => {\n        const handleStateChange = async (state) => {\n          try {\n            if (!state) return;\n            if (state.STORAGEFY_SILENT_CHANNEL_UPDATE) {\n              delete state.STORAGEFY_SILENT_CHANNEL_UPDATE;\n              return resolve(true);\n            }\n\n            const stateProps = { ...state };\n            for (let propKey in stateProps) {\n              if (options.ignoreKeys.includes(propKey)) {\n                stateProps[propKey] = undefined;\n              }\n            }\n\n            await this.adapter.set(key, stateProps, options.timeout);\n          } catch (error) {\n            // Don't reject the main promise here - just log the error\n            logError(error);\n          }\n        };\n\n        // For Redux-style stores\n        if (\n          typeof store.subscribe === \"function\" &&\n          typeof store.getState === \"function\"\n        ) {\n          // Initial sync\n          handleStateChange(store.getState());\n\n          // Subscribe to changes\n          this._unsubscribe = store.subscribe(() => {\n            handleStateChange(store.getState());\n          });\n        }\n        // For Zustand/useState-style stores\n        else if (typeof store.subscribe === \"function\") {\n          this._unsubscribe = store.subscribe(handleStateChange);\n        } else {\n          reject(new Error(\"Unsupported store type\"));\n          return;\n        }\n\n        // Resolve immediately after subscription is set up\n        if (options.syncTabs) {\n          this._registerOnDataChanged(store);\n        }\n        resolve(true);\n      });\n    } catch (error) {\n      logError(error);\n      throw error;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Hydrates a React store from persistent storage.\n   * Supports both Redux (dispatch) and Zustand (setState) update patterns.\n   * @async\n   * @param {Object} store React state store instance to hydrate\n   * @param {string} key Storage key to load from\n   * @returns {Promise<boolean>} Resolves to true on success, undefined if no data found\n   * @throws {Error} Throws if store is invalid or update fails\n   * @example\n   * // Hydrate Redux store\n   * await reactAdapter.getFromStorage(reduxStore, 'user-state');\n   *\n   * // Hydrate Zustand store\n   * await reactAdapter.getFromStorage(zustandStore, 'app-settings');\n   */\n  async getFromStorage(store, key) {\n    try {\n      logInfo(\"ReactAdapter - getFromStorage - key:\", key);\n      this._checkStore(store);\n      const storage = await this.adapter.get(key);\n      if (!storage) {\n        return;\n      }\n\n      // Handle different React state management libraries\n      if (typeof store.dispatch === \"function\") {\n        // For Redux, dispatch an action to update state\n        store.dispatch({\n          type: \"SET_STATE_FROM_STORAGE\",\n          payload: storage,\n        });\n      } else if (typeof store.setState === \"function\") {\n        // For Zustand or custom React hook store\n        store.setState(assign({}, storage));\n      } else {\n        throw new Error(\n          \"Cannot update store: setState or dispatch method not found\"\n        );\n      }\n\n      return true;\n    } catch (error) {\n      logError(error);\n      throw error;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Validates that a store has the required interface methods.\n   * @private\n   * @param {Object} store Store instance to validate\n   * @throws {Error} Throws if store is invalid or missing required methods\n   */\n  _checkStore(store) {\n    if (!store) {\n      logError(\"Store provided is not defined\");\n      throw new Error(\"Store provided is not defined\");\n    }\n\n    // Check if it's a Redux store\n    if (\n      typeof store.getState === \"function\" &&\n      typeof store.dispatch === \"function\" &&\n      typeof store.subscribe === \"function\"\n    ) {\n      // Valid Redux store, no further checks needed\n      return;\n    }\n\n    // Check if it's a Zustand store\n    if (\n      typeof store.getState === \"function\" &&\n      typeof store.setState === \"function\" &&\n      typeof store.subscribe === \"function\"\n    ) {\n      // Valid Zustand store, no further checks needed\n      return;\n    }\n\n    // Check if it's a Jotai atom\n    console.log(\"STORE>>\", store);\n    if (\n      Array.isArray(store) &&\n      store.length === 2 &&\n      typeof store[0] === \"function\" &&\n      typeof store[1] === \"function\"\n    ) {\n      // Valid Jotai atom pair (getter/setter), no further checks needed\n      return;\n    }\n\n    // Check for custom store with minimum required methods\n    const hasGetState =\n      typeof store.getState === \"function\" ||\n      typeof store._getState === \"function\";\n    const hasSetState =\n      typeof store.setState === \"function\" ||\n      typeof store._setState === \"function\";\n    const hasSubscribe = typeof store.subscribe === \"function\";\n\n    if (!hasSubscribe) {\n      logError(\"Store must have a subscribe method\");\n      throw new Error(\"Store must have a subscribe method\");\n    }\n\n    if (!hasGetState && !hasSetState) {\n      logError(\n        \"Store must have either getState/setState or _getState/_setState methods\"\n      );\n      throw new Error(\n        \"Store must have either getState/setState or _getState/_setState methods\"\n      );\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default ReactAdapter;\n\n// ------------------------------------------------------------------------------------------------\n","import StoreAdapter from \"./StoreAdapter.js\";\nimport assign from \"misc-helpers/src/utils/assign.js\";\nimport { logError, logInfo, logWarn } from \"../helpers/loggerHelper.js\";\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Svelte store adapter that syncs Svelte writable stores with persistent storage.\n * Provides seamless integration between Svelte's store contract and various storage backends.\n * @class SvelteAdapter\n * @extends StoreAdapter\n * @example\n * // Basic usage with a Svelte writable store\n * import { writable } from 'svelte/store';\n * import { IndexedDBAdapter } from 'storagefy';\n *\n * const userStore = writable({});\n * const svelteAdapter = new SvelteAdapter(new IndexedDBAdapter({ dbName: 'svelte-app' }));\n *\n * // Persist store state\n * await svelteAdapter.setInStorage(userStore, 'user-data');\n *\n * // Hydrate store from storage\n * await svelteAdapter.getFromStorage(userStore, 'user-data');\n */\nclass SvelteAdapter extends StoreAdapter {\n  /**\n   * Creates a SvelteAdapter instance.\n   * @param {StoreAdapter} adapter The storage adapter to use for persistence (IndexedDB, LocalStorage, etc.)\n   * @throws {Error} Throws if no adapter is provided\n   */\n  constructor(adapter) {\n    super();\n    if (!adapter) {\n      logError(\"Adapter provided is not defined\");\n      throw new Error(\"Adapter provided is not defined\");\n    }\n    this.adapter = adapter;\n    this._unsubscribe = null;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Registers a listener on the adapter to respond to external data changes,\n   * ensuring the connected store is synchronized with updates that come\n   * from other sources (e.g., different tabs or windows).\n   *\n   * @private\n   * @param {Object} store - A reactive store (e.g., a Svelte store) that will be updated when external changes occur.\n   */\n  _registerOnDataChanged(store) {\n    logInfo(\"SvelteAdapter - Registering onDataChanged listener\");\n    try {\n      if (!store) {\n        return;\n      }\n      this.adapter.onDataChanged(async (data) => {\n        if (data.adapterId == this.adapter.adapterId || !data.origin) {\n          return;\n        }\n\n        let currentState;\n        const unsubscribe = store.subscribe((value) => {\n          currentState = assign({}, value);\n        });\n        unsubscribe();\n\n        let dataToPatch;\n        if (!data.value) {\n          dataToPatch = await this.adapter.get(data.key);\n        } else {\n          dataToPatch = await this.adapter._decrypt(data.key, data.value);\n        }\n        if (JSON.stringify(currentState) === JSON.stringify(dataToPatch)) {\n          return;\n        }\n\n        // Update store with the patched data\n        // In Svelte, we update the store directly\n        store.update((currentState) => ({\n          ...currentState,\n          ...dataToPatch,\n          STORAGEFY_SILENT_CHANNEL_UPDATE: true,\n        }));\n      });\n    } catch (error) {\n      logError(\"SvelteAdapter - onDataChanged error:\", error);\n      throw error;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Syncs a Svelte store to persistent storage and sets up subscription for future changes.\n   * @async\n   * @param {Object} store Svelte writable store instance\n   * @param {string} key Storage key to use\n   * @param {Object} [options={}] Configuration options\n   * @param {string[]} [options.ignoreKeys=[]] Keys to exclude from persistence\n   * @param {number} [options.timeout] Operation timeout in milliseconds\n   * @returns {Promise<boolean>} Resolves to true when initial sync completes\n   * @throws {Error} Throws if store is invalid or persistence fails\n   * @example\n   * // Persist store while ignoring sensitive fields\n   * await svelteAdapter.setInStorage(userStore, 'user-profile', {\n   *   ignoreKeys: ['password', 'token'],\n   *   timeout: 2000\n   * });\n   */\n  async setInStorage(store, key, options = {}) {\n    try {\n      logInfo(\"SvelteAdapter - setInStorage - key:\", key);\n      this._checkStore(store);\n      options.ignoreKeys = options.ignoreKeys || [];\n\n      // Clean up previous subscription if exists\n      if (this._unsubscribe) {\n        this._unsubscribe();\n      }\n\n      return new Promise((resolve, reject) => {\n        const unsubscribe = store.subscribe(async (state) => {\n          try {\n            if (!state) {\n              return resolve(true);\n            }\n\n            const stateProps = { ...state };\n            for (let propKey in stateProps) {\n              if (options.ignoreKeys.includes(propKey)) {\n                stateProps[propKey] = undefined;\n              }\n            }\n\n            await this.adapter.set(key, stateProps, options.timeout);\n            return resolve(true);\n          } catch (error) {\n            return reject(error);\n          }\n        });\n\n        this._unsubscribe = unsubscribe;\n\n        if (options.syncTabs) {\n          this._registerOnDataChanged(store);\n        }\n      });\n    } catch (error) {\n      logError(error);\n      throw error;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Hydrates a Svelte store from persistent storage.\n   * @async\n   * @param {Object} store Svelte writable store instance to hydrate\n   * @param {string} key Storage key to load from\n   * @returns {Promise<boolean>} Resolves to true on success, undefined if no data found\n   * @throws {Error} Throws if store is invalid or update fails\n   * @example\n   * // Load persisted state into store\n   * await svelteAdapter.getFromStorage(userStore, 'user-profile');\n   */\n  async getFromStorage(store, key) {\n    try {\n      logInfo(\"SvelteAdapter - getFromStorage - key:\", key);\n      this._checkStore(store);\n      const storage = await this.adapter.get(key);\n      if (!storage) {\n        return;\n      }\n      store.set(assign({}, storage));\n      return true;\n    } catch (error) {\n      logError(error);\n      throw error;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Validates that a store conforms to Svelte's writable store contract.\n   * @private\n   * @param {Object} store Store instance to validate\n   * @throws {Error} Throws if store doesn't have required subscribe and set methods\n   */\n  _checkStore(store) {\n    if (\n      !store ||\n      typeof store.subscribe !== \"function\" ||\n      typeof store.set !== \"function\"\n    ) {\n      logError(\"Store provided is not a valid Svelte writable store\");\n      throw new Error(\"Store provided is not a valid Svelte writable store\");\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nexport default SvelteAdapter;\n\n// ------------------------------------------------------------------------------------------------\n","import IndexedDBAdapter from \"./adapters/IndexedDBAdapter.js\";\nimport LocalStorageAdapter from \"./adapters/LocalStorageAdapter.js\";\nimport SessionStorageAdapter from \"./adapters/SessionStorageAdapter.js\";\nimport PiniaAdapter from \"./stores/PiniaAdapter.js\";\nimport ReactAdapter from \"./stores/ReactAdapter.js\";\nimport SvelteAdapter from \"./stores/SvelteAdapter.js\";\n\n// ------------------------------------------------------------------------------------------------\n// Constants and Configuration\n// ------------------------------------------------------------------------------------------------\n\nconst DEFAULT_CONFIG = {\n  dbName: \"storagefy\",\n  storeName: \"storagefy_db\",\n  version: 1,\n  encrypt: false,\n  expireCheckInterval: 1000,\n  description: \"Storagefy database\",\n  adapter: \"indexedDB\"\n};\n\n// ------------------------------------------------------------------------------------------------\n// Storage Management\n// ------------------------------------------------------------------------------------------------\n\nlet storageAdapter;\nlet piniaAdapter;\nlet reactAdapter;\nlet svelteAdapter;\n\n/**\n * Initializes and returns a storage adapter instance.\n * @param {Object} config Configuration options\n * @param {string} [config.dbName=\"storagefy\"] Database name\n * @param {string} [config.storeName=\"storagefy_db\"] Store name\n * @param {number} [config.version=1] Database version\n * @param {boolean} [config.encrypt=false] Enable encryption\n * @param {string|boolean} [config.channelName=false] Channel name for storage communication between tabs\n * @param {number} [config.expireCheckInterval=1000] Expiration check interval\n * @param {string} [config.description=\"Storagefy database\"] Database description\n * @param {boolean} [config.forceRecreate=false] Force recreation of adapter\n * @param {boolean} [config.fresh=false] Force creation of new adapter and return a new instance - does not re-use existing adapter or update it\n * @param {\"indexedDB\"|\"localStorage\"|\"sessionStorage\"} [config.adapter=\"indexedDB\"] Storage adapter type\n * @returns {IndexedDBAdapter|LocalStorageAdapter|SessionStorageAdapter} Storage adapter instance\n * @throws {Error} If adapter initialization fails\n * @example\n * // Basic usage\n * const adapter = startStoragefy({ dbName: 'my-app' });\n * \n * // With encryption\n * const secureAdapter = startStoragefy({\n *   dbName: 'secure-app',\n *   encrypt: true,\n *   password: 'my-secret-password'\n * });\n */\nfunction startStoragefy(config = {}) {\n  const params = { ...DEFAULT_CONFIG, ...config };\n\n  if (!config.forceRecreate && storageAdapter) {\n    return storageAdapter;\n  }\n\n  switch (params.adapter) {\n    case \"localStorage\":\n      if (config.fresh) {\n        return new LocalStorageAdapter(params);\n      }\n      storageAdapter = new LocalStorageAdapter(params);\n      break;\n    case \"sessionStorage\":\n      if (config.fresh) {\n        return new SessionStorageAdapter(params);\n      }\n      storageAdapter = new SessionStorageAdapter(params);\n      break;\n    default:\n      if (config.fresh) {\n        return new IndexedDBAdapter(params);\n      }\n      storageAdapter = new IndexedDBAdapter(params);\n  }\n\n  return storageAdapter;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Retrieves the current storage adapter instance.\n * @returns {IndexedDBAdapter|LocalStorageAdapter|SessionStorageAdapter} Storage adapter instance\n * @throws {Error} If adapter is not initialized\n */\nfunction getStorageAdapter() {\n  if (!storageAdapter) {\n    throw new Error(\"Storage adapter not initialized. Call startStoragefy first.\");\n  }\n  return storageAdapter;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Framework Adapter Factories\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Creates or retrieves a framework-specific adapter with consistent interface.\n * @private\n * @param {Object} options Options for adapter creation\n * @param {Object} [options.adapter] Pre-configured storage adapter\n * @param {Object} [options.adapterParams] Parameters to create new storage adapter\n * @param {boolean} [options.forceRecreate=false] Force recreation of adapter\n * @param {Object} cachedAdapter Reference to cached adapter\n * @param {Function} AdapterClass Class to instantiate\n * @returns {Object} Framework adapter instance\n */\nfunction _getFrameworkAdapter({ adapter, adapterParams, forceRecreate }, cachedAdapter, AdapterClass) {\n  if (adapter) {\n    return new AdapterClass(adapter);\n  }\n\n  if (cachedAdapter && !forceRecreate) {\n    return cachedAdapter;\n  }\n\n  if (adapterParams) {\n    const storageAdapter = _createStorageAdapter(adapterParams);\n    return new AdapterClass(storageAdapter);\n  }\n\n  if (!storageAdapter) {\n    throw new Error(\"Storage adapter not initialized. Call startStoragefy first.\");\n  }\n\n  return new AdapterClass(storageAdapter);\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Creates a storage adapter based on parameters.\n * @private\n * @param {Object} params Adapter parameters\n * @returns {IndexedDBAdapter|LocalStorageAdapter|SessionStorageAdapter} Storage adapter\n */\nfunction _createStorageAdapter(params) {\n  switch (params.adapter) {\n    case \"localStorage\":\n      return new LocalStorageAdapter(params);\n    case \"sessionStorage\":\n      return new SessionStorageAdapter(params);\n    default:\n      return new IndexedDBAdapter(params);\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Gets a Pinia store adapter instance.\n * @param {Object} options Configuration options\n * @param {Object} [options.adapter] Pre-configured storage adapter\n * @param {Object} [options.adapterParams] Parameters to create new storage adapter\n * @param {boolean} [options.forceRecreate=false] Force recreation of adapter\n * @param {boolean} [options.fresh=false] Force creation of new adapter and return a new instance - does not re-use existing adapter or update it\n * @returns {{setInStorage: Function, getFromStorage: Function}} Pinia adapter methods\n * @throws {Error} If adapter cannot be created\n */\nfunction getPiniaAdapter({ adapter = null, adapterParams = null, forceRecreate = false, fresh = false } = {}) {\n  if (fresh) {\n    return _getFrameworkAdapter({ adapter, adapterParams, forceRecreate }, null, PiniaAdapter);\n  }\n  piniaAdapter = _getFrameworkAdapter(\n    { adapter, adapterParams, forceRecreate },\n    piniaAdapter,\n    PiniaAdapter\n  );\n  return {\n    setInStorage: piniaAdapter.setInStorage.bind(piniaAdapter),\n    getFromStorage: piniaAdapter.getFromStorage.bind(piniaAdapter)\n  };\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Gets a React store adapter instance.\n * @param {Object} options Configuration options\n * @param {Object} [options.adapter] Pre-configured storage adapter\n * @param {Object} [options.adapterParams] Parameters to create new storage adapter\n * @param {boolean} [options.forceRecreate=false] Force recreation of adapter\n * @param {boolean} [options.fresh=false] Force creation of new adapter and return a new instance - does not re-use existing adapter or update it\n * @returns {ReactAdapter} React adapter instance\n * @throws {Error} If adapter cannot be created\n */\nfunction getReactAdapter({ adapter = null, adapterParams = null, forceRecreate = false, fresh = false } = {}) {\n  if (fresh) {\n    return _getFrameworkAdapter({ adapter, adapterParams, forceRecreate }, null, ReactAdapter);\n  }\n  reactAdapter = _getFrameworkAdapter(\n    { adapter, adapterParams, forceRecreate },\n    reactAdapter,\n    ReactAdapter\n  );\n  return reactAdapter;\n}\n\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Gets a Svelte store adapter instance.\n * @param {Object} options Configuration options\n * @param {Object} [options.adapter] Pre-configured storage adapter\n * @param {Object} [options.adapterParams] Parameters to create new storage adapter\n * @param {boolean} [options.forceRecreate=false] Force recreation of adapter\n * @param {boolean} [options.fresh=false] Force creation of new adapter and return a new instance - does not re-use existing adapter or update it\n * @returns {SvelteAdapter} Svelte adapter instance\n * @throws {Error} If adapter cannot be created\n */\nfunction getSvelteAdapter({ adapter = null, adapterParams = null, forceRecreate = false, fresh = false } = {}) {\n  if (fresh) {\n    return _getFrameworkAdapter({ adapter, adapterParams, forceRecreate }, null, SvelteAdapter);\n  }\n  svelteAdapter = _getFrameworkAdapter(\n    { adapter, adapterParams, forceRecreate },\n    svelteAdapter,\n    SvelteAdapter\n  );\n  return svelteAdapter;\n}\n\n// ------------------------------------------------------------------------------------------------\n\nasync function setPiniaStorage(store, key, options = {}) {\n  try {\n    if (!piniaAdapter) {\n      getPiniaAdapter();\n    }\n    if (!store) {\n      throw new Error(\"Store is required.\");\n    }\n    if (!key) {\n      throw new Error(\"Key is required.\");\n    }\n    await piniaAdapter.getFromStorage(store, key);\n    await piniaAdapter.setInStorage(store, key, options);\n  } catch (error) {\n    logError(error);\n    throw error;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nasync function setReactStorage(store, key, options = {}) {\n  try {\n    if (!reactAdapter) {\n      getReactAdapter();\n    }\n    if (!store) {\n      throw new Error(\"Store is required.\");\n    }\n    if (!key) {\n      throw new Error(\"Key is required.\");\n    }\n    await reactAdapter.getFromStorage(store, key);\n    await reactAdapter.setInStorage(store, key, options);\n  } catch (error) {\n    logError(error);\n    throw error;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n\nasync function setSvelteStorage(store, key, options = {}) {\n  try {\n    if (!svelteAdapter) {\n      getSvelteAdapter();\n    }\n    if (!store) {\n      throw new Error(\"Store is required.\");\n    }\n    if (!key) {\n      throw new Error(\"Key is required.\");\n    }\n    await svelteAdapter.getFromStorage(store, key);\n    await svelteAdapter.setInStorage(store, key, options);\n  } catch (error) {\n    logError(error);\n    throw error;\n  }\n}\n\n// ------------------------------------------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------------------------------------------\n\nexport {\n  // Storage adapters\n  IndexedDBAdapter,\n  LocalStorageAdapter,\n  SessionStorageAdapter,\n  // Framework adapters\n  PiniaAdapter,\n  ReactAdapter,\n  SvelteAdapter,\n  // Utility functions\n  startStoragefy,\n  getStorageAdapter,\n  getPiniaAdapter,\n  getReactAdapter,\n  getSvelteAdapter,\n  setPiniaStorage,\n  setReactStorage,\n  setSvelteStorage,\n};\n"],"mappings":"AAKA,WAAW,eAAiB,GAc5B,WAAW,oBAAsB,EAS1B,IAAMA,EAAW,IAAIC,IAAS,CAC/B,WAAW,gBAAkB,WAAW,qBAAuB,IACjEA,EAAK,QAAQ,kBAAkB,EAC/B,QAAQ,MAAM,GAAGA,CAAI,EAEzB,EASaC,EAAU,IAAID,IAAS,CAC9B,WAAW,gBAAkB,WAAW,qBAAuB,IACjEA,EAAK,QAAQ,iBAAiB,EAC9B,QAAQ,KAAK,GAAGA,CAAI,EAExB,EASaE,EAAU,IAAIF,IAAS,CAC9B,WAAW,gBAAkB,WAAW,qBAAuB,IACjEA,EAAK,QAAQ,YAAY,EACzB,QAAQ,KAAK,GAAGA,CAAI,EAExB,EC5DA,OAAOG,MAAc,qCACrB,OAAOC,MAAgB,uCAIvB,IAAMC,EAAU,IAAI,YACdC,EAAU,IAAI,YAIhBC,EACAC,EAOJ,SAASC,GAAY,CAnBrB,IAAAC,EAoBE,GAAI,CAGF,GAFAC,EAAQ,uDAAuD,EAE3D,OAAO,OAAW,KAAe,OAAO,OAAQ,CAClDJ,EAAS,OAAO,OAChBC,EAASD,EAAO,OAChBI,EAAQ,sDAAsD,EAC9D,MACF,CAEA,GAAI,OAAO,OAAW,MAChBD,EAAA,OAAO,SAAP,MAAAA,EAAe,UAAW,CAC5BH,EAAS,OAAO,OAAO,UACvBC,EAASD,EAAO,OAChBI,EAAQ,yDAAyD,EACjE,MACF,CAGF,MAAM,IAAI,MAAM,0BAA0B,CAC5C,OAASC,EAAO,CACd,MAAAC,EAAS,+BAAgCD,CAAK,EACxCA,CACR,CACF,CAEA,GAAI,CACFH,EAAU,CACZ,OAASG,EAAO,CACdC,EAAS,+BAAgCD,CAAK,CAChD,CAUA,IAAME,EAAsB,MAAOC,GAAa,CAC9C,GAAI,CACF,OAAAJ,EAAQ,sDAAsD,EACvDH,EAAO,UAAU,MAAOH,EAAQ,OAAOU,CAAQ,EAAG,SAAU,GAAO,CACxE,WACF,CAAC,CACH,OAASH,EAAO,CACd,MAAAC,EAAS,iCAAkCD,CAAK,EAC1CA,CACR,CACF,EAWaI,EAAY,MAAOD,EAAUE,EAAMC,EAAc,KAAU,CACtE,GAAI,CACF,GAAI,OAAOH,GAAa,UAAY,CAACA,EAAS,OAC5C,MAAM,IAAI,MAAM,kBAAkB,EAEpCJ,EAAQ,0CAA2C,CACjD,eAAgBI,EAAS,OACzB,YAAAG,CACF,CAAC,EACD,IAAMC,EAAc,MAAML,EAAoBC,CAAQ,EACtD,OAAOP,EAAO,UACZ,CACE,KAAM,SACN,KAAMH,EAAQ,OAAOY,CAAI,EACzB,WAAY,IACZ,KAAM,SACR,EACAE,EACA,CAAE,KAAM,UAAW,OAAQ,GAAI,EAC/BD,EACA,CAAC,UAAW,SAAS,CACvB,CACF,OAASN,EAAO,CACd,MAAAC,EAAS,sBAAuBD,CAAK,EAC/BA,CACR,CACF,EAWaQ,EAAc,MAAOC,EAAKC,EAASC,EAAM,KAAU,CAC9D,GACED,IAAY,QACZ,OAAOA,GAAY,YACnB,OAAOA,GAAY,SAEnB,MAAM,IAAI,MAAM,kCAAkC,EAGpD,GAAI,CACFX,EAAQ,iCAAkC,CAAE,IAAAY,CAAI,CAAC,EACjD,IAAMC,EAAKjB,EAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,EAC9CkB,EAAUpB,EAAQ,OAAO,KAAK,UAAUiB,CAAO,CAAC,EAChDI,EAAY,MAAMlB,EAAO,QAC7B,CAAE,KAAM,UAAW,GAAAgB,CAAG,EACtBH,EACAI,CACF,EAEA,GAAIF,EACF,MAAO,CAAE,GAAAC,EAAI,KAAM,IAAI,WAAWE,CAAS,CAAE,EAG/C,IAAMC,EAAWxB,EAAS,OAAO,aAAa,GAAGqB,CAAE,CAAC,EAC9CI,EAAkBzB,EACtB,OAAO,aAAa,GAAG,IAAI,WAAWuB,CAAS,CAAC,CAClD,EAEA,MAAO,CAAE,GAAIC,EAAU,KAAMC,CAAgB,CAC/C,OAAShB,EAAO,CACd,MAAAC,EAAS,yBAA0BD,CAAK,EAClCA,CACR,CACF,EAWaiB,EAAc,MAAOR,EAAKS,EAAcP,EAAM,KAAU,CACnE,IAAIC,EAAIE,EAER,GAAI,CAGF,GAFAf,EAAQ,iCAAkC,CAAE,IAAAY,CAAI,CAAC,EAE7CA,EACFC,EAAK,IAAI,WAAWM,EAAa,EAAE,EACnCJ,EAAY,IAAI,WAAWI,EAAa,IAAI,MACvC,CACL,IAAMC,EAAgBC,GACpB,IAAI,WACF5B,EAAW4B,CAAG,EACX,MAAM,EAAE,EACR,IAAKC,GAASA,EAAK,WAAW,CAAC,CAAC,CACrC,EACFT,EAAKO,EAAaD,EAAa,EAAE,EACjCJ,EAAYK,EAAaD,EAAa,IAAI,CAC5C,CAEA,IAAMI,EAAY,MAAM1B,EAAO,QAC7B,CAAE,KAAM,UAAW,GAAAgB,CAAG,EACtBH,EACAK,CACF,EAEA,OAAO,KAAK,MAAMpB,EAAQ,OAAO4B,CAAS,CAAC,CAC7C,OAAStB,EAAO,CACd,MAAAC,EAAS,yBAA0BD,CAAK,EAClCA,CACR,CACF,EA0CO,SAASuB,EAAgBC,EAAK,CACnC,GAAI,CAACA,EAAK,OAAOA,EAEjBC,EAAQ,mCAAmC,EAE3C,GAAI,CAEF,IAAMC,EAAU,CAAC,GAAGF,CAAG,EACpB,IAAKG,GAAS,OAAO,aAAaA,EAAK,WAAW,CAAC,EAAI,CAAC,CAAC,EACzD,KAAK,EAAE,EAGV,OAAOC,EAASF,CAAO,CACzB,MAAgB,CACd,OAAOF,CACT,CACF,CAaO,SAASK,EAAkBL,EAAK,CACrC,GAAI,CAACA,EAAK,OAAOA,EAEjBC,EAAQ,qCAAqC,EAE7C,GAAI,CAKF,MAAO,CAAC,GAHQK,EAAWN,CAAG,CAGZ,EACf,IAAKG,GAAS,OAAO,aAAaA,EAAK,WAAW,CAAC,EAAI,CAAC,CAAC,EACzD,KAAK,EAAE,CACZ,MAAgB,CACd,OAAOH,CACT,CACF,CCvRA,OAAOO,OAAsB,6CAY7B,IAAMC,EAAN,KAAsB,CAOpB,YAAYC,EAAa,CAEvB,GAAI,CACE,OAAOA,GAAgB,WACzBA,EAAcF,GAAiB,mBAAmB,GAEpD,KAAK,QAAU,IAAI,iBAAiBE,CAAW,EAC/C,KAAK,YAAcA,EACnBC,EAAQ,2CAA2CD,CAAW,GAAG,CACnE,OAASE,EAAO,CACd,MAAAC,EAAS,yCAA0CD,CAAK,EAClDA,CACR,CACF,CAUA,UAAUE,EAAU,CAClB,GAAI,OAAOA,GAAa,WAAY,CAClCC,EAAQ,iEAAiE,EACzE,MACF,CAEA,KAAK,QAAQ,UAAaC,GAAU,CAClCL,EAAQ,sCAAuCK,EAAM,IAAI,EACzD,GAAI,CACFF,EAASE,EAAM,IAAI,CACrB,OAASJ,EAAO,CACdC,EAAS,gDAAiDD,CAAK,CACjE,CACF,EAEAD,EAAQ,oDAAoD,CAC9D,CASA,KAAKM,EAAM,CACT,GAAI,CACF,KAAK,QAAQ,YAAYA,CAAI,EAC7BN,EAAQ,qCAAsCM,CAAI,CACpD,OAASL,EAAO,CACdC,EAAS,gDAAiDD,CAAK,CACjE,CACF,CAQA,OAAQ,CACN,GAAI,CACF,KAAK,QAAQ,MAAM,EACnBD,EAAQ,mCAAmC,CAC7C,OAASC,EAAO,CACdC,EAAS,gDAAiDD,CAAK,CACjE,CACF,CACF,EAIOM,EAAQT,EChFf,IAAMU,EAAN,KAAqB,CAOnB,YAAYC,EAAa,CAEnBA,GACFC,EAAQ,mDAAoDD,CAAW,EACvE,KAAK,YAAcA,EACnB,KAAK,QAAU,IAAIE,EAAgBF,CAAW,IAG9C,KAAK,QAAU,KACf,KAAK,YAAc,KACnBG,EACE,wEACF,EAEJ,CAWA,MAAM,IAAIC,EAAK,CACb,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAaA,MAAM,IAAIA,EAAKC,EAAOC,EAAQ,CAC5B,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAWA,MAAM,OAAOF,EAAK,CAChB,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAWA,MAAM,KAAKG,EAAS,GAAI,CACtB,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAUA,MAAM,OAAQ,CACZ,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAUA,MAAM,OAAQ,CACZ,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAUA,MAAM,aAAc,CAClB,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAYA,MAAM,UAAUH,EAAKI,EAAM,CACzB,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAWA,MAAM,aAAaJ,EAAK,CACtB,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAWA,MAAM,IAAIA,EAAK,CACb,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAUA,MAAM,SAASA,EAAKC,EAAO,CACzB,GAAI,CAAC,KAAK,SAAW,CAACD,EAAK,OAAOC,EAClC,GAAI,CACF,IAAMI,EAAO,MAAmBC,EAAUN,CAAG,EACvCO,EAAY,MAAmBC,EAAYH,EAAMJ,EAAO,EAAK,EACnE,OAAAJ,EACE,0DAA0DG,CAAG,IAC/D,EACO,KAAK,UAAUO,CAAS,CACjC,OAASE,EAAK,CACZ,OAAAC,EAAS,qBAAsBD,CAAG,EAC3B,IACT,CACF,CAUA,MAAM,SAAST,EAAKC,EAAO,CACzB,GAAI,CAAC,KAAK,SAAW,CAACD,EAAK,OAAO,KAAK,MAAMC,CAAK,EAClD,GAAI,CACF,IAAMI,EAAO,MAAmBC,EAAUN,CAAG,EACvCW,EAAe,KAAK,MAAMV,CAAK,EAC/BW,EAAY,MAAmBC,EACnCR,EACAM,EACA,EACF,EACA,OAAAd,EACE,0DAA0DG,CAAG,IAC/D,EACO,KAAK,MAAMY,CAAS,CAC7B,OAASH,EAAK,CACZ,OAAAC,EAAS,qBAAsBD,CAAG,EAC3B,IACT,CACF,CAUA,SAAST,EAAK,CACZ,IAAMc,EAAO,GAAG,KAAK,MAAM,GAAGd,CAAG,GACjC,GAAI,KAAK,QAAS,CAChB,IAAMe,EAA0BC,EAAgBF,CAAI,EACpD,OAAAjB,EAAQ,oCAAoCG,CAAG,SAASe,CAAU,IAAI,EAC/DA,CACT,CACA,OAAAlB,EAAQ,sCAAsCiB,CAAI,GAAG,EAC9CA,CACT,CAQA,qBAAsB,CAChB,KAAK,cAAc,cAAc,KAAK,YAAY,EAClD,OAAK,qBAAuB,KAGhC,KAAK,aAAe,YAAY,IAAM,CACpC,GAAI,CACFjB,EAAQ,gDAAgD,EACxD,KAAK,YAAY,CACnB,OAASY,EAAK,CACZC,EAAS,+BAAgCD,CAAG,CAC9C,CACF,EAAG,KAAK,mBAAmB,EAC3BZ,EACE,sDAAsD,KAAK,mBAAmB,IAChF,EACF,CAOA,SAAU,CACJ,KAAK,eACP,cAAc,KAAK,YAAY,EAC/B,KAAK,aAAe,KACpBA,EAAQ,0CAA0C,GAGhD,KAAK,iBACP,OAAO,oBAAoB,eAAgB,KAAK,cAAc,EAC9D,KAAK,eAAiB,KACtBA,EAAQ,0CAA0C,EAEtD,CASA,MAAM,OAAOoB,EAAW,CACtB,OAAApB,EAAQ,mDAAmDoB,CAAS,GAAG,EAChE,KAAK,KAAK,GAAGA,CAAS,IAAI,CACnC,CASA,MAAM,UAAUjB,EAAK,CACnB,GAAI,CACF,IAAMkB,EAAU,MAAM,KAAK,aAAa,EACxC,OAAArB,EACE,gDAAgDG,CAAG,KACnDkB,EAAQlB,CAAG,GAAK,IAClB,EACOkB,EAAQlB,CAAG,GAAK,IACzB,OAASS,EAAK,CACZ,OAAAC,EAAS,iCAAiCV,CAAG,KAAMS,CAAG,EAC/C,IACT,CACF,CAaA,eAAeT,EAAKC,EAAOkB,EAAQ,CAE7B,CAAC,KAAK,aAAe,CAACA,IAG1BtB,EACE,kDAAkDG,CAAG,kBAAkBmB,CAAM,GAC/E,EAEA,KAAK,QAAQ,KAAK,CAChB,UAAW,KAAK,UAChB,IAAAnB,EACA,MAAAC,EACA,OAAAkB,CACF,CAAC,EACH,CAeA,cAAcC,EAAU,CAElB,CAAC,KAAK,aAAe,OAAOA,GAAa,aAK7CvB,EAAQ,yDAAyD,EACjE,KAAK,QAAQ,UAAUuB,CAAQ,EACjC,CACF,EAIOC,EAAQ1B,EC/Vf,OAAO2B,OAAW,kCAClB,OAAOC,OAAsB,6CAW7B,IAAMC,EAAN,cAA+BC,CAAe,CAc5C,YAAY,CACV,OAAAC,EACA,UAAAC,EACA,QAAAC,EAAU,EACV,QAAAC,EAAU,GACV,oBAAAC,EAAsB,IACtB,YAAAC,EAAc,GACd,eAAAC,EAAiB,GACjB,YAAAC,EAAc,EAChB,EAAG,CAED,GADA,MAAMF,CAAW,EACb,OAAO,UAAc,IACvB,MAAAG,EAAS,gDAAgD,EACnD,IAAI,MAAM,gDAAgD,EAGlE,KAAK,QAAU,GACf,KAAK,OAASR,EACd,KAAK,UAAYC,GAAa,GAAGD,CAAM,SACvC,KAAK,QAAUG,EACf,KAAK,UAAY,SAASH,CAAM,YAChC,KAAK,QAAU,SAASA,CAAM,SAC9B,KAAK,OAAS,GAAGA,CAAM,KACvB,KAAK,UAAYS,GAAiBT,CAAM,EACxC,KAAK,eAAiBM,GAAkB,GACxC,KAAK,oBAAsBF,EAC3B,KAAK,UAAY,KACjB,KAAK,QAAQ,CAAE,OAAAJ,EAAQ,QAAAE,EAAS,YAAAK,CAAY,CAAC,EAC7C,KAAK,oBAAoB,EAEzB,KAAK,eAAiB,IAAM,KAAK,QAAQ,EACzC,OAAO,iBAAiB,eAAgB,KAAK,cAAc,EAE3DG,EACE,+CAA+CV,CAAM,gBAAgB,KAAK,SAAS,EACrF,CACF,CAaA,QAAQ,CAAE,OAAAA,EAAQ,QAAAE,EAAS,YAAAK,CAAY,EAAG,CACxCG,EACE,yDAAyDV,CAAM,gBAAgB,KAAK,SAAS,EAC/F,EACA,KAAK,UAAY,IAAI,QAAQ,CAACW,EAASC,IAAW,CAChD,IAAMC,EAAU,UAAU,KAAKb,EAAQE,CAAO,EAE9CW,EAAQ,gBAAmBC,GAAU,CACnC,IAAMC,EAAKD,EAAM,OAAO,OACnBC,EAAG,iBAAiB,SAAS,KAAK,SAAS,GAC9CA,EAAG,kBAAkB,KAAK,SAAS,EAIrC,IAAMC,EAAO,CACX,OAAAhB,EACA,QAAAE,EACA,YAAAK,EACA,UAAW,KAAK,IAAI,CACtB,EACoBO,EAAM,OAAO,YACP,YAAY,KAAK,SAAS,EAC9C,IAAI,KAAK,UAAUE,CAAI,EAAG,KAAK,OAAO,CAC9C,EAEAH,EAAQ,UAAaC,GAAU,CAC7B,IAAMC,EAAKD,EAAM,OAAO,OAGlBG,EADcF,EAAG,YAAY,KAAK,UAAW,WAAW,EACpC,YAAY,KAAK,SAAS,EAC9CG,EAAcD,EAAM,IAAI,KAAK,OAAO,EAC1CC,EAAY,UAAY,IAAM,CAC5B,GAAI,CAACA,EAAY,OAAQ,CACvB,IAAMF,EAAO,CACX,OAAAhB,EACA,QAAAE,EACA,YAAAK,EACA,UAAW,KAAK,IAAI,CACtB,EACAU,EAAM,IAAI,KAAK,UAAUD,CAAI,EAAG,KAAK,OAAO,CAC9C,CACA,KAAK,QAAU,GACfL,EAAQI,CAAE,CACZ,EACAG,EAAY,QAAWC,GAAQ,CAC7BX,EAAS,uBAAwBW,CAAG,EACpCR,EAAQI,CAAE,CACZ,CACF,EAEAF,EAAQ,QAAWC,GAAU,CAC3BN,EAAS,0BAA2BM,EAAM,OAAO,KAAK,EACtDF,EAAOE,EAAM,OAAO,KAAK,CAC3B,CACF,CAAC,CACH,CAYA,MAAM,cAAcM,EAAU,GAAIC,EAAQ,GAAI,CAC5C,OAAAX,EACE,mEAAmEU,CAAO,cAAcC,CAAK,EAC/F,EACO,IAAI,QAAQ,MAAOV,EAASC,IAAW,CAC5C,GAAI,CAEF,GADA,MAAMU,GAAMF,CAAO,EACf,KAAK,QACP,OAAAT,EAAQ,EACD,GAGT,IAAIY,EAAU,EACd,KAAO,CAAC,KAAK,SAAWA,IAAYF,GAClC,WAAW,IAAM,CACf,GAAI,KAAK,QACP,OAAAV,EAAQ,EACD,EAEX,EAAGS,CAAO,CAEd,OAASI,EAAO,CACd,OAAOZ,EAAOY,CAAK,CACrB,CAEAZ,EAAO,IAAI,MAAM,uBAAuB,CAAC,CAC3C,CAAC,CACH,CAaA,MAAM,WAAWa,EAAMC,EAAU,CAC/B,GAAI,CACFhB,EAAQ,6CAA6Ce,CAAI,OAAO,EAGhE,IAAMR,GAFK,MAAM,KAAK,WACC,YAAY,KAAK,UAAWQ,CAAI,EAC7B,YAAY,KAAK,SAAS,EACpD,OAAO,MAAMC,EAAST,CAAK,CAC7B,OAASE,EAAK,CACZ,MAAAX,EAAS,6BAA8BW,CAAG,EACpCA,CACR,CACF,CAUA,MAAM,cAAe,CACnB,OAAAT,EAAQ,kDAAkD,EACnD,KAAK,WAAW,WAAY,MAAOO,GACjC,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,IAAI,KAAK,SAAS,EACxCJ,EAAQ,UAAY,IAAM,CACxBF,EAAQE,EAAQ,OAAS,KAAK,MAAMA,EAAQ,MAAM,EAAI,CAAC,CAAC,CAC1D,EACAA,EAAQ,QAAU,IAAM,CACtBF,EAAQ,CAAC,CAAC,CACZ,CACF,CAAC,CACF,CACH,CAYA,MAAM,IAAIgB,EAAK,CACb,GAAI,CACFjB,EAAQ,mCAAmCiB,CAAG,EAAE,EAChD,IAAMC,EAAU,KAAK,SAASD,CAAG,EAC3BE,EAAM,MAAM,KAAK,WAAW,WAAaZ,GACtC,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,IAAIW,CAAO,EACjCf,EAAQ,UAAY,IAAMF,EAAQE,EAAQ,MAAM,EAChDA,EAAQ,QAAU,IAAMF,EAAQ,IAAI,CACtC,CAAC,CACF,EAED,GAAI,CAACkB,EAAK,OAAO,KAEjB,IAAMC,EAAU,MAAM,KAAK,UAAUH,CAAG,EACxC,OAAIG,GAAW,KAAK,IAAI,GAAKA,GAC3B,MAAM,KAAK,OAAOH,CAAG,EACd,MAGF,MAAM,KAAK,SAASA,EAAKE,CAAG,CACrC,OAASV,EAAK,CACZ,OAAAX,EAAS,sBAAsBmB,CAAG,KAAMR,CAAG,EACpC,IACT,CACF,CAcA,MAAM,IAAIQ,EAAKI,EAAOC,EAAQ,CAC5B,GAAI,CAEF,GADAtB,EAAQ,mCAAmCiB,CAAG,GAAI,CAAE,MAAAI,EAAO,OAAAC,CAAO,CAAC,EAC/D,CAACL,GAAO,CAACI,EACX,MAAO,GAET,IAAMH,EAAU,KAAK,SAASD,CAAG,EACjC,GAAIA,GAA+BI,GAAU,KAC3C,aAAM,KAAK,OAAOH,CAAO,EAClB,KAETG,EAAQ,KAAK,UAAUA,CAAK,EAE5B,IAAME,EAAY,MAAM,KAAK,SAASN,EAAKI,CAAK,EAChD,OAAKE,GAEL,MAAM,KAAK,WAAW,YAAchB,GAC3B,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,IAAIgB,EAAWL,CAAO,EAC5Cf,EAAQ,UAAY,IAAM,CACpB,KAAK,gBACP,KAAK,eAAec,EAAK,OAAW,OAAO,EAE7ChB,EAAQ,EAAI,CACd,EACAE,EAAQ,QAAU,IAAMF,EAAQ,EAAK,CACvC,CAAC,CACF,EAEG,OAAOqB,GAAW,UACpB,MAAM,KAAK,aAAaL,CAAG,EACpB,IAGLK,EAAS,GACX,MAAM,KAAK,UAAUL,EAAK,KAAK,IAAI,EAAIK,CAAM,EACtC,KAGT,MAAM,KAAK,OAAOL,CAAG,EACd,OA1BgB,EA2BzB,OAASR,EAAK,CACZ,OAAAX,EAAS,sBAAsBmB,CAAG,KAAMR,CAAG,EACpC,EACT,CACF,CAYA,MAAM,OAAOQ,EAAK,CAChB,GAAI,CACFjB,EAAQ,oCAAoCiB,CAAG,EAAE,EACjD,IAAMC,EAAU,KAAK,SAASD,CAAG,EACjC,MAAM,KAAK,WAAW,YAAcV,GAC3B,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,OAAOW,CAAO,EACpCf,EAAQ,UAAY,IAAM,CACpB,KAAK,gBACP,KAAK,eAAec,EAAK,OAAW,OAAO,EAE7ChB,EAAQ,EAAI,CACd,EACAE,EAAQ,QAAU,IAAMF,EAAQ,CAClC,CAAC,CACF,EAED,IAAMuB,EAAM,MAAM,KAAK,aAAa,EACpC,OAAOA,EAAIP,CAAG,EACd,MAAM,KAAK,WAAW,YAAcV,GAC3B,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,IAAI,KAAK,UAAUiB,CAAG,EAAG,KAAK,SAAS,EAC7DrB,EAAQ,UAAY,IAAMF,EAAQ,EAClCE,EAAQ,QAAU,IAAMF,EAAQ,CAClC,CAAC,CACF,CACH,OAASQ,EAAK,CACZX,EAAS,uBAAuBmB,CAAG,KAAMR,CAAG,CAC9C,CACF,CAWA,MAAM,MAAO,CACX,IAAMgB,EAAU,CAAC,EACjB,GAAI,CACFzB,EAAQ,gDAAgD,KAAK,MAAM,EAAE,EACrE,MAAM,KAAK,WAAW,WAAY,MAAOO,GAChC,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,WAAW,EACjCJ,EAAQ,UAAY,SAAY,CAC9B,IAAMuB,EAAOvB,EAAQ,QAAU,CAAC,EAChC,QAASwB,KAAKD,EAIZ,GAHI,KAAK,UACPC,EAAIC,EAAkBD,CAAC,GAErB,EAAAA,IAAM,KAAK,SAAWA,IAAM,KAAK,YACjCA,EAAE,WAAW,KAAK,MAAM,EAAG,CAC7B,IAAMN,EAAQ,MAAM,KAAK,IAAIM,EAAE,QAAQ,KAAK,OAAQ,EAAE,CAAC,EACnDN,IAAU,MACZI,EAAQ,KAAK,CAAE,IAAKE,EAAE,QAAQ,KAAK,OAAQ,EAAE,EAAG,MAAAN,CAAM,CAAC,CAE3D,CAEFpB,EAAQ,CACV,EACAE,EAAQ,QAAU,IAAMF,EAAQ,CAClC,CAAC,CACF,CACH,OAASQ,EAAK,CACZX,EAAS,sBAAuBW,CAAG,CACrC,CACA,OAAOgB,CACT,CAYA,MAAM,IAAIR,EAAK,CACb,GAAI,CACFjB,EAAQ,iDAAiDiB,CAAG,EAAE,EAC9D,IAAMC,EAAU,KAAK,SAASD,CAAG,EACjC,OAAO,MAAM,KAAK,WAAW,WAAaV,GACjC,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,OAAOW,CAAO,EACpCf,EAAQ,UAAY,IAAMF,EAAQE,EAAQ,SAAW,MAAS,EAC9DA,EAAQ,QAAU,IAAMF,EAAQ,EAAK,CACvC,CAAC,CACF,CACH,OAASQ,EAAK,CACZ,OAAAX,EAAS,uBAAuBmB,CAAG,KAAMR,CAAG,EACrC,EACT,CACF,CAWA,MAAM,OAAQ,CACZ,GAAI,CACFT,EAAQ,sCAAsC,EAC9C,MAAM,KAAK,MAAM,EACjB,MAAM,KAAK,WAAW,YAAcO,GAC3B,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,OAAO,KAAK,OAAO,EACzCJ,EAAQ,UAAY,IAAM,CACxB,IAAM0B,EAAWtB,EAAM,OAAO,KAAK,SAAS,EAC5CsB,EAAS,UAAY,IAAM5B,EAAQ,EACnC4B,EAAS,QAAU,IAAM5B,EAAQ,CACnC,EACAE,EAAQ,QAAU,IAAMF,EAAQ,CAClC,CAAC,CACF,CACH,OAASQ,EAAK,CACZX,EAAS,0BAA2BW,CAAG,CACzC,CACF,CAWA,MAAM,OAAQ,CACZ,GAAI,CACFT,EAAQ,sCAAsC,EAC9C,MAAM,KAAK,WAAW,YAAa,MAAOO,GACjC,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,WAAW,EACjCJ,EAAQ,UAAY,IAAM,CACxB,IAAMuB,EAAOvB,EAAQ,QAAU,CAAC,EAEhC,GAAIuB,EAAK,SAAW,EAAG,CACrBzB,EAAQ,EACR,MACF,CAEA,IAAI6B,EAAY,EACVC,EAAmBd,GAChB,IAAM,CACP,EAAEa,IAAcJ,EAAK,SACnB,KAAK,gBACP,KAAK,eAAeT,EAAI,QAAQ,KAAK,OAAQ,EAAE,EAAG,OAAO,EAE3DhB,EAAQ,EAEZ,EAGF,QAAWgB,KAAOS,EAAM,CACtB,IAAMM,EAAgBzB,EAAM,OAAOU,CAAG,EACtCe,EAAc,UAAYD,EAAgBd,CAAG,EAC7Ce,EAAc,QAAUD,EAAgBd,CAAG,CAC7C,CACF,EACAd,EAAQ,QAAU,IAAMF,EAAQ,CAClC,CAAC,CACF,CACH,OAASa,EAAO,CACdhB,EAAS,2BAA4BgB,CAAK,CAC5C,CACF,CAaA,MAAM,UAAUG,EAAKgB,EAAW,CAC9B,GAAI,CACFjC,EACE,8CAA8CiB,CAAG,gBAAgBgB,CAAS,EAC5E,EACA,IAAMb,EAAU,MAAM,KAAK,aAAa,EACxCA,EAAQH,CAAG,EAAIgB,EACf,MAAM,KAAK,WAAW,YAAc1B,GAC3B,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,IAAI,KAAK,UAAUa,CAAO,EAAG,KAAK,SAAS,EACjEjB,EAAQ,UAAY,IAAMF,EAAQ,EAClCE,EAAQ,QAAU,IAAMF,EAAQ,CAClC,CAAC,CACF,CACH,OAASQ,EAAK,CACZX,EAAS,iCAAiCmB,CAAG,KAAMR,CAAG,CACxD,CACF,CAYA,MAAM,aAAaQ,EAAK,CACtB,GAAI,CACFjB,EAAQ,+CAA+CiB,CAAG,EAAE,EAC5D,IAAMG,EAAU,MAAM,KAAK,aAAa,EACxC,OAAOA,EAAQH,CAAG,EAClB,MAAM,KAAK,WAAW,YAAcV,GAC3B,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,IAAI,KAAK,UAAUa,CAAO,EAAG,KAAK,SAAS,EACjEjB,EAAQ,UAAY,IAAMF,EAAQ,EAClCE,EAAQ,QAAU,IAAMF,EAAQ,CAClC,CAAC,CACF,CACH,OAASQ,EAAK,CACZX,EAAS,kCAAkCmB,CAAG,KAAMR,CAAG,CACzD,CACF,CAWA,MAAM,aAAc,CAClB,GAAI,CACFT,EAAQ,0CAA0C,EAClD,IAAMkC,EAAM,KAAK,IAAI,EACfd,EAAU,MAAM,KAAK,aAAa,EACpCe,EAAU,GAEd,QAAWlB,KAAOG,EACZA,EAAQH,CAAG,GAAKiB,IAClB,MAAM,KAAK,OAAOjB,CAAG,EACrBkB,EAAU,IAId,GAAIA,EAAS,CACX,IAAMC,EAAiB,MAAM,KAAK,aAAa,EAC/C,MAAM,KAAK,WAAW,YAAc7B,GAC3B,IAAI,QAASN,GAAY,CAC9B,IAAME,EAAUI,EAAM,IACpB,KAAK,UAAU6B,CAAc,EAC7B,KAAK,SACP,EACAjC,EAAQ,UAAY,IAAMF,EAAQ,EAClCE,EAAQ,QAAU,IAAMF,EAAQ,CAClC,CAAC,CACF,CACH,CACF,OAASQ,EAAK,CACZX,EAAS,+BAAgCW,CAAG,CAC9C,CACF,CACF,EAIO4B,EAAQjD,EC3mBf,OAAOkD,OAAsB,6CAU7B,IAAMC,EAAN,cAAkCC,CAAe,CAY/C,YAAY,CACV,OAAAC,EACA,QAAAC,EAAU,EACV,QAAAC,EAAU,GACV,oBAAAC,EAAsB,IACtB,YAAAC,EAAc,GACd,YAAAC,EAAc,GACd,eAAAC,EAAiB,EACnB,EAAG,CAED,GADA,MAAMD,CAAW,EACb,OAAO,aAAiB,IAC1B,MAAAE,EAAS,mDAAmD,EACtD,IAAI,MAAM,mDAAmD,EAGrE,KAAK,OAASP,EACd,KAAK,QAAUE,EACf,KAAK,UAAY,SAASF,CAAM,YAChC,KAAK,QAAU,SAASA,CAAM,SAC9B,KAAK,OAAS,GAAGA,CAAM,KACvB,KAAK,UAAYQ,GAAiBR,CAAM,EACxC,KAAK,oBAAsBG,EAC3B,KAAK,eAAiBG,GAAkB,GAExC,KAAK,UAAU,CAAE,OAAAN,EAAQ,QAAAC,EAAS,YAAAG,CAAY,CAAC,EAC/C,KAAK,oBAAoB,EAEzB,KAAK,eAAiB,IAAM,KAAK,QAAQ,EACzC,OAAO,iBAAiB,eAAgB,KAAK,cAAc,EAE3DK,EACE,mDAAmDT,CAAM,cAAcC,CAAO,cAAcC,CAAO,kBAAkBE,CAAW,EAClI,CACF,CAYA,UAAU,CAAE,OAAAJ,EAAQ,QAAAC,EAAS,YAAAG,CAAY,EAAG,CAC1C,GAAI,CACFK,EACE,qEACF,EACA,IAAMC,EAAO,CACX,OAAAV,EACA,QAAAC,EACA,YAAAG,EACA,UAAW,KAAK,IAAI,CACtB,EACA,aAAa,QAAQ,KAAK,QAAS,KAAK,UAAUM,CAAI,CAAC,CACzD,OAASC,EAAK,CACZJ,EAAS,2BAA4BI,CAAG,CAC1C,CACF,CASA,cAAe,CACb,GAAI,CACFF,EAAQ,mDAAmD,EAC3D,IAAMG,EAAM,aAAa,QAAQ,KAAK,SAAS,EAC/C,OAAOA,EAAM,KAAK,MAAMA,CAAG,EAAI,CAAC,CAClC,OAASD,EAAK,CACZ,OAAAJ,EAAS,yBAA0BI,CAAG,EAC/B,CAAC,CACV,CACF,CASA,MAAM,IAAIE,EAAK,CACb,GAAI,CACFJ,EAAQ,sCAAsCI,CAAG,EAAE,EACnD,IAAMC,EAAU,KAAK,SAASD,CAAG,EAC3BD,EAAM,aAAa,QAAQE,CAAO,EACxC,GAAI,CAACF,EAAK,OAAO,KAEjB,IAAMG,EAAU,MAAM,KAAK,UAAUF,CAAG,EACxC,OAAIE,GAAW,KAAK,IAAI,GAAKA,GAC3B,MAAM,KAAK,OAAOF,CAAG,EACd,MAGF,MAAM,KAAK,SAASA,EAAKD,CAAG,CACrC,OAASD,EAAK,CACZ,OAAAJ,EAAS,sBAAsBM,CAAG,KAAMF,CAAG,EACpC,IACT,CACF,CAWA,MAAM,IAAIE,EAAKG,EAAOC,EAAQ,CAC5B,GAAI,CAEF,GADAR,EAAQ,sCAAsCI,CAAG,GAAI,CAAE,MAAAG,EAAO,OAAAC,CAAO,CAAC,EAClE,CAACJ,GAAO,CAACG,EAAO,MAAO,GAC3B,IAAMF,EAAU,KAAK,SAASD,CAAG,EACjC,GAAIA,GAA+BG,GAAU,KAC3C,aAAM,KAAK,OAAOF,CAAO,EAClB,KAETE,EAAQ,KAAK,UAAUA,CAAK,EAE5B,IAAME,EAAY,MAAM,KAAK,SAASL,EAAKG,CAAK,EAChD,OAAKE,GACL,aAAa,QAAQJ,EAASI,CAAS,EAEnC,KAAK,gBACP,KAAK,eAAeL,EAAK,OAAW,KAAK,EAGvC,OAAOI,GAAW,UACpB,MAAM,KAAK,aAAaJ,CAAG,EACpB,IAGLI,EAAS,GACX,MAAM,KAAK,UAAUJ,EAAK,KAAK,IAAI,EAAII,CAAM,EACtC,KAGT,MAAM,KAAK,OAAOJ,CAAG,EACd,OAlBgB,EAmBzB,OAASF,EAAK,CACZ,OAAAJ,EAAS,sBAAsBM,CAAG,KAAMF,CAAG,EACpC,EACT,CACF,CASA,MAAM,OAAOE,EAAK,CAChB,GAAI,CACFJ,EAAQ,uCAAuCI,CAAG,EAAE,EACpD,IAAMC,EAAU,KAAK,SAASD,CAAG,EACjC,aAAa,WAAWC,CAAO,EAE/B,IAAMK,EAAM,KAAK,aAAa,EAC9B,OAAOA,EAAIN,CAAG,EACd,aAAa,QAAQ,KAAK,UAAW,KAAK,UAAUM,CAAG,CAAC,EACpD,KAAK,gBACP,KAAK,eAAeN,EAAK,OAAW,QAAQ,CAEhD,OAASF,EAAK,CACZJ,EAAS,uBAAuBM,CAAG,KAAMF,CAAG,CAC9C,CACF,CAQA,MAAM,MAAO,CACX,IAAMS,EAAU,CAAC,EACjBX,EAAQ,mDAAmD,KAAK,MAAM,EAAE,EACxE,GAAI,CACF,QAASY,EAAI,EAAGA,EAAI,aAAa,OAAQA,IAAK,CAC5C,IAAIC,EAAI,aAAa,IAAID,CAAC,EAI1B,GAHI,KAAK,UACPC,EAAIC,EAAkBD,CAAC,GAErB,EAAAA,IAAM,KAAK,SAAWA,IAAM,KAAK,YACjCA,EAAE,WAAW,KAAK,MAAM,EAAG,CAC7B,IAAMN,EAAQ,MAAM,KAAK,IAAIM,EAAE,QAAQ,KAAK,OAAQ,EAAE,CAAC,EACnDN,IAAU,MACZI,EAAQ,KAAK,CAAE,IAAKE,EAAE,QAAQ,KAAK,OAAQ,EAAE,EAAG,MAAAN,CAAM,CAAC,CAE3D,CACF,CACF,OAASL,EAAK,CACZ,MAAAJ,EAAS,sBAAuBI,CAAG,EAC7BA,CACR,CACA,OAAOS,CACT,CASA,MAAM,IAAIP,EAAK,CACb,GAAI,CACFJ,EAAQ,oDAAoDI,CAAG,EAAE,EACjE,IAAMC,EAAU,KAAK,SAASD,CAAG,EACjC,OAAO,aAAa,QAAQC,CAAO,IAAM,IAC3C,OAASH,EAAK,CACZ,OAAAJ,EAAS,uBAAuBM,CAAG,KAAMF,CAAG,EACrC,EACT,CACF,CAQA,MAAM,OAAQ,CACZ,GAAI,CACFF,EAAQ,yCAAyC,EACjD,MAAM,KAAK,MAAM,EACjB,aAAa,WAAW,KAAK,OAAO,EACpC,aAAa,WAAW,KAAK,SAAS,CACxC,OAASE,EAAK,CACZJ,EAAS,0BAA2BI,CAAG,CACzC,CACF,CAQA,MAAM,OAAQ,CACZ,GAAI,CACFF,EAAQ,yCAAyC,EACjD,IAAMe,EAAe,CAAC,EACtB,QAASH,EAAI,EAAGA,EAAI,aAAa,OAAQA,IAAK,CAC5C,IAAMR,EAAM,aAAa,IAAIQ,CAAC,EAC1BR,EAAI,WAAW,KAAK,MAAM,GAC5BW,EAAa,KAAKX,CAAG,CAEzB,CAEA,QAAWA,KAAOW,EAChB,aAAa,WAAWX,CAAG,EACvB,KAAK,gBACP,KAAK,eAAeA,EAAI,QAAQ,KAAK,OAAQ,EAAE,EAAG,OAAW,OAAO,CAG1E,OAASY,EAAO,CACdlB,EAAS,2BAA4BkB,CAAK,CAC5C,CACF,CAUA,MAAM,UAAUZ,EAAKa,EAAW,CAC9B,GAAI,CACFjB,EAAQ,qDAAqDI,CAAG,GAAI,CAClE,UAAAa,CACF,CAAC,EACD,IAAMX,EAAU,KAAK,aAAa,EAClCA,EAAQF,CAAG,EAAIa,EACf,aAAa,QAAQ,KAAK,UAAW,KAAK,UAAUX,CAAO,CAAC,CAC9D,OAASJ,EAAK,CACZJ,EAAS,iCAAiCM,CAAG,KAAMF,CAAG,CACxD,CACF,CASA,MAAM,aAAaE,EAAK,CACtB,GAAI,CACFJ,EAAQ,sDAAsDI,CAAG,EAAE,EACnE,IAAME,EAAU,KAAK,aAAa,EAClC,OAAOA,EAAQF,CAAG,EAClB,aAAa,QAAQ,KAAK,UAAW,KAAK,UAAUE,CAAO,CAAC,CAC9D,OAASJ,EAAK,CACZJ,EAAS,kCAAkCM,CAAG,KAAMF,CAAG,CACzD,CACF,CAQA,MAAM,aAAc,CAClB,GAAI,CACFF,EAAQ,6CAA6C,EACrD,IAAMkB,EAAM,KAAK,IAAI,EACfZ,EAAU,KAAK,aAAa,EAC9Ba,EAAU,GAEd,QAAWf,KAAOE,EACZA,EAAQF,CAAG,GAAKc,IAClB,MAAM,KAAK,OAAOd,CAAG,EACrBe,EAAU,IAIVA,GACF,aAAa,QACX,KAAK,UACL,KAAK,UAAU,KAAK,aAAa,CAAC,CACpC,CAEJ,OAASjB,EAAK,CACZJ,EAAS,+BAAgCI,CAAG,CAC9C,CACF,CACF,EAIOkB,EAAQ/B,EC7Wf,OAAOgC,OAAsB,6CAW7B,IAAMC,EAAN,cAAoCC,CAAe,CAajD,YAAY,CACV,OAAAC,EACA,QAAAC,EAAU,EACV,QAAAC,EAAU,GACV,oBAAAC,EAAsB,IACtB,YAAAC,EAAc,GACd,YAAAC,EAAc,GACd,eAAAC,EAAiB,EACnB,EAAG,CAED,GADA,MAAMF,CAAW,EACb,OAAO,eAAmB,IAC5B,MAAAG,EAAS,qDAAqD,EACxD,IAAI,MAAM,qDAAqD,EAGvE,KAAK,OAASP,EACd,KAAK,QAAUE,EAEf,KAAK,UAAY,SAASF,CAAM,YAChC,KAAK,QAAU,SAASA,CAAM,SAC9B,KAAK,OAAS,GAAGA,CAAM,KACvB,KAAK,UAAYQ,GAAiBR,CAAM,EACxC,KAAK,oBAAsBG,EAC3B,KAAK,eAAiBG,GAAkB,GAExC,KAAK,UAAU,CAAE,OAAAN,EAAQ,QAAAC,EAAS,YAAAI,CAAY,CAAC,EAC/C,KAAK,oBAAoB,EAEzB,KAAK,eAAiB,IAAM,KAAK,QAAQ,EACzC,OAAO,iBAAiB,eAAgB,KAAK,cAAc,EAC3DI,EACE,oDAAoD,KAAK,MAAM,cAAc,KAAK,OAAO,EAC3F,CACF,CAYA,UAAU,CAAE,OAAAT,EAAQ,QAAAC,EAAS,YAAAI,CAAY,EAAG,CAC1C,GAAI,CACFI,EACE,qDAAqDT,CAAM,KAAKC,CAAO,EACzE,EACA,IAAMS,EAAO,CACX,OAAAV,EACA,QAAAC,EACA,YAAAI,EACA,UAAW,KAAK,IAAI,CACtB,EACA,eAAe,QAAQ,KAAK,QAAS,KAAK,UAAUK,CAAI,CAAC,CAC3D,OAASC,EAAK,CACZJ,EAAS,2BAA4BI,CAAG,CAC1C,CACF,CASA,cAAe,CACb,GAAI,CACFF,EAAQ,gDAAgD,EACxD,IAAMG,EAAM,eAAe,QAAQ,KAAK,SAAS,EACjD,OAAOA,EAAM,KAAK,MAAMA,CAAG,EAAI,CAAC,CAClC,OAASD,EAAK,CACZ,OAAAJ,EAAS,yBAA0BI,CAAG,EAC/B,CAAC,CACV,CACF,CASA,MAAM,IAAIE,EAAK,CACb,GAAI,CACFJ,EAAQ,wCAAwCI,CAAG,GAAG,EACtD,IAAMC,EAAU,KAAK,SAASD,CAAG,EAC3BD,EAAM,eAAe,QAAQE,CAAO,EAC1C,GAAI,CAACF,EAAK,OAAO,KAEjB,IAAMG,EAAU,MAAM,KAAK,UAAUF,CAAG,EACxC,OAAIE,GAAW,KAAK,IAAI,GAAKA,GAC3B,MAAM,KAAK,OAAOF,CAAG,EACd,MAGF,MAAM,KAAK,SAASA,EAAKD,CAAG,CACrC,OAASD,EAAK,CACZ,OAAAJ,EAAS,sBAAsBM,CAAG,KAAMF,CAAG,EACpC,IACT,CACF,CAWA,MAAM,IAAIE,EAAKG,EAAOC,EAAQ,CAC5B,GAAI,CAEF,GADAR,EAAQ,wCAAwCI,CAAG,GAAI,CAAE,MAAAG,EAAO,OAAAC,CAAO,CAAC,EACpE,CAACJ,GAAO,CAACG,EAAO,MAAO,GAE3B,IAAMF,EAAU,KAAK,SAASD,CAAG,EACjC,GAAIA,GAA+BG,GAAU,KAC3C,aAAM,KAAK,OAAOF,CAAO,EAClB,KAGTE,EAAQ,KAAK,UAAUA,CAAK,EAC5B,IAAME,EAAY,MAAM,KAAK,SAASL,EAAKG,CAAK,EAChD,OAAKE,GAEL,eAAe,QAAQJ,EAASI,CAAS,EACrC,KAAK,gBACP,KAAK,eAAeL,EAAKK,EAAW,KAAK,EAGvC,OAAOD,GAAW,UACpB,MAAM,KAAK,aAAaJ,CAAG,EACpB,IAGLI,EAAS,GACX,MAAM,KAAK,UAAUJ,EAAK,KAAK,IAAI,EAAII,CAAM,EACtC,KAGT,MAAM,KAAK,OAAOJ,CAAG,EACd,OAlBgB,EAmBzB,OAASF,EAAK,CACZ,OAAAJ,EAAS,sBAAsBM,CAAG,KAAMF,CAAG,EACpC,EACT,CACF,CASA,MAAM,OAAOE,EAAK,CAChB,GAAI,CACFJ,EAAQ,yCAAyCI,CAAG,GAAG,EACvD,IAAMC,EAAU,KAAK,SAASD,CAAG,EACjC,eAAe,WAAWC,CAAO,EAEjC,IAAMK,EAAM,KAAK,aAAa,EAC9B,OAAOA,EAAIN,CAAG,EACd,eAAe,QAAQ,KAAK,UAAW,KAAK,UAAUM,CAAG,CAAC,EACtD,KAAK,gBACP,KAAK,eAAeN,EAAK,OAAW,QAAQ,CAEhD,OAASF,EAAK,CACZJ,EAAS,uBAAuBM,CAAG,KAAMF,CAAG,CAC9C,CACF,CAQA,MAAM,MAAO,CACX,IAAMS,EAAU,CAAC,EACjB,GAAI,CACFX,EACE,qDAAqD,KAAK,MAAM,GAClE,EACA,QAASY,EAAI,EAAGA,EAAI,eAAe,OAAQA,IAAK,CAC9C,IAAIC,EAAI,eAAe,IAAID,CAAC,EAI5B,GAHI,KAAK,UACPC,EAAIC,EAAkBD,CAAC,GAErB,EAAAA,IAAM,KAAK,SAAWA,IAAM,KAAK,YACjCA,EAAE,WAAW,KAAK,MAAM,EAAG,CAC7B,IAAMN,EAAQ,MAAM,KAAK,IAAIM,EAAE,QAAQ,KAAK,OAAQ,EAAE,CAAC,EACnDN,IAAU,MACZI,EAAQ,KAAK,CAAE,IAAKE,EAAE,QAAQ,KAAK,OAAQ,EAAE,EAAG,MAAAN,CAAM,CAAC,CAE3D,CACF,CACF,OAASL,EAAK,CACZ,MAAAJ,EAAS,sBAAuBI,CAAG,EAC7BA,CACR,CACA,OAAOS,CACT,CASA,MAAM,IAAIP,EAAK,CACb,GAAI,CACFJ,EAAQ,sDAAsDI,CAAG,GAAG,EACpE,IAAMC,EAAU,KAAK,SAASD,CAAG,EACjC,OAAO,eAAe,QAAQC,CAAO,IAAM,IAC7C,OAASH,EAAK,CACZ,OAAAJ,EAAS,uBAAuBM,CAAG,KAAMF,CAAG,EACrC,EACT,CACF,CAQA,MAAM,OAAQ,CACZ,GAAI,CACFF,EAAQ,2CAA2C,EACnD,MAAM,KAAK,MAAM,EACjB,eAAe,WAAW,KAAK,OAAO,EACtC,eAAe,WAAW,KAAK,SAAS,CAC1C,OAASE,EAAK,CACZJ,EAAS,0BAA2BI,CAAG,CACzC,CACF,CAQA,MAAM,OAAQ,CACZ,GAAI,CACFF,EAAQ,2CAA2C,EACnD,IAAMe,EAAe,CAAC,EAEtB,QAASH,EAAI,EAAGA,EAAI,eAAe,OAAQA,IAAK,CAC9C,IAAMR,EAAM,eAAe,IAAIQ,CAAC,EAC5BR,EAAI,WAAW,KAAK,MAAM,GAC5BW,EAAa,KAAKX,CAAG,CAEzB,CAEA,QAAWA,KAAOW,EAChB,eAAe,WAAWX,CAAG,EACzB,KAAK,gBACP,KAAK,eAAeA,EAAI,QAAQ,KAAK,OAAQ,EAAE,EAAG,OAAW,OAAO,CAG1E,OAASY,EAAO,CACdlB,EAAS,2BAA4BkB,CAAK,CAC5C,CACF,CAUA,MAAM,UAAUZ,EAAKa,EAAW,CAC9B,GAAI,CACFjB,EAAQ,mDAAmDI,CAAG,GAAG,EACjE,IAAME,EAAU,KAAK,aAAa,EAClCA,EAAQF,CAAG,EAAIa,EACf,eAAe,QAAQ,KAAK,UAAW,KAAK,UAAUX,CAAO,CAAC,CAChE,OAASJ,EAAK,CACZJ,EAAS,iCAAiCM,CAAG,KAAMF,CAAG,CACxD,CACF,CASA,MAAM,aAAaE,EAAK,CACtB,GAAI,CACFJ,EAAQ,oDAAoDI,CAAG,GAAG,EAClE,IAAME,EAAU,KAAK,aAAa,EAClC,OAAOA,EAAQF,CAAG,EAClB,eAAe,QAAQ,KAAK,UAAW,KAAK,UAAUE,CAAO,CAAC,CAChE,OAASJ,EAAK,CACZJ,EAAS,kCAAkCM,CAAG,KAAMF,CAAG,CACzD,CACF,CAQA,MAAM,aAAc,CAClB,GAAI,CACFF,EAAQ,+CAA+C,EACvD,IAAMkB,EAAM,KAAK,IAAI,EACfZ,EAAU,KAAK,aAAa,EAC9Ba,EAAU,GAEd,QAAWf,KAAOE,EACZA,EAAQF,CAAG,GAAKc,IAClB,MAAM,KAAK,OAAOd,CAAG,EACrBe,EAAU,IAIVA,GACF,eAAe,QACb,KAAK,UACL,KAAK,UAAU,KAAK,aAAa,CAAC,CACpC,CAEJ,OAASjB,EAAK,CACZJ,EAAS,+BAAgCI,CAAG,CAC9C,CACF,CACF,EAIOkB,EAAQ/B,EC7Vf,IAAMgC,EAAN,KAAmB,CAqBjB,MAAM,aAAaC,EAAOC,EAAKC,EAAU,CAAC,EAAG,CAC3C,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAiBA,MAAM,eAAeF,EAAOC,EAAKE,EAAS,CACxC,MAAM,IAAI,MAAM,iBAAiB,CACnC,CAWA,SAAU,CACR,GAAI,KAAK,aAAc,CACrBC,EAAQ,4DAA4D,EACpE,KAAK,aAAa,EAClB,KAAK,aAAe,KACpB,MACF,CACAA,EAAQ,2DAA2D,CACrE,CACF,EAIOC,EAAQN,ECtFf,OAAOO,OAAY,mCAenB,IAAMC,EAAN,cAA2BC,CAAa,CAMtC,YAAYC,EAAS,CAEnB,GADA,MAAM,EACF,CAACA,EACH,MAAAC,EAAS,iCAAiC,EACpC,IAAI,MAAM,iCAAiC,EAEnD,KAAK,QAAUD,CACjB,CAUA,YAAYE,EAAO,CACjB,GAAI,CAACA,GAAS,CAACA,EAAM,YAAc,CAACA,EAAM,OACxC,MAAAD,EAAS,+BAA+B,EAClC,IAAI,MAAM,+BAA+B,CAEnD,CAYA,uBAAuBC,EAAO,CAC5BC,EAAQ,mDAAmD,EACtDD,GAGL,KAAK,QAAQ,cAAc,MAAOE,GAAS,CACzC,GAAI,CACF,GAAIA,EAAK,WAAa,KAAK,QAAQ,WAAa,CAACA,EAAK,OACpD,OAGF,IAAIC,EAOJ,GANKD,EAAK,MAGRC,EAAc,MAAM,KAAK,QAAQ,SAASD,EAAK,IAAKA,EAAK,KAAK,EAF9DC,EAAc,MAAM,KAAK,QAAQ,IAAID,EAAK,GAAG,EAK3C,KAAK,UAAUF,EAAM,MAAM,IAAM,KAAK,UAAUG,CAAW,EAC7D,OAGFH,EAAM,OAAS,CACb,GAAGA,EAAM,OACT,GAAGG,EACH,gCAAiC,EACnC,CACF,OAASC,EAAO,CACdL,EAAS,wCAAyCK,CAAK,CACzD,CACF,CAAC,CACH,CAqBA,MAAM,aAAaJ,EAAOK,EAAKC,EAAU,CAAC,EAAG,CAC3C,GAAI,CACF,OAAAL,EAAQ,qCAAsCI,CAAG,EACjD,KAAK,YAAYL,CAAK,EACtBM,EAAQ,WAAaA,EAAQ,YAAc,CAAC,EAGxC,KAAK,cACP,KAAK,aAAa,EAGb,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,KAAK,aAAeR,EAAM,WAAW,MAAOS,EAAUC,IAAU,CAC9D,GAAI,CACF,GAAI,CAACA,EACH,OAAOH,EAAQ,EAAI,EAErB,GAAIG,EAAM,gCACR,cAAOA,EAAM,gCACNH,EAAQ,EAAI,EAGrB,IAAMI,EAAa,CAAE,GAAGD,CAAM,EAC9B,QAASE,KAAWD,EACdL,EAAQ,WAAW,SAASM,CAAO,IACrCD,EAAWC,CAAO,EAAI,QAI1B,aAAM,KAAK,QAAQ,IAAIP,EAAKM,EAAYL,EAAQ,OAAO,EAEhDC,EAAQ,EAAI,CACrB,OAASH,EAAO,CACd,OAAOI,EAAOJ,CAAK,CACrB,CACF,CAAC,EAEDJ,EAAM,OAAO,CAAE,GAAGA,EAAM,MAAO,CAAC,EAE5BM,EAAQ,UACV,KAAK,uBAAuBN,CAAK,CAErC,CAAC,CACH,OAASI,EAAO,CACd,MAAAL,EAASK,CAAK,EACRA,CACR,CACF,CAeA,MAAM,eAAeJ,EAAOK,EAAK,CAC/B,GAAI,CACFJ,EAAQ,uCAAwCI,CAAG,EACnD,KAAK,YAAYL,CAAK,EACtB,IAAMa,EAAU,MAAM,KAAK,QAAQ,IAAIR,CAAG,EAC1C,OAAKQ,GAILb,EAAM,OAAOc,GAAO,CAAC,EAAGD,CAAO,CAAC,EACzB,IAJL,MAKJ,OAAST,EAAO,CACd,MAAAL,EAASK,CAAK,EACRA,CACR,CACF,CACF,EAIOW,EAAQnB,EC7Lf,OAAOoB,OAAY,mCAoBnB,IAAMC,EAAN,cAA2BC,CAAa,CAMtC,YAAYC,EAAS,CAEnB,GADA,MAAM,EACF,CAACA,EACH,MAAAC,EAAS,iCAAiC,EACpC,IAAI,MAAM,iCAAiC,EAEnD,KAAK,QAAUD,EACf,KAAK,aAAe,IACtB,CAIA,YAAYE,EAASC,EAAS,CAC5B,MAAO,CACL,GAAGD,EACH,GAAGC,EACH,gCAAiC,EACnC,CACF,CAYA,uBAAuBC,EAAO,CAC5BC,EAAQ,mDAAmD,EACtDD,GAIL,KAAK,QAAQ,cAAc,MAAOE,GAAS,CACzC,GAAI,CAEF,GAAIA,EAAK,WAAa,KAAK,QAAQ,WAAa,CAACA,EAAK,OACpD,OAGF,IAAIC,EAQJ,GAPKD,EAAK,MAGRC,EAAc,MAAM,KAAK,QAAQ,SAASD,EAAK,IAAKA,EAAK,KAAK,EAF9DC,EAAc,MAAM,KAAK,QAAQ,IAAID,EAAK,GAAG,EAO7C,OAAOF,EAAM,UAAa,YAC1B,OAAOA,EAAM,UAAa,WAC1B,CACA,IAAMI,EAAeJ,EAAM,SAAS,EACpC,GAAI,KAAK,UAAUI,CAAY,IAAM,KAAK,UAAUD,CAAW,EAC7D,OAGFH,EAAM,SAAS,CACb,KAAM,mBACN,QAAS,KAAK,YAAYI,EAAcD,CAAW,CACrD,CAAC,EACD,MACF,CAGA,GACE,OAAOH,EAAM,UAAa,YAC1B,OAAOA,EAAM,UAAa,WAC1B,CACA,IAAMI,EAAeJ,EAAM,SAAS,EACpC,GAAI,KAAK,UAAUI,CAAY,IAAM,KAAK,UAAUD,CAAW,EAC7D,OAEFH,EAAM,SAAS,KAAK,YAAYI,EAAcD,CAAW,CAAC,EAC1D,MACF,CAGA,GACE,OAAOH,EAAM,KAAQ,YACrB,OAAOA,EAAM,KAAQ,WACrB,CACA,IAAMI,EAAeJ,EAAM,IAAI,EAC/B,GAAI,KAAK,UAAUI,CAAY,IAAM,KAAK,UAAUD,CAAW,EAC7D,OAGFH,EAAM,IAAI,KAAK,YAAYI,EAAcD,CAAW,CAAC,EACrD,MACF,CAEA,GAAI,OAAOH,EAAM,QAAW,WAAY,CACtCA,EAAM,OAAQK,GACR,KAAK,UAAUA,CAAK,IAAM,KAAK,UAAUF,CAAW,EAC/CE,EAEF,KAAK,YAAYA,EAAOF,CAAW,CAC3C,EACD,MACF,CAGA,IAAMC,EACJ,OAAOJ,EAAM,UAAa,WACtBA,EAAM,SAAS,EACf,OAAOA,EAAM,KAAQ,WACrBA,EAAM,IAAI,EACV,CAAC,EAEP,GAAI,KAAK,UAAUI,CAAY,IAAM,KAAK,UAAUD,CAAW,EAC7D,OAGE,OAAOH,EAAM,KAAQ,WACvBA,EAAM,IAAI,KAAK,YAAYI,EAAcD,CAAW,CAAC,EAErDN,EAAS,2DAA2D,CAExE,OAASS,EAAO,CACdT,EAAS,mCAAoCS,CAAK,CACpD,CACF,CAAC,CACH,CAyBA,MAAM,aAAaN,EAAOO,EAAKC,EAAU,CAAC,EAAG,CAC3C,GAAI,CACF,OAAAP,EAAQ,qCAAsCM,CAAG,EACjD,KAAK,YAAYP,CAAK,EACtBQ,EAAQ,WAAaA,EAAQ,YAAc,CAAC,EAGxC,KAAK,cACP,KAAK,aAAa,EAGb,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,IAAMC,EAAoB,MAAON,GAAU,CACzC,GAAI,CACF,GAAI,CAACA,EAAO,OACZ,GAAIA,EAAM,gCACR,cAAOA,EAAM,gCACNI,EAAQ,EAAI,EAGrB,IAAMG,EAAa,CAAE,GAAGP,CAAM,EAC9B,QAASQ,KAAWD,EACdJ,EAAQ,WAAW,SAASK,CAAO,IACrCD,EAAWC,CAAO,EAAI,QAI1B,MAAM,KAAK,QAAQ,IAAIN,EAAKK,EAAYJ,EAAQ,OAAO,CACzD,OAASF,EAAO,CAEdT,EAASS,CAAK,CAChB,CACF,EAGA,GACE,OAAON,EAAM,WAAc,YAC3B,OAAOA,EAAM,UAAa,WAG1BW,EAAkBX,EAAM,SAAS,CAAC,EAGlC,KAAK,aAAeA,EAAM,UAAU,IAAM,CACxCW,EAAkBX,EAAM,SAAS,CAAC,CACpC,CAAC,UAGM,OAAOA,EAAM,WAAc,WAClC,KAAK,aAAeA,EAAM,UAAUW,CAAiB,MAChD,CACLD,EAAO,IAAI,MAAM,wBAAwB,CAAC,EAC1C,MACF,CAGIF,EAAQ,UACV,KAAK,uBAAuBR,CAAK,EAEnCS,EAAQ,EAAI,CACd,CAAC,CACH,OAASH,EAAO,CACd,MAAAT,EAASS,CAAK,EACRA,CACR,CACF,CAmBA,MAAM,eAAeN,EAAOO,EAAK,CAC/B,GAAI,CACFN,EAAQ,uCAAwCM,CAAG,EACnD,KAAK,YAAYP,CAAK,EACtB,IAAMc,EAAU,MAAM,KAAK,QAAQ,IAAIP,CAAG,EAC1C,GAAI,CAACO,EACH,OAIF,GAAI,OAAOd,EAAM,UAAa,WAE5BA,EAAM,SAAS,CACb,KAAM,yBACN,QAASc,CACX,CAAC,UACQ,OAAOd,EAAM,UAAa,WAEnCA,EAAM,SAASe,GAAO,CAAC,EAAGD,CAAO,CAAC,MAElC,OAAM,IAAI,MACR,4DACF,EAGF,MAAO,EACT,OAASR,EAAO,CACd,MAAAT,EAASS,CAAK,EACRA,CACR,CACF,CAUA,YAAYN,EAAO,CACjB,GAAI,CAACA,EACH,MAAAH,EAAS,+BAA+B,EAClC,IAAI,MAAM,+BAA+B,EAyBjD,GApBE,OAAOG,EAAM,UAAa,YAC1B,OAAOA,EAAM,UAAa,YAC1B,OAAOA,EAAM,WAAc,YAQ3B,OAAOA,EAAM,UAAa,YAC1B,OAAOA,EAAM,UAAa,YAC1B,OAAOA,EAAM,WAAc,aAO7B,QAAQ,IAAI,UAAWA,CAAK,EAE1B,MAAM,QAAQA,CAAK,GACnBA,EAAM,SAAW,GACjB,OAAOA,EAAM,CAAC,GAAM,YACpB,OAAOA,EAAM,CAAC,GAAM,YAGpB,OAIF,IAAMgB,EACJ,OAAOhB,EAAM,UAAa,YAC1B,OAAOA,EAAM,WAAc,WACvBiB,EACJ,OAAOjB,EAAM,UAAa,YAC1B,OAAOA,EAAM,WAAc,WAG7B,GAAI,EAFiB,OAAOA,EAAM,WAAc,YAG9C,MAAAH,EAAS,oCAAoC,EACvC,IAAI,MAAM,oCAAoC,EAGtD,GAAI,CAACmB,GAAe,CAACC,EACnB,MAAApB,EACE,yEACF,EACM,IAAI,MACR,yEACF,CAEJ,CACF,EAIOqB,EAAQxB,EC7Wf,OAAOyB,MAAY,mCAwBnB,IAAMC,EAAN,cAA4BC,CAAa,CAMvC,YAAYC,EAAS,CAEnB,GADA,MAAM,EACF,CAACA,EACH,MAAAC,EAAS,iCAAiC,EACpC,IAAI,MAAM,iCAAiC,EAEnD,KAAK,QAAUD,EACf,KAAK,aAAe,IACtB,CAYA,uBAAuBE,EAAO,CAC5BC,EAAQ,oDAAoD,EAC5D,GAAI,CACF,GAAI,CAACD,EACH,OAEF,KAAK,QAAQ,cAAc,MAAOE,GAAS,CACzC,GAAIA,EAAK,WAAa,KAAK,QAAQ,WAAa,CAACA,EAAK,OACpD,OAGF,IAAIC,EACgBH,EAAM,UAAWI,GAAU,CAC7CD,EAAeE,EAAO,CAAC,EAAGD,CAAK,CACjC,CAAC,EACW,EAEZ,IAAIE,EACCJ,EAAK,MAGRI,EAAc,MAAM,KAAK,QAAQ,SAASJ,EAAK,IAAKA,EAAK,KAAK,EAF9DI,EAAc,MAAM,KAAK,QAAQ,IAAIJ,EAAK,GAAG,EAI3C,KAAK,UAAUC,CAAY,IAAM,KAAK,UAAUG,CAAW,GAM/DN,EAAM,OAAQG,IAAkB,CAC9B,GAAGA,EACH,GAAGG,EACH,gCAAiC,EACnC,EAAE,CACJ,CAAC,CACH,OAASC,EAAO,CACd,MAAAR,EAAS,uCAAwCQ,CAAK,EAChDA,CACR,CACF,CAqBA,MAAM,aAAaP,EAAOQ,EAAKC,EAAU,CAAC,EAAG,CAC3C,GAAI,CACF,OAAAR,EAAQ,sCAAuCO,CAAG,EAClD,KAAK,YAAYR,CAAK,EACtBS,EAAQ,WAAaA,EAAQ,YAAc,CAAC,EAGxC,KAAK,cACP,KAAK,aAAa,EAGb,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,IAAMC,EAAcZ,EAAM,UAAU,MAAOa,GAAU,CACnD,GAAI,CACF,GAAI,CAACA,EACH,OAAOH,EAAQ,EAAI,EAGrB,IAAMI,EAAa,CAAE,GAAGD,CAAM,EAC9B,QAASE,KAAWD,EACdL,EAAQ,WAAW,SAASM,CAAO,IACrCD,EAAWC,CAAO,EAAI,QAI1B,aAAM,KAAK,QAAQ,IAAIP,EAAKM,EAAYL,EAAQ,OAAO,EAChDC,EAAQ,EAAI,CACrB,OAASH,EAAO,CACd,OAAOI,EAAOJ,CAAK,CACrB,CACF,CAAC,EAED,KAAK,aAAeK,EAEhBH,EAAQ,UACV,KAAK,uBAAuBT,CAAK,CAErC,CAAC,CACH,OAASO,EAAO,CACd,MAAAR,EAASQ,CAAK,EACRA,CACR,CACF,CAeA,MAAM,eAAeP,EAAOQ,EAAK,CAC/B,GAAI,CACFP,EAAQ,wCAAyCO,CAAG,EACpD,KAAK,YAAYR,CAAK,EACtB,IAAMgB,EAAU,MAAM,KAAK,QAAQ,IAAIR,CAAG,EAC1C,OAAKQ,GAGLhB,EAAM,IAAIK,EAAO,CAAC,EAAGW,CAAO,CAAC,EACtB,IAHL,MAIJ,OAAST,EAAO,CACd,MAAAR,EAASQ,CAAK,EACRA,CACR,CACF,CAUA,YAAYP,EAAO,CACjB,GACE,CAACA,GACD,OAAOA,EAAM,WAAc,YAC3B,OAAOA,EAAM,KAAQ,WAErB,MAAAD,EAAS,qDAAqD,EACxD,IAAI,MAAM,qDAAqD,CAEzE,CACF,EAIOkB,EAAQrB,ECnMf,IAAMsB,GAAiB,CACrB,OAAQ,YACR,UAAW,eACX,QAAS,EACT,QAAS,GACT,oBAAqB,IACrB,YAAa,qBACb,QAAS,WACX,EAMIC,EACAC,EACAC,EACAC,EA4BJ,SAASC,GAAeC,EAAS,CAAC,EAAG,CACnC,IAAMC,EAAS,CAAE,GAAGP,GAAgB,GAAGM,CAAO,EAE9C,GAAI,CAACA,EAAO,eAAiBL,EAC3B,OAAOA,EAGT,OAAQM,EAAO,QAAS,CACtB,IAAK,eACH,GAAID,EAAO,MACT,OAAO,IAAIE,EAAoBD,CAAM,EAEvCN,EAAiB,IAAIO,EAAoBD,CAAM,EAC/C,MACF,IAAK,iBACH,GAAID,EAAO,MACT,OAAO,IAAIG,EAAsBF,CAAM,EAEzCN,EAAiB,IAAIQ,EAAsBF,CAAM,EACjD,MACF,QACE,GAAID,EAAO,MACT,OAAO,IAAII,EAAiBH,CAAM,EAEpCN,EAAiB,IAAIS,EAAiBH,CAAM,CAChD,CAEA,OAAON,CACT,CASA,SAASU,IAAoB,CAC3B,GAAI,CAACV,EACH,MAAM,IAAI,MAAM,6DAA6D,EAE/E,OAAOA,CACT,CAiBA,SAASW,EAAqB,CAAE,QAAAC,EAAS,cAAAC,EAAe,cAAAC,CAAc,EAAGC,EAAeC,EAAc,CACpG,GAAIJ,EACF,OAAO,IAAII,EAAaJ,CAAO,EAGjC,GAAIG,GAAiB,CAACD,EACpB,OAAOC,EAGT,GAAIF,EAAe,CACjB,IAAMb,EAAiBiB,GAAsBJ,CAAa,EAC1D,OAAO,IAAIG,EAAahB,CAAc,CACxC,CAEA,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,6DAA6D,EAG/E,OAAO,IAAIgB,EAAahB,CAAc,CACxC,CAUA,SAASiB,GAAsBX,EAAQ,CACrC,OAAQA,EAAO,QAAS,CACtB,IAAK,eACH,OAAO,IAAIC,EAAoBD,CAAM,EACvC,IAAK,iBACH,OAAO,IAAIE,EAAsBF,CAAM,EACzC,QACE,OAAO,IAAIG,EAAiBH,CAAM,CACtC,CACF,CAcA,SAASY,GAAgB,CAAE,QAAAN,EAAU,KAAM,cAAAC,EAAgB,KAAM,cAAAC,EAAgB,GAAO,MAAAK,EAAQ,EAAM,EAAI,CAAC,EAAG,CAC5G,OAAIA,EACKR,EAAqB,CAAE,QAAAC,EAAS,cAAAC,EAAe,cAAAC,CAAc,EAAG,KAAMM,CAAY,GAE3FnB,EAAeU,EACb,CAAE,QAAAC,EAAS,cAAAC,EAAe,cAAAC,CAAc,EACxCb,EACAmB,CACF,EACO,CACL,aAAcnB,EAAa,aAAa,KAAKA,CAAY,EACzD,eAAgBA,EAAa,eAAe,KAAKA,CAAY,CAC/D,EACF,CAcA,SAASoB,GAAgB,CAAE,QAAAT,EAAU,KAAM,cAAAC,EAAgB,KAAM,cAAAC,EAAgB,GAAO,MAAAK,EAAQ,EAAM,EAAI,CAAC,EAAG,CAC5G,OAAIA,EACKR,EAAqB,CAAE,QAAAC,EAAS,cAAAC,EAAe,cAAAC,CAAc,EAAG,KAAMQ,CAAY,GAE3FpB,EAAeS,EACb,CAAE,QAAAC,EAAS,cAAAC,EAAe,cAAAC,CAAc,EACxCZ,EACAoB,CACF,EACOpB,EACT,CAcA,SAASqB,GAAiB,CAAE,QAAAX,EAAU,KAAM,cAAAC,EAAgB,KAAM,cAAAC,EAAgB,GAAO,MAAAK,EAAQ,EAAM,EAAI,CAAC,EAAG,CAC7G,OAAIA,EACKR,EAAqB,CAAE,QAAAC,EAAS,cAAAC,EAAe,cAAAC,CAAc,EAAG,KAAMU,CAAa,GAE5FrB,EAAgBQ,EACd,CAAE,QAAAC,EAAS,cAAAC,EAAe,cAAAC,CAAc,EACxCX,EACAqB,CACF,EACOrB,EACT,CAIA,eAAesB,GAAgBC,EAAOC,EAAKC,EAAU,CAAC,EAAG,CACvD,GAAI,CAIF,GAHK3B,GACHiB,GAAgB,EAEd,CAACQ,EACH,MAAM,IAAI,MAAM,oBAAoB,EAEtC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,kBAAkB,EAEpC,MAAM1B,EAAa,eAAeyB,EAAOC,CAAG,EAC5C,MAAM1B,EAAa,aAAayB,EAAOC,EAAKC,CAAO,CACrD,OAASC,EAAO,CACd,eAASA,CAAK,EACRA,CACR,CACF,CAIA,eAAeC,GAAgBJ,EAAOC,EAAKC,EAAU,CAAC,EAAG,CACvD,GAAI,CAIF,GAHK1B,GACHmB,GAAgB,EAEd,CAACK,EACH,MAAM,IAAI,MAAM,oBAAoB,EAEtC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,kBAAkB,EAEpC,MAAMzB,EAAa,eAAewB,EAAOC,CAAG,EAC5C,MAAMzB,EAAa,aAAawB,EAAOC,EAAKC,CAAO,CACrD,OAASC,EAAO,CACd,eAASA,CAAK,EACRA,CACR,CACF,CAIA,eAAeE,GAAiBL,EAAOC,EAAKC,EAAU,CAAC,EAAG,CACxD,GAAI,CAIF,GAHKzB,GACHoB,GAAiB,EAEf,CAACG,EACH,MAAM,IAAI,MAAM,oBAAoB,EAEtC,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,kBAAkB,EAEpC,MAAMxB,EAAc,eAAeuB,EAAOC,CAAG,EAC7C,MAAMxB,EAAc,aAAauB,EAAOC,EAAKC,CAAO,CACtD,OAASC,EAAO,CACd,eAASA,CAAK,EACRA,CACR,CACF","names":["logError","args","logWarn","logInfo","base64To","base64From","ENCODER","DECODER","crypto","subtle","getCrypto","_a","logInfo","error","logError","generateKeyMaterial","password","deriveKey","salt","extractable","keyMaterial","encryptData","key","dataObj","raw","iv","encoded","encrypted","ivBase64","encryptedBase64","decryptData","encryptedObj","decodeBase64","b64","char","decrypted","simpleObfuscate","str","logInfo","shifted","char","base64To","simpleDeobfuscate","base64From","generateSimpleId","CrossTabChannel","channelName","logInfo","error","logError","callback","logWarn","event","data","CrossTabChannel_default","StorageAdapter","channelName","logInfo","CrossTabChannel_default","logWarn","key","value","expire","prefix","time","cKey","deriveKey","encrypted","encryptData","err","logError","encryptedObj","decrypted","decryptData","full","obfuscated","simpleObfuscate","tableName","expires","origin","callback","StorageAdapter_default","sleep","generateSimpleId","IndexedDBAdapter","StorageAdapter_default","dbName","storeName","version","encrypt","expireCheckInterval","channelName","enableSyncTabs","description","logError","generateSimpleId","logInfo","resolve","reject","request","event","db","meta","store","metaRequest","err","timeout","tries","sleep","attempt","error","mode","callback","key","fullKey","raw","expires","value","expire","encrypted","exp","results","keys","k","simpleDeobfuscate","request2","completed","checkCompletion","deleteRequest","timestamp","now","changed","currentExpires","IndexedDBAdapter_default","generateSimpleId","LocalStorageAdapter","StorageAdapter_default","dbName","version","encrypt","expireCheckInterval","description","channelName","enableSyncTabs","logError","generateSimpleId","logInfo","meta","err","raw","key","fullKey","expires","value","expire","encrypted","exp","results","i","k","simpleDeobfuscate","keysToRemove","error","timestamp","now","changed","LocalStorageAdapter_default","generateSimpleId","SessionStorageAdapter","StorageAdapter_default","dbName","version","encrypt","expireCheckInterval","channelName","description","enableSyncTabs","logError","generateSimpleId","logInfo","meta","err","raw","key","fullKey","expires","value","expire","encrypted","exp","results","i","k","simpleDeobfuscate","keysToRemove","error","timestamp","now","changed","SessionStorageAdapter_default","StoreAdapter","store","key","options","timeout","logInfo","StoreAdapter_default","assign","PiniaAdapter","StoreAdapter_default","adapter","logError","store","logInfo","data","dataToPatch","error","key","options","resolve","reject","mutation","state","stateProps","propKey","storage","assign","PiniaAdapter_default","assign","ReactAdapter","StoreAdapter_default","adapter","logError","current","payload","store","logInfo","data","dataToPatch","currentState","state","error","key","options","resolve","reject","handleStateChange","stateProps","propKey","storage","assign","hasGetState","hasSetState","ReactAdapter_default","assign","SvelteAdapter","StoreAdapter_default","adapter","logError","store","logInfo","data","currentState","value","assign","dataToPatch","error","key","options","resolve","reject","unsubscribe","state","stateProps","propKey","storage","SvelteAdapter_default","DEFAULT_CONFIG","storageAdapter","piniaAdapter","reactAdapter","svelteAdapter","startStoragefy","config","params","LocalStorageAdapter_default","SessionStorageAdapter_default","IndexedDBAdapter_default","getStorageAdapter","_getFrameworkAdapter","adapter","adapterParams","forceRecreate","cachedAdapter","AdapterClass","_createStorageAdapter","getPiniaAdapter","fresh","PiniaAdapter_default","getReactAdapter","ReactAdapter_default","getSvelteAdapter","SvelteAdapter_default","setPiniaStorage","store","key","options","error","setReactStorage","setSvelteStorage"]}