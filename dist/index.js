globalThis.storagefyDebug=!0;globalThis.storagefyDebugLevel=0;var n=(...o)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=0&&(o.unshift("Storagefy Error:"),console.error(...o))},_=(...o)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=1&&(o.unshift("Storagefy Warn:"),console.warn(...o))},s=(...o)=>{globalThis.storagefyDebug&&globalThis.storagefyDebugLevel>=2&&(o.unshift("Storagefy:"),console.info(...o))};import $ from"misc-helpers/src/utils/base64To.js";import U from"misc-helpers/src/utils/base64From.js";var T=new TextEncoder,V=new TextDecoder,E,u;function Q(){try{if(s("CryptoHelper - Attempting to initialize crypto engine"),typeof window<"u"&&window.crypto){E=window.crypto,u=E.subtle,s("CryptoHelper - Crypto initialized from window.crypto");return}if(typeof global<"u"&&global.crypto?.webcrypto){E=global.crypto.webcrypto,u=E.subtle,s("CryptoHelper - Crypto initialized from global.webcrypto");return}throw new Error("Crypto API not available")}catch(o){throw n("Failed to initialize crypto:",o),o}}try{Q()}catch(o){n("Failed to initialize crypto:",o)}var X=async o=>{try{return s("CryptoHelper - Generating key material from password"),u.importKey("raw",T.encode(o),"PBKDF2",!1,["deriveKey"])}catch(e){throw n("Error generating key material:",e),e}},N=async(o,e,t=!1)=>{try{if(typeof o!="string"||!o.length)throw new Error("Invalid password");s("CryptoHelper - Deriving key with PBKDF2",{passwordLength:o.length,extractable:t});let r=await X(o);return u.deriveKey({name:"PBKDF2",salt:T.encode(e),iterations:1e5,hash:"SHA-256"},r,{name:"AES-GCM",length:256},t,["encrypt","decrypt"])}catch(r){throw n("Error deriving key:",r),r}},z=async(o,e,t=!1)=>{if(e===void 0||typeof e=="function"||typeof e=="symbol")throw new Error("Invalid data type for encryption");try{s("CryptoHelper - Encrypting data",{raw:t});let r=E.getRandomValues(new Uint8Array(12)),i=T.encode(JSON.stringify(e)),a=await u.encrypt({name:"AES-GCM",iv:r},o,i);if(t)return{iv:r,data:new Uint8Array(a)};let c=$(String.fromCharCode(...r)),l=$(String.fromCharCode(...new Uint8Array(a)));return{iv:c,data:l}}catch(r){throw n("Error encrypting data:",r),r}},k=async(o,e,t=!1)=>{let r,i;try{if(s("CryptoHelper - Decrypting data",{raw:t}),t)r=new Uint8Array(e.iv),i=new Uint8Array(e.data);else{let c=l=>new Uint8Array(U(l).split("").map(h=>h.charCodeAt(0)));r=c(e.iv),i=c(e.data)}let a=await u.decrypt({name:"AES-GCM",iv:r},o,i);return JSON.parse(V.decode(a))}catch(a){throw n("Error decrypting data:",a),a}};function M(o){if(!o)return o;s("CryptoHelper - Obfuscating string");try{let e=[...o].map(t=>String.fromCharCode(t.charCodeAt(0)+1)).join("");return $(e)}catch{return o}}function g(o){if(!o)return o;s("CryptoHelper - Deobfuscating string");try{return[...U(o)].map(t=>String.fromCharCode(t.charCodeAt(0)-1)).join("")}catch{return o}}import ee from"misc-helpers/src/utils/generateSimpleId.js";var O=class{constructor(e){try{typeof e!="string"&&(e=ee("storagefy_channel")),this.channel=new BroadcastChannel(e),this.channelName=e,s(`CrossTabChannel initialized on channel "${e}"`)}catch(t){throw n("Failed to initialize BroadcastChannel:",t),t}}subscribe(e){if(typeof e!="function"){_("CrossTabChannel.subscribe: Provided callback is not a function.");return}this.channel.onmessage=t=>{s("CrossTabChannel - Received message:",t.data);try{e(t.data)}catch(r){n("Error in CrossTabChannel subscriber callback:",r)}},s("CrossTabChannel - Subscribed to incoming messages.")}emit(e){try{this.channel.postMessage(e),s("CrossTabChannel - Emitted message:",e)}catch(t){n("CrossTabChannel.emit: Failed to send message:",t)}}close(){try{this.channel.close(),s("CrossTabChannel - Channel closed.")}catch(e){n("CrossTabChannel.close: Error closing channel:",e)}}},Y=O;var v=class{constructor(e){e?(s("StorageAdapter - Initializing cross-tab channel:",e),this.channelName=e,this.channel=new Y(e)):(this.channel=null,this.channelName=null,_("StorageAdapter - No channel name provided, cross-tab syncing disabled."))}async get(e){throw new Error("Not implemented")}async set(e,t,r){throw new Error("Not implemented")}async delete(e){throw new Error("Not implemented")}async list(e=""){throw new Error("Not implemented")}async reset(){throw new Error("Not implemented")}async clear(){throw new Error("Not implemented")}async clearExpire(){throw new Error("Not implemented")}async setExpire(e,t){throw new Error("Not implemented")}async deleteExpire(e){throw new Error("Not implemented")}async has(e){throw new Error("Not implemented")}async _encrypt(e,t){if(!this.encrypt||!e)return t;try{let r=await N(e),i=await z(r,t,!1);return s(`StorageAdapter - Successfully encrypted value for key "${e}".`),JSON.stringify(i)}catch(r){return n("Encryption failed:",r),null}}async _decrypt(e,t){if(!this.encrypt||!e)return JSON.parse(t);try{let r=await N(e),i=JSON.parse(t),a=await k(r,i,!1);return s(`StorageAdapter - Successfully decrypted value for key "${e}".`),JSON.parse(a)}catch(r){return n("Decryption failed:",r),null}}_fullKey(e){let t=`${this.prefix}${e}`;if(this.encrypt){let r=M(t);return s(`StorageAdapter - Obfuscated key "${e}" to "${r}".`),r}return s(`StorageAdapter - Using plain key: "${t}"`),t}_startExpireWatcher(){this._expireTimer&&clearInterval(this._expireTimer),!(this.expireCheckInterval<=0)&&(this._expireTimer=setInterval(()=>{try{s("StorageAdapter - Running expiration cleanup..."),this.clearExpire()}catch(e){n("Error clearing expired keys:",e)}},this.expireCheckInterval),s(`StorageAdapter - Expire watcher started, interval: ${this.expireCheckInterval}ms`))}destroy(){this._expireTimer&&(clearInterval(this._expireTimer),this._expireTimer=null,s("StorageAdapter - Expire watcher stopped.")),this._unloadHandler&&(window.removeEventListener("beforeunload",this._unloadHandler),this._unloadHandler=null,s("StorageAdapter - Removed unload handler."))}async getAll(e){return s(`StorageAdapter - Getting all keys under table: "${e}"`),this.list(`${e}__`)}async getExpire(e){try{let t=await this._loadExpires();return s(`StorageAdapter - Getting expiration for key "${e}":`,t[e]||null),t[e]||null}catch(t){return n(`Error getting expire for key '${e}':`,t),null}}emitDataChange(e,t,r){!this.channelName||!r||(s(`StorageAdapter - Emitting data change for key "${e}" from origin "${r}"`),this.channel.emit({adapterId:this.adapterId,key:e,value:t,origin:r}))}onDataChanged(e){!this.channelName||typeof e!="function"||(s("StorageAdapter - Subscribing to cross-tab data changes."),this.channel.subscribe(e))}},y=v;import te from"misc-helpers/src/utils/sleep.js";import re from"misc-helpers/src/utils/generateSimpleId.js";var L=class extends y{constructor({dbName:e,storeName:t,version:r=1,encrypt:i=!1,expireCheckInterval:a=1e3,channelName:c=!1,enableSyncTabs:l=!1,description:h=""}){if(super(c),typeof indexedDB>"u")throw n("IndexedDB is not available in this environment"),new Error("IndexedDB is not available in this environment");this.isReady=!1,this.dbName=e,this.storeName=t||`${e}_store`,this.encrypt=i,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=re(e),this.enableSyncTabs=l||!1,this.expireCheckInterval=a,this.dbPromise=null,this._initDB({dbName:e,version:r,description:h}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),s(`IndexedDBAdapter - initialized with dbName: ${e}, storeName: ${this.storeName}`)}_initDB({dbName:e,version:t,description:r}){s(`IndexedDBAdapter -Initializing IndexedDB with dbName: ${e}, storeName: ${this.storeName}`),this.dbPromise=new Promise((i,a)=>{let c=indexedDB.open(e,t);c.onupgradeneeded=l=>{let h=l.target.result;h.objectStoreNames.contains(this.storeName)||h.createObjectStore(this.storeName);let p={dbName:e,version:t,description:r,createdAt:Date.now()};l.target.transaction.objectStore(this.storeName).put(JSON.stringify(p),this.metaKey)},c.onsuccess=l=>{let h=l.target.result,C=h.transaction(this.storeName,"readwrite").objectStore(this.storeName),b=C.get(this.metaKey);b.onsuccess=()=>{if(!b.result){let K={dbName:e,version:t,description:r,createdAt:Date.now()};C.put(JSON.stringify(K),this.metaKey)}this.isReady=!0,i(h)},b.onerror=K=>{n("Error checking meta:",K),i(h)}},c.onerror=l=>{n("Error opening database:",l.target.error),a(l.target.error)}})}async waitReadiness(e=50,t=20){return s(`IndexedDBAdapter - Waiting for database readiness with timeout: ${e}ms, tries: ${t}`),new Promise(async(r,i)=>{let a=0;for(;!this.isReady&&a++<=t;){if(this.isReady)return r(),!0;await te(e)}if(this.isReady)return r(),!0;i(new Error("Database is not ready"))})}async _withStore(e,t){try{s(`IndexedDBAdapter - Executing operation in ${e} mode`);let a=(await this.dbPromise).transaction(this.storeName,e).objectStore(this.storeName);return await t(a)}catch(r){throw n("Database operation failed:",r),r}}async _loadExpires(){return s("IndexedDBAdapter - Loading expiration timestamps"),this._withStore("readonly",async e=>new Promise(t=>{let r=e.get(this.expireKey);r.onsuccess=()=>{t(r.result?JSON.parse(r.result):{})},r.onerror=()=>{t({})}}))}async get(e){try{s(`IndexedDBAdapter - Getting key: ${e}`);let t=this._fullKey(e),r=await this._withStore("readonly",a=>new Promise(c=>{let l=a.get(t);l.onsuccess=()=>c(l.result),l.onerror=()=>c(null)}));if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return n(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(s(`IndexedDBAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let a=await this._encrypt(e,t);return a?(await this._withStore("readwrite",c=>new Promise(l=>{let h=c.put(a,i);h.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),l(!0)},h.onerror=()=>l(!1)})),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return n(`Error setting key '${e}':`,i),!1}}async delete(e){try{s(`IndexedDBAdapter - Deleting key: ${e}`);let t=this._fullKey(e);await this._withStore("readwrite",i=>new Promise(a=>{let c=i.delete(t);c.onsuccess=()=>{this.enableSyncTabs&&this.emitDataChange(e,void 0,"reset"),a(!0)},c.onerror=()=>a()}));let r=await this._loadExpires();delete r[e],await this._withStore("readwrite",i=>new Promise(a=>{let c=i.put(JSON.stringify(r),this.expireKey);c.onsuccess=()=>a(),c.onerror=()=>a()}))}catch(t){n(`Error deleting key '${e}':`,t)}}async list(){let e=[];try{s(`IndexedDBAdapter - Listing keys with prefix: ${this.prefix}`),await this._withStore("readonly",async t=>new Promise(r=>{let i=t.getAllKeys();i.onsuccess=async()=>{let a=i.result||[];for(let c of a)if(this.encrypt&&(c=g(c)),!(c===this.metaKey||c===this.expireKey)&&c.startsWith(this.prefix)){let l=await this.get(c.replace(this.prefix,""));l!==null&&e.push({key:c.replace(this.prefix,""),value:l})}r()},i.onerror=()=>r()}))}catch(t){n("Error listing keys:",t)}return e}async has(e){try{s(`IndexedDBAdapter - Checking existence of key: ${e}`);let t=this._fullKey(e);return await this._withStore("readonly",r=>new Promise(i=>{let a=r.getKey(t);a.onsuccess=()=>i(a.result!==void 0),a.onerror=()=>i(!1)}))}catch(t){return n(`Error checking key '${e}':`,t),!1}}async clear(){try{s("IndexedDBAdapter - Clearing all data"),await this.reset(),await this._withStore("readwrite",e=>new Promise(t=>{let r=e.delete(this.metaKey);r.onsuccess=()=>{let i=e.delete(this.expireKey);i.onsuccess=()=>t(),i.onerror=()=>t()},r.onerror=()=>t()}))}catch(e){n("Error clearing storage:",e)}}async reset(){try{s("IndexedDBAdapter - Resetting storage"),await this._withStore("readwrite",async e=>new Promise(t=>{let r=e.getAllKeys();r.onsuccess=()=>{let i=r.result||[];if(i.length===0){t();return}let a=0,c=l=>()=>{++a===i.length&&(this.enableSyncTabs&&this.emitDataChange(l.replace(this.prefix,""),"reset"),t())};for(let l of i){let h=e.delete(l);h.onsuccess=c(l),h.onerror=c(l)}},r.onerror=()=>t()}))}catch(e){n("Error resetting storage:",e)}}async setExpire(e,t){try{s(`IndexedDBAdapter - Setting expire for key: ${e}, timestamp: ${t}`);let r=await this._loadExpires();r[e]=t,await this._withStore("readwrite",i=>new Promise(a=>{let c=i.put(JSON.stringify(r),this.expireKey);c.onsuccess=()=>a(),c.onerror=()=>a()}))}catch(r){n(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{s(`IndexedDBAdapter - Deleting expire for key: ${e}`);let t=await this._loadExpires();delete t[e],await this._withStore("readwrite",r=>new Promise(i=>{let a=r.put(JSON.stringify(t),this.expireKey);a.onsuccess=()=>i(),a.onerror=()=>i()}))}catch(t){n(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{s("IndexedDBAdapter - Clearing expired keys");let e=Date.now(),t=await this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);if(r){let i=await this._loadExpires();await this._withStore("readwrite",a=>new Promise(c=>{let l=a.put(JSON.stringify(i),this.expireKey);l.onsuccess=()=>c(),l.onerror=()=>c()}))}}catch(e){n("Error clearing expired keys:",e)}}},A=L;import ie from"misc-helpers/src/utils/generateSimpleId.js";var P=class extends y{constructor({dbName:e,version:t=1,encrypt:r=!1,expireCheckInterval:i=1e3,description:a="",channelName:c=!1,enableSyncTabs:l=!1}){if(super(c),typeof localStorage>"u")throw n("LocalStorage is not available in this environment"),new Error("LocalStorage is not available in this environment");this.dbName=e,this.encrypt=r,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=ie(e),this.expireCheckInterval=i,this.enableSyncTabs=l||!1,this._initMeta({dbName:e,version:t,description:a}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),s(`LocalStorageAdapter -  initialized with dbName: ${e}, version: ${t}, encrypt: ${r}, description: ${a}`)}_initMeta({dbName:e,version:t,description:r}){try{s("LocalStorageAdapter - Initializing metadata for LocalStorageAdapter");let i={dbName:e,version:t,description:r,createdAt:Date.now()};localStorage.setItem(this.metaKey,JSON.stringify(i))}catch(i){n("Error initializing meta:",i)}}_loadExpires(){try{s("LocalStorageAdapter - Loading expiration metadata");let e=localStorage.getItem(this.expireKey);return e?JSON.parse(e):{}}catch(e){return n("Error loading expires:",e),{}}}async get(e){try{s(`LocalStorageAdapter - Getting key: ${e}`);let t=this._fullKey(e),r=localStorage.getItem(t);if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return n(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(s(`LocalStorageAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let a=await this._encrypt(e,t);return a?(localStorage.setItem(i,a),this.enableSyncTabs&&this.emitDataChange(e,void 0,"set"),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return n(`Error setting key '${e}':`,i),!1}}async delete(e){try{s(`LocalStorageAdapter - Deleting key: ${e}`);let t=this._fullKey(e);localStorage.removeItem(t);let r=this._loadExpires();delete r[e],localStorage.setItem(this.expireKey,JSON.stringify(r)),this.enableSyncTabs&&this.emitDataChange(e,void 0,"delete")}catch(t){n(`Error deleting key '${e}':`,t)}}async list(){let e=[];s(`LocalStorageAdapter - Listing keys with prefix: ${this.prefix}`);try{for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);if(this.encrypt&&(r=g(r)),!(r===this.metaKey||r===this.expireKey)&&r.startsWith(this.prefix)){let i=await this.get(r.replace(this.prefix,""));i!==null&&e.push({key:r.replace(this.prefix,""),value:i})}}}catch(t){throw n("Error listing keys:",t),t}return e}async has(e){try{s(`LocalStorageAdapter - Checking existence of key: ${e}`);let t=this._fullKey(e);return localStorage.getItem(t)!==null}catch(t){return n(`Error checking key '${e}':`,t),!1}}async clear(){try{s("LocalStorageAdapter - Clearing all data"),await this.reset(),localStorage.removeItem(this.metaKey),localStorage.removeItem(this.expireKey)}catch(e){n("Error clearing storage:",e)}}async reset(){try{s("LocalStorageAdapter - Resetting storage");let e=[];for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);r.startsWith(this.prefix)&&e.push(r)}for(let t of e)localStorage.removeItem(t),this.enableSyncTabs&&this.emitDataChange(t.replace(this.prefix,""),void 0,"reset")}catch(e){n("Error resetting storage:",e)}}async setExpire(e,t){try{s(`LocalStorageAdapter - Setting expiration for key: ${e}`,{timestamp:t});let r=this._loadExpires();r[e]=t,localStorage.setItem(this.expireKey,JSON.stringify(r))}catch(r){n(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{s(`LocalStorageAdapter - Deleting expiration for key: ${e}`);let t=this._loadExpires();delete t[e],localStorage.setItem(this.expireKey,JSON.stringify(t))}catch(t){n(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{s("LocalStorageAdapter - Clearing expired keys");let e=Date.now(),t=this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);r&&localStorage.setItem(this.expireKey,JSON.stringify(this._loadExpires()))}catch(e){n("Error clearing expired keys:",e)}}},D=P;import se from"misc-helpers/src/utils/generateSimpleId.js";var J=class extends y{constructor({dbName:e,version:t=1,encrypt:r=!1,expireCheckInterval:i=1e3,channelName:a=!1,description:c="",enableSyncTabs:l=!1}){if(super(a),typeof sessionStorage>"u")throw n("SessionStorage is not available in this environment"),new Error("SessionStorage is not available in this environment");this.dbName=e,this.encrypt=r,this.expireKey=`STRGF_${e}__expires`,this.metaKey=`STRGF_${e}__meta`,this.prefix=`${e}__`,this.adapterId=se(e),this.expireCheckInterval=i,this.enableSyncTabs=l||!1,this._initMeta({dbName:e,version:t,description:c}),this._startExpireWatcher(),this._unloadHandler=()=>this.destroy(),window.addEventListener("beforeunload",this._unloadHandler),s(`SessionStorageAdapter - initialized with prefix: ${this.prefix}, encrypt: ${this.encrypt}`)}_initMeta({dbName:e,version:t,description:r}){try{s(`SessionStorageAdapter - Initializing metadata for ${e} v${t}`);let i={dbName:e,version:t,description:r,createdAt:Date.now()};sessionStorage.setItem(this.metaKey,JSON.stringify(i))}catch(i){n("Error initializing meta:",i)}}_loadExpires(){try{s("SessionStorageAdapter - Loading expiration map");let e=sessionStorage.getItem(this.expireKey);return e?JSON.parse(e):{}}catch(e){return n("Error loading expires:",e),{}}}async get(e){try{s(`SessionStorageAdapter - Getting key '${e}'`);let t=this._fullKey(e),r=sessionStorage.getItem(t);if(!r)return null;let i=await this.getExpire(e);return i&&Date.now()>=i?(await this.delete(e),null):await this._decrypt(e,r)}catch(t){return n(`Error getting key '${e}':`,t),null}}async set(e,t,r){try{if(s(`SessionStorageAdapter - Setting key: ${e}`,{value:t,expire:r}),!e&&!t)return!1;let i=this._fullKey(e);if(e&&t==null)return await this.delete(i),null;t=JSON.stringify(t);let a=await this._encrypt(e,t);return a?(sessionStorage.setItem(i,a),this.enableSyncTabs&&this.emitDataChange(e,a,"set"),typeof r!="number"?(await this.deleteExpire(e),!0):r>0?(await this.setExpire(e,Date.now()+r),!0):(await this.delete(e),null)):!1}catch(i){return n(`Error setting key '${e}':`,i),!1}}async delete(e){try{s(`SessionStorageAdapter - Deleting key '${e}'`);let t=this._fullKey(e);sessionStorage.removeItem(t);let r=this._loadExpires();delete r[e],sessionStorage.setItem(this.expireKey,JSON.stringify(r)),this.enableSyncTabs&&this.emitDataChange(e,void 0,"delete")}catch(t){n(`Error deleting key '${e}':`,t)}}async list(){let e=[];try{s(`SessionStorageAdapter - Listing keys with prefix '${this.prefix}'`);for(let t=0;t<sessionStorage.length;t++){let r=sessionStorage.key(t);if(this.encrypt&&(r=g(r)),!(r===this.metaKey||r===this.expireKey)&&r.startsWith(this.prefix)){let i=await this.get(r.replace(this.prefix,""));i!==null&&e.push({key:r.replace(this.prefix,""),value:i})}}}catch(t){throw n("Error listing keys:",t),t}return e}async has(e){try{s(`SessionStorageAdapter - Checking existence of key '${e}'`);let t=this._fullKey(e);return sessionStorage.getItem(t)!==null}catch(t){return n(`Error checking key '${e}':`,t),!1}}async clear(){try{s("SessionStorageAdapter - Clearing all data"),await this.reset(),sessionStorage.removeItem(this.metaKey),sessionStorage.removeItem(this.expireKey)}catch(e){n("Error clearing storage:",e)}}async reset(){try{s("SessionStorageAdapter - Resetting storage");let e=[];for(let t=0;t<sessionStorage.length;t++){let r=sessionStorage.key(t);r.startsWith(this.prefix)&&e.push(r)}for(let t of e)sessionStorage.removeItem(t),this.enableSyncTabs&&this.emitDataChange(t.replace(this.prefix,""),void 0,"reset")}catch(e){n("Error resetting storage:",e)}}async setExpire(e,t){try{s(`SessionStorageAdapter - Setting expire for key '${e}'`);let r=this._loadExpires();r[e]=t,sessionStorage.setItem(this.expireKey,JSON.stringify(r))}catch(r){n(`Error setting expire for key '${e}':`,r)}}async deleteExpire(e){try{s(`SessionStorageAdapter - Deleting expire for key '${e}'`);let t=this._loadExpires();delete t[e],sessionStorage.setItem(this.expireKey,JSON.stringify(t))}catch(t){n(`Error deleting expire for key '${e}':`,t)}}async clearExpire(){try{s("SessionStorageAdapter - Clearing expired keys");let e=Date.now(),t=this._loadExpires(),r=!1;for(let i in t)t[i]<=e&&(await this.delete(i),r=!0);r&&sessionStorage.setItem(this.expireKey,JSON.stringify(this._loadExpires()))}catch(e){n("Error clearing expired keys:",e)}}},I=J;var R=class{async setInStorage(e,t,r={}){throw new Error("Not implemented")}async getFromStorage(e,t,r){throw new Error("Not implemented")}destroy(e){if(this.stores&&this.stores[e]&&typeof this.stores[e].unsubscribe=="function"){s("StoreAdapter - destroy - Unsubscribing from store changes."),this.stores[e].unsubscribe,delete this.stores[e];return}s("StoreAdapter - destroy - No unsubscribe function to call.")}},S=R;import ne from"misc-helpers/src/utils/assign.js";var F=class extends S{constructor(e){if(super(),!e)throw n("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this.stores={}}_checkStore(e){if(!e||!e.$subscribe||!e.$patch)throw n("Store provided is not defined"),new Error("Store provided is not defined")}_registerOnDataChanged(e){s("PiniaAdapter - Registering onDataChanged listener"),!(!e||!this.stores||!this.stores[e])&&this.adapter.onDataChanged(async t=>{try{if(t.adapterId==this.adapter.adapterId||!t.origin||!this.stores||!this.stores[t.key]||!this.stores[t.key].store)return;let r;if(t.value?r=await this.adapter._decrypt(t.key,t.value):r=await this.adapter.get(t.key),JSON.stringify(!this.stores[t.key].store.$state)===JSON.stringify(r))return;this.stores[t.key].store.$state={...this.stores[t.key].store.$state,...r,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}}catch(r){n("PiniaAdapter - onDataChanged - error:",r)}})}async setInStorage(e,t,r={}){try{return s("PiniaAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this.stores[t]&&this.stores[t].unsubscribe&&typeof this.stores[t].unsubscribe=="function"&&this.stores[t].unsubscribe(),delete this.stores[t],this.stores[t]={key:t,options:r,store:e,unsubscribe:null},new Promise((i,a)=>{this.stores[t].unsubscribe=e.$subscribe(async(c,l)=>{try{if(!l)return i(!0);if(l.STORAGEFY_SILENT_CHANNEL_UPDATE)return delete l.STORAGEFY_SILENT_CHANNEL_UPDATE,i(!0);let h={...l};for(let p in h)r.ignoreKeys.includes(p)&&(h[p]=void 0);return await this.adapter.set(t,h,r.timeout),i(!0)}catch(h){return a(h)}}),e.$patch({...e.$state}),r.syncTabs&&this._registerOnDataChanged(t)})}catch(i){throw n(i),i}}async getFromStorage(e,t){try{s("PiniaAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);return r?(e.$patch(ne({},r)),!0):void 0}catch(r){throw n(r),r}}},H=F;import oe from"misc-helpers/src/utils/assign.js";var B=class extends S{constructor(e){if(super(),!e)throw n("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this.stores={}}_getPayload(e,t){return{...e,...t,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}}_registerOnDataChanged(e){!e||!this.stores||!this.stores[e]||(s("ReactAdapter - Registering onDataChanged listener"),this.adapter.onDataChanged(async t=>{try{if(t.adapterId==this.adapter.adapterId||!t.origin||!this.stores||!this.stores[t.key]||!this.stores[t.key].store)return;let r=this.stores[t.key].store,i;if(t.value?i=await this.adapter._decrypt(t.key,t.value):i=await this.adapter.get(t.key),typeof r.dispatch=="function"&&typeof r.getState=="function"){let c=r.getState();if(JSON.stringify(c)===JSON.stringify(i))return;r.dispatch({type:"STORAGEFY_UPDATE",payload:this._getPayload(c,i)});return}if(typeof r.getState=="function"&&typeof r.setState=="function"){let c=r.getState();if(JSON.stringify(c)===JSON.stringify(i))return;r.setState(this._getPayload(c,i));return}if(typeof r.set=="function"&&typeof r.get=="function"){let c=r.get();if(JSON.stringify(c)===JSON.stringify(i))return;r.set(this._getPayload(c,i));return}if(typeof r.update=="function"){r.update(c=>JSON.stringify(c)===JSON.stringify(i)?c:this._getPayload(c,i));return}let a=typeof r.getState=="function"?r.getState():typeof r.get=="function"?r.get():{};if(JSON.stringify(a)===JSON.stringify(i))return;typeof r.set=="function"?r.set(this._getPayload(a,i)):n("Unable to update store: No compatible update method found")}catch(r){n("Error in _registerOnDataChanged:",r)}}))}async setInStorage(e,t,r={}){try{return s("ReactAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this.stores[t]&&this.stores[t].unsubscribe&&typeof this.stores[t].unsubscribe=="function"&&this.stores[t].unsubscribe(),delete this.stores[t],this.stores[t]={key:t,options:r,store:e,unsubscribe:null},new Promise((i,a)=>{let c=async l=>{try{if(!l)return;if(l.STORAGEFY_SILENT_CHANNEL_UPDATE)return delete l.STORAGEFY_SILENT_CHANNEL_UPDATE,i(!0);let h={...l};for(let p in h)r.ignoreKeys.includes(p)&&(h[p]=void 0);await this.adapter.set(t,h,r.timeout)}catch(h){n(h)}};if(typeof e.subscribe=="function"&&typeof e.getState=="function")c(e.getState()),this.stores[t].unsubscribe=e.subscribe(()=>{c(e.getState())});else if(typeof e.subscribe=="function")this.stores[t].unsubscribe=e.subscribe(c);else{a(new Error("Unsupported store type"));return}r.syncTabs&&this._registerOnDataChanged(t),i(!0)})}catch(i){throw n(i),i}}async getFromStorage(e,t){try{s("ReactAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);if(!r)return;if(typeof e.dispatch=="function")e.dispatch({type:"SET_STATE_FROM_STORAGE",payload:r});else if(typeof e.setState=="function")e.setState(oe({},r));else throw new Error("Cannot update store: setState or dispatch method not found");return!0}catch(r){throw n(r),r}}_checkStore(e){if(!e)throw n("Store provided is not defined"),new Error("Store provided is not defined");if(typeof e.getState=="function"&&typeof e.dispatch=="function"&&typeof e.subscribe=="function"||typeof e.getState=="function"&&typeof e.setState=="function"&&typeof e.subscribe=="function"||Array.isArray(e)&&e.length===2&&typeof e[0]=="function"&&typeof e[1]=="function")return;let t=typeof e.getState=="function"||typeof e._getState=="function",r=typeof e.setState=="function"||typeof e._setState=="function";if(!(typeof e.subscribe=="function"))throw n("Store must have a subscribe method"),new Error("Store must have a subscribe method");if(!t&&!r)throw n("Store must have either getState/setState or _getState/_setState methods"),new Error("Store must have either getState/setState or _getState/_setState methods")}},G=B;import j from"misc-helpers/src/utils/assign.js";var q=class extends S{constructor(e){if(super(),!e)throw n("Adapter provided is not defined"),new Error("Adapter provided is not defined");this.adapter=e,this.stores={}}_registerOnDataChanged(e){if(s("SvelteAdapter - Registering onDataChanged listener"),!(!e||!this.stores||!this.stores[e]))try{if(!store)return;this.adapter.onDataChanged(async t=>{if(t.adapterId==this.adapter.adapterId||!t.origin||!this.stores||!this.stores[t.key]||!this.stores[t.key].store)return;let r;this.stores[t.key].store.subscribe(c=>{r=j({},c)})();let a;t.value?a=await this.adapter._decrypt(t.key,t.value):a=await this.adapter.get(t.key),JSON.stringify(r)!==JSON.stringify(a)&&this.stores[t.key].store.update(c=>({...c,...a,STORAGEFY_SILENT_CHANNEL_UPDATE:!0}))})}catch(t){throw n("SvelteAdapter - onDataChanged error:",t),t}}async setInStorage(e,t,r={}){try{return s("SvelteAdapter - setInStorage - key:",t),this._checkStore(e),r.ignoreKeys=r.ignoreKeys||[],this.stores[t]&&this.stores[t].unsubscribe&&typeof this.stores[t].unsubscribe=="function"&&this.stores[t].unsubscribe(),delete this.stores[t],this.stores[t]={key:t,options:r,store:e,unsubscribe:null},new Promise((i,a)=>{this.stores[t].unsubscribe=e.subscribe(async c=>{try{if(!c)return i(!0);let l={...c};for(let h in l)r.ignoreKeys.includes(h)&&(l[h]=void 0);return await this.adapter.set(t,l,r.timeout),i(!0)}catch(l){return a(l)}}),r.syncTabs&&this._registerOnDataChanged(t)})}catch(i){throw n(i),i}}async getFromStorage(e,t){try{s("SvelteAdapter - getFromStorage - key:",t),this._checkStore(e);let r=await this.adapter.get(t);return r?(e.set(j({},r)),!0):void 0}catch(r){throw n(r),r}}_checkStore(e){if(!e||typeof e.subscribe!="function"||typeof e.set!="function")throw n("Store provided is not a valid Svelte writable store"),new Error("Store provided is not a valid Svelte writable store")}},W=q;var ae={dbName:"storagefy",storeName:"storagefy_db",version:1,encrypt:!1,expireCheckInterval:1e3,description:"Storagefy database",adapter:"indexedDB"},f,d,w,m;function ft(o={}){let e={...ae,...o};if(!o.forceRecreate&&f)return f;switch(e.adapter){case"localStorage":if(o.fresh)return new D(e);f=new D(e);break;case"sessionStorage":if(o.fresh)return new I(e);f=new I(e);break;default:if(o.fresh)return new A(e);f=new A(e)}return f}function dt(){if(!f)throw new Error("Storage adapter not initialized. Call startStoragefy first.");return f}function x({adapter:o,adapterParams:e,forceRecreate:t},r,i){if(o)return new i(o);if(r&&!t)return r;if(e){let a=ce(e);return new i(a)}if(!f)throw new Error("Storage adapter not initialized. Call startStoragefy first.");return new i(f)}function ce(o){switch(o.adapter){case"localStorage":return new D(o);case"sessionStorage":return new I(o);default:return new A(o)}}function le({adapter:o=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?x({adapter:o,adapterParams:e,forceRecreate:t},null,H):(d=x({adapter:o,adapterParams:e,forceRecreate:t},d,H),{setInStorage:d.setInStorage.bind(d),getFromStorage:d.getFromStorage.bind(d)})}function he({adapter:o=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?x({adapter:o,adapterParams:e,forceRecreate:t},null,G):(w=x({adapter:o,adapterParams:e,forceRecreate:t},w,G),w)}function fe({adapter:o=null,adapterParams:e=null,forceRecreate:t=!1,fresh:r=!1}={}){return r?x({adapter:o,adapterParams:e,forceRecreate:t},null,W):(m=x({adapter:o,adapterParams:e,forceRecreate:t},m,W),m)}async function pt(o,e,t={}){try{if(d||le(),!o)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await d.getFromStorage(o,e),await d.setInStorage(o,e,t)}catch(r){throw logError(r),r}}async function ut(o,e,t={}){try{if(w||he(),!o)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await w.getFromStorage(o,e),await w.setInStorage(o,e,t)}catch(r){throw logError(r),r}}async function gt(o,e,t={}){try{if(m||fe(),!o)throw new Error("Store is required.");if(!e)throw new Error("Key is required.");await m.getFromStorage(o,e),await m.setInStorage(o,e,t)}catch(r){throw logError(r),r}}export{A as IndexedDBAdapter,D as LocalStorageAdapter,H as PiniaAdapter,G as ReactAdapter,I as SessionStorageAdapter,W as SvelteAdapter,le as getPiniaAdapter,he as getReactAdapter,dt as getStorageAdapter,fe as getSvelteAdapter,pt as setPiniaStorage,ut as setReactStorage,gt as setSvelteStorage,ft as startStoragefy};
//# sourceMappingURL=index.js.map